// Seq_XYZRobot.cpp: implementation of the CSeq_XYZRobot class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "handler.h"
#include "Seq_XYZRobot.h"
#include <TIME.H>

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////
CSeq_XYZRobot	SeqXYZRobot;

CSeq_XYZRobot::CSeq_XYZRobot()
{
	// 모터 번호 할당
	m_nMotY = M_BCRREAD_ROBOT_Y;
	m_nMotX = M_BCRREAD_ROBOT_X;
	m_nMotZ = M_BCRREAD_ROBOT_Z;

	// yangkyu [2015.02.22]
	// 번호는 메인 설비 정면 기준으로 0(앞쪽 좌), 1(앞쪽 우), 2(뒤쪽 좌), 3(뒤쪽 우)
	//m_nMotGrip1 = M_GRIP_ROBOT_2;
	//m_nMotGrip2 = M_GRIP_ROBOT_4;
	//m_nMotGrip3 = M_GRIP_ROBOT_1;
	//m_nMotGrip4 = M_GRIP_ROBOT_3;
	// yangkyu [2015.03.25]
	// 모터 값 수정
	m_nMotGrip1 = M_GRIP_ROBOT_1;
	m_nMotGrip2 = M_GRIP_ROBOT_2;
	m_nMotGrip3 = M_GRIP_ROBOT_3;
	m_nMotGrip4 = M_GRIP_ROBOT_4;

	// yangkyu [2015.02.23]
	// 번호는 메인 설비 정면 기준으로 0(앞쪽 좌), 1(앞쪽 우), 2(뒤쪽 좌), 3(뒤쪽 우)
	//m_nMotZ0 = M_LIFTER_Z2;
	//m_nMotZ1 = M_LIFTER_Z4;
	//m_nMotZ2 = M_LIFTER_Z1;
	//m_nMotZ3 = M_LIFTER_Z3;
	// yangkyu [2015.03.25]
	// 모터 값 수정
	m_nMotZ0 = M_LIFTER_Z1;
	m_nMotZ1 = M_LIFTER_Z2;
	m_nMotZ2 = M_LIFTER_Z3;
	m_nMotZ3 = M_LIFTER_Z4;

	// 테스트용 플래그 (일시적으로 사용)
	// 현재 그립퍼 모터가 하나 고장난 관계로 모터가 구동되지 않아 추가됨
	// - 추후에 모터 살아나면 이 부분 해제하면 됨
	// - 모터가 정상이면 그립퍼 모터는 반드시 Homing 작업 후 안전 위치로 보내는 작업 필요하게 됨
	//m_nflag_GripSkip = FALSE;
	m_nflag_GripSkip = TRUE;
}

CSeq_XYZRobot::~CSeq_XYZRobot()
{

}

//==================================================================//
// 쓰레드 동작
//==================================================================//
void CSeq_XYZRobot::OnSeq_RUN(void) 
{
	OnSeq_INIT();     // 쓰레드 관련 변수 초기화
	OnSeq_Execute();  // 쓰레드 제어
}

//==================================================================//
// 쓰레드 관련 변수 초기화
//==================================================================//
void CSeq_XYZRobot::OnSeq_INIT(void) 
{
	if (m_bflag_INIT == true)	{
		return;
	}
	m_bflag_INIT = true;

	// 규이리 추가 [2015.03.13]
	// SingleMove 스텝 정보 초기화
	CTL_Lib.OnReset_SingleMoveStep(m_nMotY);
	CTL_Lib.OnReset_SingleMoveStep(m_nMotX);
	CTL_Lib.OnReset_SingleMoveStep(m_nMotZ);
	CTL_Lib.OnReset_SingleMoveStep(m_nMotGrip1);
	CTL_Lib.OnReset_SingleMoveStep(m_nMotGrip2);
	CTL_Lib.OnReset_SingleMoveStep(m_nMotGrip3);
	CTL_Lib.OnReset_SingleMoveStep(m_nMotGrip4);

	m_nStep_Init	= 0;
	m_nStep_Run		= 0;
	m_nStep_Rcvy	= 0;

	m_nStep_BCRRead			= 0;
	m_nStep_BCRBad			= 0;
	m_nStep_ReadMove		= 0;
	m_nStep_NG_Buff	= 0;
	m_nStep_BufferConvClear	= 0;
	m_nStep_NGAccyOut		= 0;
	m_nStep_ForceDischarge	= 0;
	
	m_nGirpSum = 0;
	m_nGripRetryCnt = 0;
	
	m_nStep_GripRetry		= 0;
	// yangkyu [2015.03.05]
	m_nStep_BufferConvPlace	= 0;
	// 규이리 추가 [2015.02.25]
	m_nStep_Grip			= 0;
	m_nStep_AccyVacPick		= 0;
	m_nStep_AccyGripPick	= 0;
	m_nStep_WorkSiteChange	= 0;
	m_nStep_AccyPlace		= 0;

	m_nStep_NGBufferPlace = 0;
	m_nStep_NGBufferPick = 0;
	
	st_map.nSupplyTypeMath	= 0;

	// yangkyu [2015.03.19]
	m_sCurrntAccyMathCode = "";

	// [리셋] 복구 동작 요청 플래그
	stSync.nRcvyComplete[SITE_XYZ_ROBOT_] = CTL_YES;
}

//==================================================================//
// 쓰레드 제어
//==================================================================//
void CSeq_XYZRobot::OnSeq_Execute(void) 
{
	// 시컨스 인터럽트 조건 확인
	if (Func.OnIsInterruptCondition() == 1)
	{
		return;
	}
	int nRet = 0;


	switch(st_work.nEqpStatus)
	{
	case dINIT:
		// 초기화 진행 대화상자에서 [YES] 선택했는지 여부
		if (st_handler.nInitTryREQ != YES)
		{
			break;
		}
		OnRun_Initial();  // XYZRobot 초기화 작업
		break;
		
	case dRUN:
		// 복구 동작 실행 후 시컨스 동작 진행함
		if (stSync.nRcvyComplete[SITE_XYZ_ROBOT_] == CTL_NO)
		{
			//nRet = OnRcvy_RobotPos();	// XYZRobot 버퍼 모터의 위치 복구 동작
			nRet = CTL_GOOD;
			if (nRet == CTL_GOOD)
			{
				stSync.nRcvyComplete[SITE_XYZ_ROBOT_] = CTL_YES;
			}
		}
		else
		{
			// 초기화 작업이 완료되지 않으면 [AUTO] 작업 시작 불가능
			// - st_handler.nIsAllSiteInitEnd : 초기화 화면에서 설정
			if (st_handler.nIsAllSiteInitEnd == CTL_YES)
			{
				OnRun_Move();	// XYZRobot 버퍼 모터의 시컨스 동작
			}
		}
		break;

	default:
		// 복구 동작 필요하다고 설정함
		if (stSync.nRcvyComplete[SITE_XYZ_ROBOT_] != CTL_NO)
		{
			stSync.nRcvyComplete[SITE_XYZ_ROBOT_] = CTL_NO;
		}

		if (st_work.nForceDischarge != FORCEDISCHARGE_ON)
		{
			// SingleMove 스텝 정보 초기화
			//////////////////////////////////////////////////////////////////////////
			CTL_Lib.OnReset_SingleMoveStep(m_nMotY);
			CTL_Lib.OnReset_SingleMoveStep(m_nMotX);
			CTL_Lib.OnReset_SingleMoveStep(m_nMotZ);
			CTL_Lib.OnReset_SingleMoveStep(m_nMotGrip1);
			CTL_Lib.OnReset_SingleMoveStep(m_nMotGrip2);
			CTL_Lib.OnReset_SingleMoveStep(m_nMotGrip3);
			CTL_Lib.OnReset_SingleMoveStep(m_nMotGrip4);
			//////////////////////////////////////////////////////////////////////////
		}

		// yangkyu 2015.03.31
		// Run 상태일때가 아닌 Stop 상태일때 동작을 하도록 수정.
		OnRun_ForceDischarge();

		break;
	}
}

//==================================================================//
// [SSD] 플립퍼 로봇의 초기화 작업
//==================================================================//
void CSeq_XYZRobot::OnRun_Initial() 
{
	// 초기화 작업이 완료된 경우 강제 리턴
	if (st_handler.mn_init_state[INIT_XYZ_ROBOT] != CTL_NO)
	{
		return;
	}
	int nRet = VAR_INIT_;
	int i;
	int nRetData[4] = {0,};

	switch(m_nStep_Init)
	{
	case 0:
		// 구조체 정보 초기화
		memset(st_map.nXYZRbtPickerInfo, 0, sizeof(st_map.nXYZRbtPickerInfo));
		st_map.nNGOutCNT = 0;	// NG 버퍼에 버려진 악세사리 갯수

		m_nStep_Init = 100;
		break;

	case 100:
		// Z축 모터 Homing
		nRet = g_comiMgr.HomeCheck_Mot(m_nMotZ, 0, MOT_TIMEOUT);
		if (nRet == CTLBD_RET_GOOD)
		{
			//m_nStep_Init = 120;
			// 규이리 수정 [2015.03.13]
			m_nStep_Init = 110;
		}
		else if (nRet == CTLBD_RET_ERROR)
		{
			// 070003 0 07 "BARCODE_ROBOT_Z_HOMING_ERR."
			alarm.mstr_code		= "070003";
			alarm.mn_count_mode	= 0;
			alarm.mn_type_mode	= eWARNING;
			st_work.nEqpStatus	= dWARNING;
		}
		break;

		// 규이리 위치 이동 [2014.03.13]
	case 110:
		nRet = CTL_Lib.OnSingleMove(m_nMotZ, st_motor[m_nMotZ].d_pos[Z_RBT_SAFETY_], (int)st_handler.md_run_speed);
		if (nRet == CTLBD_RET_GOOD)
		{
			m_nStep_Init = 120;
		}
		else if (nRet == CTLBD_RET_ERROR || nRet == CTLBD_RET_RETRY)
		{
			// 071005 0 00 "BARCODE_ROBOT_Z_RBT_SAFETY_MOVE_ERR."
			alarm.mstr_code		= "071005";
			alarm.mn_count_mode	= 0;
			alarm.mn_type_mode	= eWARNING;
			st_work.nEqpStatus	= dWARNING;
		}
		break;

	case 120:
		// 악세사리 공급용 리프터가 Homing 작업 완료할때까지 기다림
		// - 문제가 있어 리프터가 최대로 올라와 있는 경우 악세사리가 높게 쌓여지게 되서 xyz 로봇과 충돌 가능성 있음
		// - 기구적으로 파손 위험은 없지만 악세사리가 설비 바닥에 흩어질 수 있어 조건 추가됨
		if (st_work.nLiftDownComplete == CTL_YES)
		{
			m_nStep_Init = 150;
		}
		break;

	case 150:
		// Y축 모터 Homing 작업 진행
		nRet = g_comiMgr.HomeCheck_Mot(m_nMotY, 0, MOT_TIMEOUT);
		if (nRet == CTLBD_RET_GOOD)
		{
			m_nStep_Init = 180;
		}
		else if (nRet == CTLBD_RET_ERROR)
		{
			// 050003 0 00 "BARCODE_ROBOT_Y_HOMING_ERR."
			alarm.mstr_code		= "050003";
			alarm.mn_count_mode	= 0;
			alarm.mn_type_mode	= eWARNING;
			st_work.nEqpStatus	= dWARNING;
		}
		break;

		// 그립퍼 또는 Vacuum에 악세사리가 존재할 수 있어 NG 버퍼 영역에서 Homing 작업 진행
	case 180:
		m_dTargetPos = st_motor[m_nMotY].d_pos[Y_RBT_ACC_NG_OUT_];

		nRet = CTL_Lib.OnSingleMove(m_nMotY, m_dTargetPos, (int)st_handler.md_run_speed);
		if (nRet == CTLBD_RET_GOOD)
		{
			m_nStep_Init = 190;
		}
		else if (nRet == CTLBD_RET_ERROR || nRet == CTLBD_RET_RETRY)
		{
			// 051007 0 00 "BARCODE_ROBOT_Y_RBT_ACC_NG_OUT_MOVE_ERR."
			alarm.mstr_code		= "051007";
			alarm.mn_count_mode	= 0;
			alarm.mn_type_mode	= eWARNING;
			st_work.nEqpStatus	= dWARNING;
		}
		break;

		// 규이리 수정 [2015.03.13]
	case 190:
		// 그립퍼 모터는 (그립퍼 모든 또는 Vacuum 모드) 상관없이 Homing 작업해야 함
		// 현재는 문제가 있어 조건에 따라 Homing 작업 진행
		// - 플래그 셋팅에 따라 Homing 작업 여부 결정
		// - 기본적으로는 초기화 진행해야 하지만 현재 모터 1축이 문제가 있어 임시로 처리함
		if (m_nflag_GripSkip == TRUE)
		{
			m_nStep_Init = 230;	// Vacuum 동작
		}
		else
		{
			m_nStep_Init = 200;	// 그립퍼 모터 Homing 작업
		}
		break;

		//==========================================================//
		// 그립퍼 동작
		//==========================================================//
	case 200:
		// 설비 정면 기준 좌앞 그립퍼 모터 Homing 작업 진행
		nRet = g_comiMgr.HomeCheck_Mot(m_nMotGrip1, 1, MOT_TIMEOUT);
		if (nRet == CTLBD_RET_GOOD)
		{
			m_nStep_Init = 210;
		}
		else if (nRet == CTLBD_RET_ERROR)
		{
			// 080003 0 00 "ROBOT_GRIP_1_HOMING_ERR."
			alarm.mstr_code		= "080003";
			alarm.mn_count_mode	= 0;
			alarm.mn_type_mode	= eWARNING;
			st_work.nEqpStatus	= dWARNING;
		}
		break;

	case 210:
		// 설비 정면 기준 우앞 그립퍼 모터 Homing 작업 진행
		nRet = g_comiMgr.HomeCheck_Mot(m_nMotGrip2, 1, MOT_TIMEOUT);
		if (nRet == CTLBD_RET_GOOD)
		{
			//m_nStep_Init = 280;
			// 규이리 수정 [2015.03.13]
			// (Vacuum Off) 동작도 함께 진행해야 함
			m_nStep_Init = 230;
		}
		else if (nRet == CTLBD_RET_ERROR)
		{
			// 090003 0 00 "ROBOT_GRIP_2_HOMING_ERR."
			alarm.mstr_code		= "090003";
			alarm.mn_count_mode	= 0;
			alarm.mn_type_mode	= eWARNING;
			st_work.nEqpStatus	= dWARNING;
		}
		break;
		//==========================================================//

		//==========================================================//
		// Vacuum 동작
		// 규이리 수정 [2015.03.14]
		//==========================================================//
	case 230:
		for(i=0; i<MAX_PICKER_; i++)
		{
			if (i < 2)
			{
				m_nPicker[TYPE_FLAG_][i] = CTL_YES;
			}
			else
			{
				m_nPicker[TYPE_FLAG_][i] = CTL_NO;
			}
		}
		// [0:좌앞, 1:우앞] 2개의 Vacuum 해제
		OnSet_SolVacuum(IO_OFF, m_nPicker[TYPE_FLAG_]);	// 그립퍼 Vacuum [ON:진공설정, OFF:진공해제]
		m_nStep_Init = 235;
		break;

	case 235:
		nRet = OnGet_SolVacuum(IO_OFF, m_nPicker[TYPE_FLAG_], m_nPicker[TYPE_SEN_]);
		// 어찌되었던 동작이 완료될때까지 대기
		if (nRet == CTL_GOOD || nRet == CTL_ERROR)
		{
			m_lTime_GoesBy[0] = GetCurrentTime();
			m_nStep_Init = 240;
		}
		break;

	case 240:
		// 그립퍼의 자재 존재 상태 반환
		// - m_nPicker : [case 230:] 에서 설정됨
		nRet = Func.OnGet_PickerStatus(0, CTL_NO, m_nPicker);
		if (nRet == CTL_ERROR)
		{
			m_lTime_GoesBy[1] = GetCurrentTime();
			m_lTime_GoesBy[2] = m_lTime_GoesBy[1] - m_lTime_GoesBy[0];
			if (m_lTime_GoesBy[2] < 0)
			{
				m_lTime_GoesBy[0] = GetCurrentTime();
				break;
			}
			
			if (m_lTime_GoesBy[2] > 10)
			{
				// OnGet_PickerStatus() 함수 안에서 알람 코드 설정됨
				alarm.mn_count_mode	= 0;
				alarm.mn_type_mode	= eWARNING;
				st_work.nEqpStatus	= dWARNING;
			}
			break;
		}
		m_nStep_Init = 280;
		break;
		//==========================================================//

		// 피커의 쥐쪽열 그립퍼 및 Vacuum을 동작시키기 위하여 Y축 모터 이동
	case 280:
		// 악세사리 박스 투입구 방향이 Home 방향이므로 뒤쪽열 그립퍼의 Vacuum을 제어하기 위해서는 (+)해줘야 함
		m_dTargetPos = st_motor[m_nMotY].d_pos[Y_RBT_ACC_NG_OUT_] + st_accy.d_Y_Gripper_Size;

		nRet = CTL_Lib.OnSingleMove(m_nMotY, m_dTargetPos, (int)st_handler.md_run_speed);
		if (nRet == CTLBD_RET_GOOD)
		{
			m_nStep_Init = 290;
		}
		else if (nRet == CTLBD_RET_ERROR || nRet == CTLBD_RET_RETRY)
		{
			// 051007 0 00 "BARCODE_ROBOT_Y_RBT_ACC_NG_OUT_MOVE_ERR."
			alarm.mstr_code		= "051007";
			alarm.mn_count_mode	= 0;
			alarm.mn_type_mode	= eWARNING;
			st_work.nEqpStatus	= dWARNING;
		}
		break;

		// 규이리 수정 [2015.03.13]
	case 290:
		if (m_nflag_GripSkip == TRUE)
		{
			m_nStep_Init = 330;	// Vacuum 동작
		}
		else
		{
			m_nStep_Init = 300;	// 그립퍼 모터 Homing 작업
		}
		break;

		//==========================================================//
		// 그립퍼 동작
		//==========================================================//
	case 300:
		// 설비 정면 기준 좌뒤 그립퍼 모터 Homing 작업 진행
		nRet = g_comiMgr.HomeCheck_Mot(m_nMotGrip3, 1, MOT_TIMEOUT);
		if (nRet == CTLBD_RET_GOOD)
		{
			m_nStep_Init = 310;
		}
		else if (nRet == CTLBD_RET_ERROR)
		{
			// 100003 0 00 "ROBOT_GRIP_3_HOMING_ERR."
			alarm.mstr_code		= "100003";
			alarm.mn_count_mode	= 0;
			alarm.mn_type_mode	= eWARNING;
			st_work.nEqpStatus	= dWARNING;
		}
		break;

	case 310:
		// 설비 정면 기준 우뒤 그립퍼 모터 Homing 작업 진행
		nRet = g_comiMgr.HomeCheck_Mot(m_nMotGrip4, 1, MOT_TIMEOUT);
		if (nRet == CTLBD_RET_GOOD)
		{
			//m_nStep_Init = 400;
			// 규이리 수정 [2015.03.13]
			// (Vacuum Off) 동작도 함께 진행해야 함
			m_nStep_Init = 330;
		}
		else if (nRet == CTLBD_RET_ERROR)
		{
			// 110003 0 00 "ROBOT_GRIP_4_HOMING_ERR."
			alarm.mstr_code		= "110003";
			alarm.mn_count_mode	= 0;
			alarm.mn_type_mode	= eWARNING;
			st_work.nEqpStatus	= dWARNING;
		}
		break;
		//==========================================================//

		//==========================================================//
		// Vacuum 동작
		// 규이리 수정 [2015.03.14]
		//==========================================================//
	case 330:
		for(i=0; i<MAX_PICKER_; i++)
		{
			if (i < 2)
			{
				m_nPicker[TYPE_FLAG_][i] = CTL_NO;
			}
			else
			{
				m_nPicker[TYPE_FLAG_][i] = CTL_YES;
			}
		}
		// [2:좌뒤, 3:우뒤] 2개의 Vacuum 해제
		OnSet_SolVacuum(IO_OFF, m_nPicker[TYPE_FLAG_]);	// 그립퍼 Vacuum [ON:진공설정, OFF:진공해제]
		m_nStep_Init = 335;
		break;

	case 335:
		nRet = OnGet_SolVacuum(IO_OFF, m_nPicker[TYPE_FLAG_], m_nPicker[TYPE_SEN_]);
		// 어찌되었던 동작이 완료될때까지 대기
		if (nRet == CTL_GOOD || nRet == CTL_ERROR)
		{
			m_lTime_GoesBy[0] = GetCurrentTime();
			m_nStep_Init = 340;
		}
		break;

	case 340:
		// 그립퍼의 자재 존재 상태 반환
		// - m_nPicker : [case 250:] 에서 설정됨
		nRet = Func.OnGet_PickerStatus(0, CTL_NO, m_nPicker);
		if (nRet == CTL_ERROR)
		{
			m_lTime_GoesBy[1] = GetCurrentTime();
			m_lTime_GoesBy[2] = m_lTime_GoesBy[1] - m_lTime_GoesBy[0];
			if (m_lTime_GoesBy[2] < 0)
			{
				m_lTime_GoesBy[0] = GetCurrentTime();
				break;
			}
			
			if (m_lTime_GoesBy[2] > 10)
			{
				// OnGet_PickerStatus() 함수 안에서 알람 코드 설정됨
				alarm.mn_count_mode	= 0;
				alarm.mn_type_mode	= eWARNING;
				st_work.nEqpStatus	= dWARNING;
			}
			break;
		}
		m_nStep_Init = 400;
		break;
		//==========================================================//

	case 400:
		// 바코드 방향이 [가로->세로] 변경되면서 간섭이 발생
		// - Y축 모터의 Homing 위치에서 X축 모터 Homing 작업하면 바코드 유닛이 투입구쪽 기구물과 충돌 발생
		nRet = g_comiMgr.HomeCheck_Mot(m_nMotX, 0, MOT_TIMEOUT);
		if (nRet == CTLBD_RET_GOOD)
		{
			m_nStep_Init = 500;
		}
		else if (nRet == CTLBD_RET_ERROR)
		{
			// 060003 0 00 "BARCODE_ROBOT_X_HOMING_ERR."
			alarm.mstr_code		= "060003";
			alarm.mn_count_mode	= 0;
			alarm.mn_type_mode	= eWARNING;
			st_work.nEqpStatus	= dWARNING;
		}
		break;

	case 500:
		for(i=0; i<2; i++)
		{
			m_nRespMot[i] = CTL_NO;
		}

		// 초기 대기 위치 [NG 버퍼 위치]
		nRetData[0] = COMI.Start_SingleMove(m_nMotX, st_motor[m_nMotX].d_pos[X_RBT_ACC_BCR_],		(int)st_handler.md_run_speed);
		nRetData[1] = COMI.Start_SingleMove(m_nMotY, st_motor[m_nMotY].d_pos[Y_RBT_ACC_NG_BUFFER_],	(int)st_handler.md_run_speed);
		if (nRetData[0] == CTLBD_RET_GOOD)
		{
			m_nRespMot[0] = CTL_YES;
		}
		if (nRetData[1] == CTLBD_RET_GOOD)
		{
			m_nRespMot[1] = CTL_YES;
		}
		
		if (m_nRespMot[0] == CTL_YES &&
			m_nRespMot[1] == CTL_YES)
		{
			for(i=0; i<2; i++)
			{
				m_nRespMot[i] = CTL_NO;
			}
			m_nStep_Init = 520;
		}
		else if (nRetData[0] == CTLBD_RET_RETRY ||
			nRetData[1] == CTLBD_RET_RETRY)
		{
			m_nStep_Init = 500;
		}
		else if (nRetData[0] != CTLBD_RET_PROCEED && nRetData[0] != CTLBD_RET_GOOD)
		{
			m_nStep_Init = 500;
			
			// 061000 0 00 "BARCODE_ROBOT_X_RBT_ACC_BCR_POS_MOVE_ERR."
			alarm.mstr_code		= "061000";
			alarm.mn_count_mode	= 0;
			alarm.mn_type_mode	= eWARNING;
			st_work.nEqpStatus	= dWARNING;
		}
		else if (nRetData[1] != CTLBD_RET_PROCEED && nRetData[1] != CTLBD_RET_GOOD)
		{
			m_nStep_Init = 500;
			
			// 051008 0 00 "BARCODE_ROBOT_Y_RBT_ACC_NG_BUFFER_MOVE_ERR."
			alarm.mstr_code		= "051008";
			alarm.mn_count_mode	= 0;
			alarm.mn_type_mode	= eWARNING;
			st_work.nEqpStatus	= dWARNING;
		}
		break;

	case 520:
		nRetData[0] = COMI.Check_SingleMove(m_nMotX, st_motor[m_nMotX].d_pos[X_RBT_ACC_BCR_]);
		nRetData[1] = COMI.Check_SingleMove(m_nMotY, st_motor[m_nMotY].d_pos[Y_RBT_ACC_NG_BUFFER_]);
		if (nRetData[0] == CTLBD_RET_GOOD)
		{
			m_nRespMot[0] = CTL_YES;
		}
		if (nRetData[1] == CTLBD_RET_GOOD)
		{
			m_nRespMot[1] = CTL_YES;
		}
		
		if (m_nRespMot[0] == CTL_YES &&
			m_nRespMot[1] == CTL_YES)
		{
			for(i=0; i<2; i++)
			{
				m_nRespMot[i] = CTL_NO;
			}
			m_nStep_Init = 1000;
		}
		else if (nRetData[0] == CTLBD_RET_RETRY ||
			nRetData[1] == CTLBD_RET_RETRY)
		{
			m_nStep_Init = 500;
		}
		else if (nRetData[0] != CTLBD_RET_PROCEED && nRetData[0] != CTLBD_RET_GOOD)
		{
			m_nStep_Init = 500;
			
			// 061000 0 00 "BARCODE_ROBOT_X_RBT_ACC_BCR_POS_MOVE_ERR."
			alarm.mstr_code		= "061000";
			alarm.mn_count_mode	= 0;
			alarm.mn_type_mode	= eWARNING;
			st_work.nEqpStatus	= dWARNING;
		}
		else if (nRetData[1] != CTLBD_RET_PROCEED && nRetData[1] != CTLBD_RET_GOOD)
		{
			m_nStep_Init = 500;
			
			// 051008 0 00 "BARCODE_ROBOT_Y_RBT_ACC_NG_BUFFER_MOVE_ERR."
			alarm.mstr_code		= "051008";
			alarm.mn_count_mode	= 0;
			alarm.mn_type_mode	= eWARNING;
			st_work.nEqpStatus	= dWARNING;
		}
		break;

	case 1000:
		// 규이리 수정 [2015.03.10]
		// 초기화 작업시에는 실재 자재의 존재 상태를 검사해야 함
		// - WithOut 모드에서도 자재가 존재하는 경우에는 제거해야 함
		nRetData[0] = OnCheck_NGBufferFrontAccy(IO_ON,	CHK_NOT_EXIST_, SIDE_LEFT_);
		nRetData[1] = OnCheck_NGBufferFrontAccy(IO_ON,	CHK_NOT_EXIST_, SIDE_RIGHT_);
		nRetData[2] = OnCheck_NGBufferRearAccy(IO_ON,	CHK_NOT_EXIST_, SIDE_LEFT_);
		nRetData[3] = OnCheck_NGBufferRearAccy(IO_ON,	CHK_NOT_EXIST_, SIDE_RIGHT_);

		if (nRetData[0] == IO_OFF && nRetData[1] == IO_OFF && nRetData[2] == IO_OFF && nRetData[3] == IO_OFF)
		{
			memset(st_map.nNGBuffer, 0, sizeof(st_map.nNGBuffer));
			m_nStep_Init = 1200;
		}
		else
		{
			m_nStep_Init = 1100;
		}
		break;

	case 1100:
		// NG 버퍼의 악세사리 제거
		nRet = OnProc_NGBufferClear();	// NG 버퍼의 악세사리 배출
		if (nRet == CTLBD_RET_GOOD)
		{
			// 다시 한번 NG 버퍼에 악세사리 존재하는지 재검사
			m_nStep_Init = 1000;
		}
		break;

	case 1200:
		// 규이리 수정 [2015.03.10]
		nRetData[0] = OnCheck_FrontAccySupply(IO_ON,	CHK_NOT_EXIST_, SIDE_LEFT_);
		nRetData[1] = OnCheck_FrontAccySupply(IO_ON,	CHK_NOT_EXIST_, SIDE_RIGHT_);
		nRetData[2] = OnCheck_RearAccySupply(IO_ON,		CHK_NOT_EXIST_, SIDE_LEFT_);
		nRetData[3] = OnCheck_RearAccySupply(IO_ON,		CHK_NOT_EXIST_, SIDE_RIGHT_);

		if (nRetData[0] == IO_OFF && nRetData[1] == IO_OFF &&
			nRetData[2] == IO_OFF && nRetData[3] == IO_OFF)
		{
			// Conv 버퍼의 자재 제거 동작 후에도 [case 1200:] 호출되므로 NG 버퍼로 Y축 모터 이동시킴
			m_nStep_Init = 10000;
		}
		else
		{
			m_nStep_Init = 1300;
		}
		break;

	case 1300:
		// Buffer Conv의 Init 상태가 완료 또는 준비가 될때까지 대기
		if (st_handler.mn_init_state[INIT_BUFFER_CONV] == CTL_YES ||
			st_handler.mn_init_state[INIT_BUFFER_CONV] == CTL_READY)
		{
			m_nStep_Init = 1400;
		}
		break;

	case 1400:
		// Conv 버퍼의 악세사리 제거
		nRet = OnProc_BufferConvClear();
		if (nRet == CTLBD_RET_GOOD)
		{
			m_nStep_Init = 1200;
		}
		break;

	case 10000:
		nRet = CTL_Lib.OnSingleMove(m_nMotY, st_motor[m_nMotY].d_pos[Y_RBT_ACC_NG_BUFFER_], (int)st_handler.md_run_speed);
		if (nRet == CTLBD_RET_GOOD)
		{
			m_nStep_Init = 11000;
		}
		else if (nRetData[1] == CTLBD_RET_ERROR || nRetData[1] == CTLBD_RET_RETRY)
		{
			// 051008 0 00 "BARCODE_ROBOT_Y_RBT_ACC_NG_BUFFER_MOVE_ERR."
			alarm.mstr_code		= "051008";
			alarm.mn_count_mode	= 0;
			alarm.mn_type_mode	= eWARNING;
			st_work.nEqpStatus	= dWARNING;
		}
		break;

	case 11000:
		stSync.nResp_XYZRbt2Lifter_Work = SYNC_RESP_RESET_;
		stSync.nReq_XYZRbt2BufferAlaignConv_Work = SYNC_REQ_RESET_;

		// 초기화 화면에서 [초기화] 완료 표시 가능
		st_handler.mn_init_state[INIT_XYZ_ROBOT] = CTL_YES;
		m_nStep_Init = 0;
		break;
	}
}

void CSeq_XYZRobot::OnRun_Move() 
{
	// 전체 사이트 복구 동작 완료 여부 확인
	// - 모든 부분의 복구 동작이 완료된 후에만 시컨스 동작하도록 함
	// : 복구 동작 중에 시컨스 구동하면 복구하는 영역과 충돌이 발생할 수 있음
	if (Func.OnIsAllRcvyComplete() != CTL_YES)
	{
		return;
	}
	Func.OnTrace_ThreadStep(9, m_nStep_Run);	// 쓰레드 스텝 정보 TRACE

	int i = 0;
	int nRet = VAR_INIT_;
	int nRetData[4] = {0,};
	int nDeviceType = 0;
	int nSum = 0;
	int nAccyCodeMathChk = 0;
	CString tmp;
	CString sSndMeg;

	switch(m_nStep_Run)
	{
	case 0:
		// Lot Start 상태가 될때까지 대기
		if (st_map.nLotStart != CTL_YES)
		{
			break;
		}
		// Box Lift가 Lot End 상태 또는 박스 배출 상태일 경우
		if (stSync.nLotEnd_BoxLifter == TRUE)
		{
			st_map.nSupplyTypeMath = 0;
			stSync.nLotEnd_XYZRobot = TRUE;
			break;
		}
		else
		{
			stSync.nLotEnd_XYZRobot = FALSE;
		}
		
		// kilee [2015.03.07]
		// 리프터에서 악세사리 준비가 되었는지 확인
		// - 준비됨 : 리프터가 준비한 악세사리 집으러 이동
		// - 민준비 : NG 버퍼 영역으로 일단 이동 [이동 시간을 줄이기 위함]
		if (stSync.nReq_Lifter2XYZRbt_Work == SYNC_REQ_ACC_LIFT_COMPLETE_)
		{
			// SLAVE_MODE(TOP)의 경우 Accy Math 코드를 하지 않음.
			// BCR가 없으므로 바로 짚는 동작을 진행.
			if (st_basic.nMode_SupplyMode == SLAVE_MODE)
			{
				// 바코드를 읽지 않기 때문에 자재의 정보를 GOOD으로 만듬.
				memset(st_map.nBCR_State, BCR_READ_GOOD_, sizeof(st_map.nBCR_State));
				
				for(i=0; i<4; i++)
				{
					st_work.sRbtBCR_Data[i] = "";
				}
				
				if (st_handler.cwnd_main != NULL)
				{
					// XYZ 로봇의 상태 표시 요청
					st_handler.cwnd_main->PostMessage(WM_UPDATE_MAIN, PLACE_XYZ_RBT_);
				}
				if (st_basic.nMode_GripUsing == GRIP_USING)
				{
					m_nStep_Run = 2000;	// Grip 사용 모드
				}
				else if(st_basic.nMode_VacUsing == VAC_USING)
				{
					m_nStep_Run = 2500;	// Vacuum 사용 모드
				}
			}
			else
			{
				m_nStep_Run = 300;
			}
		}
		else
		{
			m_nStep_Run = 100;
		}
		break;
		
		//==========================================================//
		// kilee [2015.03.07]
		// NG 버퍼 영역으로 일단 이동시킴
		//==========================================================//
	case 100:
		nRet = CTL_Lib.OnSingleMove(m_nMotZ, st_motor[m_nMotZ].d_pos[Z_RBT_SAFETY_], (int)st_handler.md_run_speed);
		if (nRet == CTLBD_RET_GOOD)
		{
			m_nStep_Run = 200;
		}
		else if (nRet == CTLBD_RET_ERROR || nRet == CTLBD_RET_RETRY)
		{
			// 071005 0 0 "BARCODE_ROBOT_Z_RBT_SAFETY_MOVE_ERR"
			alarm.mstr_code		= "071005";
			alarm.mn_count_mode	= 0;
			alarm.mn_type_mode	= eWARNING;
			st_work.nEqpStatus	= dWARNING;
		}
		break;
		
	case 200:
		nRet = CTL_Lib.OnSingleMove(m_nMotY, st_motor[m_nMotY].d_pos[Y_RBT_ACC_NG_BUFFER_], (int)st_handler.md_run_speed);
		if (nRet == CTLBD_RET_GOOD)
		{
			// SLAVE_MODE(TOP)의 경우 Accy Math 코드를 하지 않음.
			// BCR가 없으므로 바로 짚는 동작을 진행.
			if (st_basic.nMode_SupplyMode == SLAVE_MODE)
			{
				// 바코드를 읽지 않기 때문에 자재의 정보를 GOOD으로 만듬.
				memset(st_map.nBCR_State, BCR_READ_GOOD_, sizeof(st_map.nBCR_State));

				for(i=0; i<4; i++)
				{
					st_work.sRbtBCR_Data[i] = "";
				}

				if (st_handler.cwnd_main != NULL)
				{
					// XYZ 로봇의 상태 표시 요청
					st_handler.cwnd_main->PostMessage(WM_UPDATE_MAIN, PLACE_XYZ_RBT_);
				}
				if (st_basic.nMode_GripUsing == GRIP_USING)
				{
					m_nStep_Run = 2000;	// Grip 사용 모드
				}
				else if(st_basic.nMode_VacUsing == VAC_USING)
				{
					m_nStep_Run = 2500;	// Vacuum 사용 모드
				}
			}
			else
			{
				m_nStep_Run = 300;
			}
		}
		else if (nRetData[1] == CTLBD_RET_ERROR || nRetData[1] == CTLBD_RET_RETRY)
		{
			// 051008 0 00 "BARCODE_ROBOT_Y_RBT_ACC_NG_BUFFER_MOVE_ERR."
			alarm.mstr_code		= "051008";
			alarm.mn_count_mode	= 0;
			alarm.mn_type_mode	= eWARNING;
			st_work.nEqpStatus	= dWARNING;
		}
		break;
		//==========================================================//

		// yangkyu [2015.03.19]
		// 바코드를 읽기 전에 현재 Accy Math Code값이 Null인지 확인 한다.
		// st_work.m_sAccyMathCode 값은 Main에서 보내준다.
	case 300:
		// st_work.m_sAccyMathCode 값이 없으면 대기 
		st_work.m_sAccyMathCode = "LA69-01773A";
		//st_work.m_sAccyMathCode = "LA69-01773B";
		if ((st_work.m_sAccyMathCode) != "")
		{
			// 처음 시작인 경우 m_sCurrntAccyMathCode 값이 NULL 이기 때문에 st_work.m_sAccyMathCode 값을 저장 한다. 
			if (m_sCurrntAccyMathCode == "")
			{
				m_sCurrntAccyMathCode = st_work.m_sAccyMathCode;
				// 규이리 수정 [2015.03.20]
				for(i=0; i<4; i++)
				{
					st_work.sRbtBCR_Data[i] = "";
				}
				m_nStep_Run = 500;
			}
			else	// 이전에 작업 한 Accy Math Code와 같은지 확인
			{
				// 규이리 수정 [2015.03.20]
// 				for(i=0; i<4; i++)
// 				{
// 					st_work.sRbtBCR_Data[i] = "";
// 				}
// 				m_nStep_Run = 500;
				// yangkyu [2015.04.10]
				if (m_sCurrntAccyMathCode == st_work.m_sAccyMathCode)
				{
					for(i=0; i<4; i++)
					{
						st_work.sRbtBCR_Data[i] = "";
					}
					m_nStep_Run = 500;
				}
				else
				{
					m_sCurrntAccyMathCode = "";	
					m_nStep_Run = 0;
					st_work.nForceDischarge = FORCEDISCHARGE_ON;
					Func.OnSet_EqpStatusStop();
					break;
				}
			}
		}
		else
		{
			// 자재가 없는 경우이기 떄문에 st_work.m_sAccyMathCode에 Test를 넣어 진행
			if (st_basic.n_mode_device == WITHOUT_DVC_)
			{
				st_work.m_sAccyMathCode = "Test";
			}
		}
		break;

	case 500:
		// Box Lift가 Lot 상태 확인
		if (stSync.nLotEnd_BoxLifter == TRUE)
		{
			m_nStep_Run = 0;
			break;
		}
		
		// Accy 바코드 읽는 작업 수행
		nRet = OnProc_ReadMove();

		if (nRet == CTL_GOOD)
		{
			if (st_handler.cwnd_main != NULL)
			{
				// XYZ 로봇의 상태 표시 요청
				st_handler.cwnd_main->PostMessage(WM_UPDATE_MAIN, PLACE_XYZ_RBT_);
			}
			if (st_basic.nMode_GripUsing == GRIP_USING)
			{
				m_nStep_Run = 2000;	// Grip 사용 모드
			}
			else if(st_basic.nMode_VacUsing == VAC_USING)
			{
				m_nStep_Run = 2500;	// Vacuum 사용 모드
			}
		}
		break;

	//////////////////////////////////////////////////////////////////////////
	// Grip 작업
	//////////////////////////////////////////////////////////////////////////
	case 2000:
		nRet = OnProc_AccyGripPick();

		if (nRet == CTL_GOOD)
		{
			m_nStep_Run = 3000;
		}
		else if (nRet == CTL_ERROR)
		{
			m_nStep_Run = 6000;
		}
		break;
	//////////////////////////////////////////////////////////////////////////

	//////////////////////////////////////////////////////////////////////////
	// Vacuum 작업
	//////////////////////////////////////////////////////////////////////////
	case 2500:
		nRet = OnProc_AccyVacPick();
		
		if (nRet == CTL_GOOD)
		{
			m_nStep_Run = 3000;
		}
		else if (nRet == CTL_ERROR)
		{
			m_nStep_Run = 6000;
		}
		break;
	//////////////////////////////////////////////////////////////////////////

	//////////////////////////////////////////////////////////////////////////
	// Accy Place 작업
	case 3000:
		nRet = OnProc_AccyPlace();
		
		if (nRet == CTL_GOOD)
		{
			m_nStep_Run = 9000;
		}
		break;

	//////////////////////////////////////////////////////////////////////////
	// yangkyu [2105.03.05]
	// Lift Z축을 2mm씩 10회 시도 후 Gripper의 센서가 감지가 되지 않앗을 경우
	// Lift Z축을 내리면서 다음 동작을 위해 수행 하는 부분 
	case 6000:
		nRet = OnProc_WorkSiteChange();
		if (nRet == CTLBD_RET_GOOD)
		{
			m_nStep_Run = 9000;
		}
		break;

	//////////////////////////////////////////////////////////////////////////

	case 9000:
		stSync.nResp_XYZRbt2Lifter_Work = SYNC_RESP_RESET_;
		// BCR 구조체 값 초기화
		memset(st_map.nBCR_State, -1, sizeof(st_map.nBCR_State));

		if (st_handler.cwnd_main != NULL) 
		{
			// 바코드 상태 표시 초기화 요청
			st_handler.cwnd_main->PostMessage(WM_UPDATE_MAIN, READ_BCR_DATA);
		}

		m_nStep_Run = 0;
		m_nGripRetryCnt = 0;
		break;

	}
}

//////////////////////////////////////////////////////////////////////////
// Accy 배출 작업
// int nzNGAccyInfo[4] : Gripper 정보
// Gripper가 잡고 있는 Accy 배출 (0 : 1, 2번 Gripper, 1 : 3, 4번 Gripper)
//////////////////////////////////////////////////////////////////////////
int CSeq_XYZRobot::OnProc_AccyOut(int nzNGAccyInfo[4], int nzSite)
{
	int nFuncRet = CTL_PROCEED;
	int nRet = VAR_INIT_;
	int nSum;
	int nRetData[4] = {0,};

	switch(m_nStep_NGAccyOut)
	{
	case 0:
		if (nzSite == SIDE_FRONT_)
		{
			if(nzNGAccyInfo[0] == 1 && nzNGAccyInfo[1] == 1)
			{
				nFuncRet = CTL_GOOD;
				break;
			}
		}
		else if (nzSite == SIDE_REAR_)
		{
			if(nzNGAccyInfo[2] == 1 && nzNGAccyInfo[3] == 1)
			{
				nFuncRet = CTL_GOOD;
				break;
			}
		}
		//m_nStep_NGAccyOut = 100;
		// KILEE [2015.03.23]
		m_nStep_NGAccyOut = 50;
		break;

		// KILEE [2015.03.23]
	case 50:
		nRet = CTL_Lib.OnSingleMove(m_nMotZ, st_motor[m_nMotZ].d_pos[Z_RBT_SAFETY_], (int)st_handler.md_run_speed);
		if (nRet == CTLBD_RET_GOOD)
		{
			m_nStep_NGAccyOut = 100;
		}
		else if (nRet == CTLBD_RET_ERROR || nRet == CTLBD_RET_RETRY)
		{
			// 071005 0 0 "BARCODE_ROBOT_Z_RBT_SAFETY_MOVE_ERR"
			alarm.mstr_code		= "071005";
			alarm.mn_count_mode	= 0;
			alarm.mn_type_mode	= eWARNING;
			st_work.nEqpStatus	= dWARNING;
		}
		break;

	case 100:
		// yangkyu [2015.02.27]
		// nzSite에 따라 d_Y_Gripper_Size 더한 위치로 이동함. (SIDE_FRONT = 0, SIDE_REAR = 1)
		m_dTargetPos = st_motor[m_nMotY].d_pos[Y_RBT_ACC_NG_OUT_] + (st_accy.d_Y_Gripper_Size * nzSite);
		nRet = CTL_Lib.OnSingleMove(m_nMotY, m_dTargetPos, (int)st_handler.md_run_speed);
		if (nRet == CTLBD_RET_GOOD)
		{
			m_nStep_NGAccyOut = 200;
			st_map.nNGOut = 1;
			if (st_handler.cwnd_main != NULL)
			{
				// NG Out 상태 표시 요청
				st_handler.cwnd_main->PostMessage(WM_UPDATE_MAIN, PLACE_NG_OUT_);
			}
		}
		else if (nRet == CTLBD_RET_ERROR || nRet == CTLBD_RET_RETRY)
		{
			// 051007 0 00 "BARCODE_ROBOT_Y_RBT_ACC_NG_OUT_MOVE_ERR."
			alarm.mstr_code		= "051007";
			alarm.mn_count_mode	= 0;
			alarm.mn_type_mode	= eWARNING;
			st_work.nEqpStatus	= dWARNING;
		}
		break;

	case 200:
		// 초기에는 그립퍼+Vacuum 모드도 가능하다고 했는데 실재로는 불가능함
		// - 그립퍼면 그립퍼만 사용, Vacuum이면 Vacuum만 사용해야 함
		if (st_basic.nMode_GripUsing == GRIP_USING)
		{
			m_nStep_NGAccyOut = 300;	// 그립퍼 모드 사용
		}
		else if (st_basic.nMode_VacUsing == VAC_USING)
		{
			// 이전 동작에서 이미 (Vacuum Off) 진행했을 것이므로 다시 진행하지 않도록 함
			// - 해도 무방하지만 대기 시간만큼의 시간이 더 소요됨
			m_nStep_NGAccyOut = 500;
		}
		break;

		//==========================================================//
		// Grip 사용 모드
		//==========================================================//
	case 300:
		if (nzSite == SIDE_FRONT_)
		{
			nSum = !nzNGAccyInfo[0] * 1;
		}
		else if (nzSite == SIDE_REAR_)
		{
			nSum = !nzNGAccyInfo[2] * 4;
		}
		
		// [0] or [2] Grip Off
		nRet = OnProc_Grip(nSum, IO_OFF);
		if (nRet == CTLBD_RET_GOOD)
		{
			st_map.nNGOutCNT += nzSite == SIDE_FRONT_ ? !nzNGAccyInfo[0] : !nzNGAccyInfo[2];
			m_nStep_NGAccyOut = 310;
		}
		break;

	case 310:
		if (nzSite == SIDE_FRONT_)
		{
			nSum = !nzNGAccyInfo[1] * 2;
		}
		else if (nzSite == SIDE_REAR_)
		{
			nSum = !nzNGAccyInfo[3] * 8;
		}
		
		// [1] or [3] Grip Off
		nRet = OnProc_Grip(nSum, IO_OFF);
		if (nRet == CTLBD_RET_GOOD)
		{
			st_map.nNGOutCNT += nzSite == SIDE_FRONT_ ? !nzNGAccyInfo[1] : !nzNGAccyInfo[3];
			m_nStep_NGAccyOut = 1000;
		}
		break;
		//==========================================================//

		//==========================================================//
		// Vacuum 사용 모드
		//==========================================================//

	case 500:
		m_nPicker[TYPE_FLAG_][0] = CTL_NO;	// [리셋] 플래그 정보
		m_nPicker[TYPE_FLAG_][1] = CTL_NO;	// [리셋] 플래그 정보
		m_nPicker[TYPE_FLAG_][2] = CTL_NO;	// [리셋] 플래그 정보
		m_nPicker[TYPE_FLAG_][3] = CTL_NO;	// [리셋] 플래그 정보
		m_nStep_NGAccyOut = 510;
		break;

	case 510:
		if (nzSite == SIDE_FRONT_)
		{
			if (nzNGAccyInfo[0] == BCR_READ_BAD_)
			{
				m_nPicker[TYPE_FLAG_][0] = CTL_YES;	// 동작할 Vacuum으로 설정
			}
		}
		else if (nzSite == SIDE_REAR_)
		{
			if (nzNGAccyInfo[2] == BCR_READ_BAD_)
			{
				m_nPicker[TYPE_FLAG_][2] = CTL_YES;	// 동작할 Vacuum으로 설정
			}
		}
		m_nStep_NGAccyOut = 600;
		break;

	case 600:
		OnSet_SolVacuum(IO_OFF, m_nPicker[TYPE_FLAG_]);	// 그립퍼 Vacuum [ON:진공설정, OFF:진공해제]
		m_nStep_NGAccyOut = 610;
		break;

	case 610:
		nRet = OnGet_SolVacuum(IO_OFF, m_nPicker[TYPE_FLAG_], m_nPicker[TYPE_SEN_]);
		// 어찌되었던 동작이 완료될때까지 대기
		// - 피커를 들고 알람을 출력시키기 위함
		if (nRet == CTL_GOOD )
		{
			if (nzSite == SIDE_FRONT_)
			{
				// 악세사리 버리는 동작 진행한 그리퍼에 한해서 악세사리가 Vacuum 센서에 감지된 경우
				if (m_nPicker[TYPE_FLAG_][0] == CTL_YES && m_nPicker[TYPE_SEN_][0] == CTL_NO)
				{
					// 그립퍼의 구조체 정보 갱신 [자재 지었음]
					st_map.nXYZRbtPickerInfo[0]	= CTL_NO;
					m_nPicker[TYPE_FLAG_][0]	= CTL_NO;
				}
			}
			else if (nzSite == SIDE_REAR_)
			{
				// 악세사리 버리는 동작 진행한 그리퍼에 한해서 악세사리가 Vacuum 센서에 감지된 경우
				if (m_nPicker[TYPE_FLAG_][2] == CTL_YES && m_nPicker[TYPE_SEN_][2] == CTL_NO)
				{
					// 그립퍼의 구조체 정보 갱신 [자재 지었음]
					st_map.nXYZRbtPickerInfo[2]	= CTL_NO;
					m_nPicker[TYPE_FLAG_][2]	= CTL_NO;
				}
			}
			st_map.nNGOutCNT += nzSite == SIDE_FRONT_ ? !nzNGAccyInfo[0] : !nzNGAccyInfo[2];
			//m_nStep_NGAccyOut = 630;
			// kilee [2015.03.17]
			m_nStep_NGAccyOut = 700;
		}
		else if (nRet == CTL_ERROR)
		{
			m_nStep_NGAccyOut = 600;
		}
		break;

	case 700:
		m_nPicker[TYPE_FLAG_][0] = CTL_NO;	// [리셋] 플래그 정보
		m_nPicker[TYPE_FLAG_][1] = CTL_NO;	// [리셋] 플래그 정보
		m_nPicker[TYPE_FLAG_][2] = CTL_NO;	// [리셋] 플래그 정보
		m_nPicker[TYPE_FLAG_][3] = CTL_NO;	// [리셋] 플래그 정보
		m_nStep_NGAccyOut = 710;
		break;
		
	case 710:
		if (nzSite == SIDE_FRONT_)
		{
			if (nzNGAccyInfo[1] == BCR_READ_BAD_)
			{
				m_nPicker[TYPE_FLAG_][1] = CTL_YES;	// 동작할 Vacuum으로 설정
			}
		}
		else if (nzSite == SIDE_REAR_)
		{
			if (nzNGAccyInfo[3] == BCR_READ_BAD_)
			{
				m_nPicker[TYPE_FLAG_][3] = CTL_YES;	// 동작할 Vacuum으로 설정
			}
		}
		m_nStep_NGAccyOut = 800;
		break;
		
	case 800:
		OnSet_SolVacuum(IO_OFF, m_nPicker[TYPE_FLAG_]);	// 그립퍼 Vacuum [ON:진공설정, OFF:진공해제]
		m_nStep_NGAccyOut = 810;
		break;
		
	case 810:
		nRet = OnGet_SolVacuum(IO_OFF, m_nPicker[TYPE_FLAG_], m_nPicker[TYPE_SEN_]);
		// 어찌되었던 동작이 완료될때까지 대기
		// - 피커를 들고 알람을 출력시키기 위함
		if (nRet == CTL_GOOD)
		{
			if (nzSite == SIDE_FRONT_)
			{
				// 악세사리 버리는 동작 진행한 그리퍼에 한해서 악세사리가 Vacuum 센서에 감지된 경우
				if (m_nPicker[TYPE_FLAG_][1] == CTL_YES && m_nPicker[TYPE_SEN_][1] == CTL_NO)
				{
					// 그립퍼의 구조체 정보 갱신 [자재 지었음]
					st_map.nXYZRbtPickerInfo[1]	= CTL_NO;
					m_nPicker[TYPE_FLAG_][1]	= CTL_NO;
				}
			}
			else if (nzSite == SIDE_REAR_)
			{
				// 악세사리 버리는 동작 진행한 그리퍼에 한해서 악세사리가 Vacuum 센서에 감지된 경우
				if (m_nPicker[TYPE_FLAG_][3] == CTL_YES && m_nPicker[TYPE_SEN_][3] == CTL_NO)
				{
					// 그립퍼의 구조체 정보 갱신 [자재 지었음]
					st_map.nXYZRbtPickerInfo[3]	= CTL_NO;
					m_nPicker[TYPE_FLAG_][3]	= CTL_NO;
				}
			}
			st_map.nNGOutCNT += nzSite == SIDE_FRONT_ ? !nzNGAccyInfo[1] : !nzNGAccyInfo[3];
			m_nStep_NGAccyOut = 1000;
		}
		else if (nRet == CTL_ERROR)
		{
			m_nStep_NGAccyOut = 800;
		}
		break;
		//==========================================================//

	case 1000:
		nRet = CTL_Lib.OnSingleMove(m_nMotZ, st_motor[m_nMotZ].d_pos[Z_RBT_SAFETY_], (int)st_handler.md_run_speed);
		if (nRet == CTLBD_RET_GOOD)
		{
			m_nStep_NGAccyOut = 5000;
		}
		else if (nRet == CTLBD_RET_ERROR || nRet == CTLBD_RET_RETRY)
		{
			// 071005 0 07 "BARCODE_ROBOT_Z_RBT_SAFETY_MOVE_ERR."
			alarm.mstr_code		= "071005";
			alarm.mn_count_mode	= 0;
			alarm.mn_type_mode	= eWARNING;
			st_work.nEqpStatus	= dWARNING;
		}
		break;

	case 5000:
		st_map.nNGOut = 0;
		if (st_handler.cwnd_main != NULL)
		{
			// NG Out 배출 상태 표시 요청
			st_handler.cwnd_main->PostMessage(WM_UPDATE_MAIN, PLACE_NG_OUT_);
		}
		nFuncRet = CTL_GOOD;
		m_nStep_NGAccyOut = 0;
		break;
	}
	return nFuncRet;
}

//==================================================================//
// NG 버퍼의 악세사리 배출
// - 작업 종료 후 Y축 모터는 NG 버퍼 위치에 존재함
//==================================================================//
int CSeq_XYZRobot::OnProc_NGBufferClear() 
{
	Func.OnTrace_ThreadStep(10, m_nStep_NG_Buff);	// 쓰레드 스텝 정보 TRACE
	int nFuncRet = CTL_PROCEED;

	int nRet = VAR_INIT_;
	int i, iCheckCount = 0;
	int nRetData[4] = {0,};

	switch(m_nStep_NG_Buff)
	{
	case 0:
		// Z축 모터를 안전 위치로 이동시킴
		nRet = CTL_Lib.OnSingleMove(m_nMotZ, st_motor[m_nMotZ].d_pos[Z_RBT_SAFETY_], (int)st_handler.md_run_speed);
		if (nRet == CTLBD_RET_GOOD)
		{
			m_nStep_NG_Buff = 10;
		}
		else if (nRet == CTLBD_RET_ERROR || nRet == CTLBD_RET_RETRY)
		{
			// 071005 0 07 "BARCODE_ROBOT_Z_RBT_SAFETY_MOVE_ERR."
			alarm.mstr_code		= "071005";
			alarm.mn_count_mode	= 0;
			alarm.mn_type_mode	= eWARNING;
			st_work.nEqpStatus	= dWARNING;
		}
		break;

	case 10:
		// Y축 모터를 NG 버퍼 영역으로 이동
		nRet = CTL_Lib.OnSingleMove(m_nMotY, st_motor[m_nMotY].d_pos[Y_RBT_ACC_NG_BUFFER_], (int)st_handler.md_run_speed);
		if (nRet == CTLBD_RET_GOOD)
		{
			// 초기에는 그립퍼+Vacuum 모드도 가능하다고 했는데 실재로는 불가능함
			// - 그립퍼면 그립퍼만 사용, Vacuum이면 Vacuum만 사용해야 함
			if (st_basic.nMode_GripUsing == GRIP_USING)
			{
				m_nStep_NG_Buff = 50;	// 그립퍼 모드 사용
			}
			else if (st_basic.nMode_VacUsing == VAC_USING)
			{
				//m_nStep_NG_Buff = 60;
				// 규이리 수정 [2015.03.14]
				// 이전 동작에서 이미 (Vacuum Off) 진행했을 것이므로 다시 진행하지 않도록 함
				// - 해도 무방하지만 대기 시간만큼의 시간이 더 소요됨
				m_nStep_NG_Buff = 80;
			}
		}
		else if (nRet == CTLBD_RET_ERROR || nRet == CTLBD_RET_RETRY)
		{
			// 051008 0 00 "BARCODE_ROBOT_Y_RBT_ACC_NG_BUFFER_MOVE_ERR."
			alarm.mstr_code		= "051008";
			alarm.mn_count_mode	= 0;
			alarm.mn_type_mode	= eWARNING;
			st_work.nEqpStatus	= dWARNING;
		}
		break;

		// 그립퍼 동작 부분
	case 50:
		// [0],[1],[2],[3] Grip Off
		nRet = OnProc_Grip(15, IO_OFF);
		if (nRet == CTLBD_RET_GOOD)
		{
			m_nGirpSum = 0;
			m_nStep_NG_Buff = 80;
		}
		break;

	case 80:
		// 규이리 수정 [2015.03.14]
		// 초기화 작업시에는 실재 자재의 존재 상태를 검사해야 함
		// - WithOut 모드에서도 자재가 존재하는 경우에는 제거해야 함
		nRetData[0] = OnCheck_NGBufferFrontAccy(IO_ON,	CHK_NOT_EXIST_,	SIDE_LEFT_);
		nRetData[1] = OnCheck_NGBufferFrontAccy(IO_ON,	CHK_NOT_EXIST_,	SIDE_RIGHT_);
		nRetData[2] = OnCheck_NGBufferRearAccy(IO_ON,	CHK_NOT_EXIST_,	SIDE_LEFT_);
		nRetData[3] = OnCheck_NGBufferRearAccy(IO_ON,	CHK_NOT_EXIST_, SIDE_RIGHT_);

		if (st_basic.n_mode_device == WITHOUT_DVC_)
		{
			for(i=0; i<MAX_PICKER_; i++)
			{
				nRetData[i] = st_map.nNGBuffer[i];
			}
		}

		// kilee [2015.03.17]
		for(i=0; i<MAX_PICKER_; i++)
		{
			m_nSensor[i] = nRetData[i];
		}

		m_nGirpSum = (nRetData[0]*1) + (nRetData[1]*2) + (nRetData[2]*4) + (nRetData[3]*8);
		
		// 그립퍼 사용 모드인 경우
		if (st_basic.nMode_GripUsing == GRIP_USING)
		{
			m_nStep_NG_Buff = 200;
		}
		else if (st_basic.nMode_VacUsing == VAC_USING)
		{
			// 시간이 지난 후에 Vacuum 형성될 수 있으므로 다시 검사
			m_lTime_GoesBy[0] = GetCurrentTime();
			m_nStep_NG_Buff = 300;
		}
		break;

		//==========================================================//
		// 그립퍼 사용 모드
		//==========================================================//
	case 200:
		nRet = CTL_Lib.OnSingleMove(m_nMotZ, st_motor[m_nMotZ].d_pos[Z_RBT_ACC_NG_BUFFER_PICK_], (int)st_handler.md_run_speed);
		if (nRet == CTLBD_RET_GOOD)
		{
			m_nStep_NG_Buff = 250;
		}
		else if (nRet == CTLBD_RET_ERROR || nRet == CTLBD_RET_RETRY)
		{
			// 071002 0 00 "BARCODE_ROBOT_Z_RBT_ACC_NG_BUFFER_PICK_MOVE_ERR."
			alarm.mstr_code		= "071002";
			alarm.mn_count_mode	= 0;
			alarm.mn_type_mode	= eWARNING;
			st_work.nEqpStatus	= dWARNING;
		}
		break;

	case 250:
		// 악세사리 존재하는 그립퍼 동작시킴
		nRet = OnProc_Grip(m_nGirpSum, IO_ON);
		if (nRet == CTLBD_RET_GOOD)
		{
			m_nStep_NG_Buff = 260;
		}
		break;

	case 260:
		nRet = CTL_Lib.OnSingleMove(m_nMotZ, st_motor[m_nMotZ].d_pos[Z_RBT_SAFETY_], (int)st_handler.md_run_speed);
		if (nRet == CTLBD_RET_GOOD)
		{
			m_nStep_NG_Buff = 500;
		}
		else if (nRet == CTLBD_RET_ERROR || nRet == CTLBD_RET_RETRY)
		{
			// 071005 0 07 "BARCODE_ROBOT_Z_RBT_SAFETY_MOVE_ERR."
			alarm.mstr_code		= "071005";
			alarm.mn_count_mode	= 0;
			alarm.mn_type_mode	= eWARNING;
			st_work.nEqpStatus	= dWARNING;
		}
		break;
		//==========================================================//

		//==========================================================//
		// Vacuum 사용 모드
		//==========================================================//
	case 300:
		m_nRepickCount = 0;  // [리셋] 자재 집기 시도 횟수

		// 전체 피커 갯수 가운데
		for(i=0; i<MAX_PICKER_; i++)
		{
			m_nPicker[TYPE_FLAG_][i] = CTL_NO;	// [리셋] 플래그 정보
			
			// 악세사리 존재하는 버퍼에 대해서만 Vacuum 동작함
			//if (nRetData[i] == IO_ON)
			// kilee [2015.03.17]
			if (m_nSensor[i] == IO_ON)
			{
				m_nPicker[TYPE_FLAG_][i] = CTL_YES;	// 동작할 Vacuum으로 설정
			}
		}
		m_nStep_NG_Buff = 310;
		break;

	case 310:
		// Z축 모터를 NG 버퍼에서 악세사리 집기 위한 위치로 이동
		nRet = COMI.Start_SingleMove(m_nMotZ, st_motor[m_nMotZ].d_pos[Z_RBT_ACC_NG_BUFFER_PICK_], (int)st_handler.md_run_speed);
		if (nRet == CTLBD_RET_GOOD)
		{
			// 동작 상 무리가 없어 보이고 동작 시간 줄이기 위해 이곳에서 동작시킴
			// - m_nPicker[FLAG_INFO] : [case 300:]에서 설정됨
			OnSet_SolVacuum(IO_ON, m_nPicker[TYPE_FLAG_]);	// 그립퍼 Vacuum [ON:진공설정, OFF:진공해제]
			m_nStep_NG_Buff = 320;
		}
		else if (nRet == CTLBD_RET_ERROR || nRet == CTLBD_RET_SAFETY)
		{
			m_nStep_NG_Buff = 310;

			// 071002 0 00 "BARCODE_ROBOT_Z_RBT_ACC_NG_BUFFER_PICK_MOVE_ERR."
			alarm.mstr_code		= "071002";
			alarm.mn_count_mode	= 0;
			alarm.mn_type_mode	= eWARNING;
			st_work.nEqpStatus	= dWARNING;
		}
		break;

	case 320:
		nRet = COMI.Check_SingleMove(m_nMotZ, st_motor[m_nMotZ].d_pos[Z_RBT_ACC_NG_BUFFER_PICK_]);
		if (nRet == CTLBD_RET_GOOD)
		{
			m_nStep_NG_Buff = 330;
		}
		else if (nRet == CTLBD_RET_ERROR || nRet == CTLBD_RET_SAFETY)
		{
			m_nStep_NG_Buff = 310;
			
			// 071002 0 00 "BARCODE_ROBOT_Z_RBT_ACC_NG_BUFFER_PICK_MOVE_ERR."
			alarm.mstr_code		= "071002";
			alarm.mn_count_mode	= 0;
			alarm.mn_type_mode	= eWARNING;
			st_work.nEqpStatus	= dWARNING;
		}
		else if (nRet == CTLBD_RET_RETRY)
		{
			m_nStep_NG_Buff = 310;
		}
		break;

	case 330:
		nRet = OnGet_SolVacuum(IO_ON, m_nPicker[TYPE_FLAG_], m_nPicker[TYPE_SEN_]);
		// 어찌되었던 동작이 완료될때까지 대기
		// - 피커를 들고 알람을 출력시키기 위함
		if (nRet == CTL_GOOD || nRet == CTL_ERROR)
		{
			m_nStep_NG_Buff = 340;
		}
		break;

	case 340:
		nRet = CTL_Lib.OnSingleMove(m_nMotZ, st_motor[m_nMotZ].d_pos[Z_RBT_SAFETY_], (int)st_handler.md_run_speed);
		if (nRet == CTLBD_RET_GOOD)
		{
			m_lTime_GoesBy[0] = GetCurrentTime();
			m_nStep_NG_Buff = 350;
		}
		else if (nRet == CTLBD_RET_ERROR || nRet == CTLBD_RET_RETRY)
		{
			// 071005 0 07 "BARCODE_ROBOT_Z_RBT_SAFETY_MOVE_ERR."
			alarm.mstr_code		= "071005";
			alarm.mn_count_mode	= 0;
			alarm.mn_type_mode	= eWARNING;
			st_work.nEqpStatus	= dWARNING;
		}
		break;

	case 350:
		// 그립퍼의 자재 상태 반환
		// - m_nPicker : [case 300:]에서 설정됨
		nRet = Func.OnGet_PickerStatus(0, CTL_YES, m_nPicker);
		if (nRet == CTL_ERROR)
		{
			m_lTime_GoesBy[1] = GetCurrentTime();
			m_lTime_GoesBy[2] = m_lTime_GoesBy[1] - m_lTime_GoesBy[0];
			if (m_lTime_GoesBy[2] < 0)
			{
				m_lTime_GoesBy[0] = GetCurrentTime();
				break;
			}
			
			if (m_lTime_GoesBy[2] < 10)
			{
				break;
			}
		}
		// [자재 정상] : 곧바로 밑에 부분 실행
		// [자재 에러] : 일정 시간 대기 후에 밑에 부분 실행

		// 전체 그립퍼 갯수 가운데
		for(i=0; i<MAX_PICKER_; i++)
		{
			// 악세사리 집기 동작 진행한 그리퍼에 한해서 악세사리가 Vacuum 센서에 감지된 경우
			if (m_nPicker[TYPE_FLAG_][i] == CTL_YES && m_nPicker[TYPE_SEN_][i] == CTL_YES)
			{
				// 그립퍼의 구조체 정보 갱신 [자재 지었음]
				st_map.nXYZRbtPickerInfo[i]	= CTL_YES;
				m_nPicker[TYPE_FLAG_][i]	= CTL_NO;
			}
		}

		// OnGet_PickerStatus() 함수에서는 [CTL_GOOD/CTL_ERROR] 반환되었을 것임
		if (nRet == CTL_GOOD)
		{
			m_nStep_NG_Buff = 500;
		}
		else
		{
			m_nRepickCount++;	// 재시도 횟수 증가
			if (m_nRepickCount > 2)
			{
				m_nRepickCount = 2;
			}
			m_nStep_NG_Buff = 310;	// 악세사리 집기 동작 재시도

			if (m_nRepickCount >= 2)
			{
				m_nRepickCount = 0;	// [리셋] 자재 집기 시도 횟수

				// OnGet_PickerStatus() 함수 안에서 알람 코드 설정됨
				alarm.mn_count_mode	= 0;
				alarm.mn_type_mode	= eWARNING;
				st_work.nEqpStatus	= dWARNING;
			}
		}
		break;
		//==========================================================//

	case 500:
		// 규이리 수정 [2015.03.14]
		nRetData[0] = OnCheck_NGBufferFrontAccy(IO_ON,	CHK_NOT_EXIST_, SIDE_LEFT_);
		nRetData[1] = OnCheck_NGBufferFrontAccy(IO_ON,	CHK_NOT_EXIST_, SIDE_RIGHT_);
		nRetData[2] = OnCheck_NGBufferRearAccy(IO_ON,	CHK_NOT_EXIST_, SIDE_LEFT_);
		nRetData[3] = OnCheck_NGBufferRearAccy(IO_ON,	CHK_NOT_EXIST_, SIDE_RIGHT_);

		for(i=0; i<MAX_PICKER_; i++)
		{
			if (st_map.nXYZRbtPickerInfo[i] == CTL_YES)
			{
				if (nRetData[i] != IO_OFF)
				{
					// 못집은 악세사리 존재함
					// Vacuum 센서가 문제가 있어 실재로 못 집었는데 감지된 경우
					iCheckCount++;
				}
			}
		}

		if (iCheckCount > 0)
		{
			m_nStep_NG_Buff = 0;

			// 143000 0 00 "PS1204_PS1205_PS1206_PS1207_NG_BUFFER_ACCY_EXSIT_CHK_ERR."
			alarm.mstr_code		= "143000";
			alarm.mn_count_mode	= 0;
			alarm.mn_type_mode	= eWARNING;
			st_work.nEqpStatus	= dWARNING;

			break;
		}

		for(i=0; i<MAX_PICKER_; i++)
		{
			if (st_map.nXYZRbtPickerInfo[i] == CTL_YES)
			{
				st_map.nBCR_State[i] = BCR_READ_BAD_;
			}
			else
			{
				st_map.nBCR_State[i] = BCR_READ_GOOD_;
			}
		}
		m_nStep_NG_Buff = 1000;
		break;

	case 1000:
		// Gripper가 잡고 있는 Accy 배출 (SIDE_FRONT_ : 1, 2번 Gripper, SIDE_REAR_ : 3, 4번 Gripper)
		nRet = OnProc_AccyOut(st_map.nBCR_State, SIDE_REAR_);

		if (nRet == CTLBD_RET_GOOD)
		{
			m_nStep_NG_Buff = 1100;
		}
		break;

	case 1100:
		// Gripper가 잡고 있는 Accy 배출 (SIDE_FRONT_ : 1, 2번 Gripper, SIDE_REAR_ : 3, 4번 Gripper)
		nRet = OnProc_AccyOut(st_map.nBCR_State, SIDE_FRONT_);

		if (nRet == CTLBD_RET_GOOD)
		{
			m_nStep_NG_Buff = 1200;
		}
		break;

	case 1200:
		nRet = CTL_Lib.OnSingleMove(m_nMotY, st_motor[m_nMotY].d_pos[Y_RBT_ACC_NG_BUFFER_], (int)st_handler.md_run_speed);
		if (nRet == CTLBD_RET_GOOD)
		{
			m_nStep_NG_Buff = 2000;
		}
		else if (nRet == CTLBD_RET_ERROR || nRet == CTLBD_RET_RETRY)
		{
			// 051008 0 00 "BARCODE_ROBOT_Y_RBT_ACC_NG_BUFFER_MOVE_ERR."
			alarm.mstr_code		= "051008";
			alarm.mn_count_mode	= 0;
			alarm.mn_type_mode	= eWARNING;
			st_work.nEqpStatus	= dWARNING;
		}
		break;

	case 2000:
		memset(st_map.nNGBuffer, ACCY_NO_, sizeof(st_map.nNGBuffer));
		m_nStep_NG_Buff = 0;
		nFuncRet = CTL_GOOD;
		break;
	}

	return nFuncRet;
}

//////////////////////////////////////////////////////////////////////////
// Buffer Conv 배출 작업
//////////////////////////////////////////////////////////////////////////
int CSeq_XYZRobot::OnProc_BufferConvClear()
{
	Func.OnTrace_ThreadStep(20, m_nStep_BufferConvClear);	// 쓰레드 스텝 정보 TRACE
	int nFuncRet = CTL_PROCEED;
	int nRet = VAR_INIT_;
	int i, iCheckCount = 0;
	int nRetData[4] = {0,};
	
	switch(m_nStep_BufferConvClear)
	{
	case 0:
		// Z축 모터를 안전 위치로 이동시킴
		nRet = CTL_Lib.OnSingleMove(m_nMotZ, st_motor[m_nMotZ].d_pos[Z_RBT_SAFETY_], (int)st_handler.md_run_speed);
		if (nRet == CTLBD_RET_GOOD)
		{
			m_nStep_BufferConvClear = 10;
		}
		else if (nRet == CTLBD_RET_ERROR || nRet == CTLBD_RET_RETRY)
		{
			// 071005 0 07 "BARCODE_ROBOT_Z_RBT_SAFETY_MOVE_ERR."
			alarm.mstr_code		= "071005";
			alarm.mn_count_mode	= 0;
			alarm.mn_type_mode	= eWARNING;
			st_work.nEqpStatus	= dWARNING;
		}
		break;

	case 10:
		nRet = CTL_Lib.OnSingleMove(m_nMotY, st_motor[m_nMotY].d_pos[Y_RBT_ACC_CONV_R_BUFF_], (int)st_handler.md_run_speed);
		if (nRet == CTLBD_RET_GOOD)
		{
			// 초기에는 그립퍼+Vacuum 모드도 가능하다고 했는데 실재로는 불가능함
			// - 그립퍼면 그립퍼만 사용, Vacuum이면 Vacuum만 사용해야 함
			if (st_basic.nMode_GripUsing == GRIP_USING)
			{
				m_nStep_BufferConvClear = 50;	// 그립퍼 모드 사용
			}
			else if (st_basic.nMode_VacUsing == VAC_USING)
			{
				//m_nStep_NG_Buff = 60;
				// 규이리 수정 [2015.03.14]
				// 이전 동작에서 이미 (Vacuum Off) 진행했을 것이므로 다시 진행하지 않도록 함
				// - 해도 무방하지만 대기 시간만큼의 시간이 더 소요됨
				m_nStep_BufferConvClear = 80;
			}
		}
		else if (nRet == CTLBD_RET_ERROR || nRet == CTLBD_RET_RETRY)
		{
			// 051010 0 00 "BARCODE_ROBOT_Y_RBT_ACC_BUFFER_CONV_REAR_MOVE_ERR."
			alarm.mstr_code		= "051010";
			alarm.mn_count_mode	= 0;
			alarm.mn_type_mode	= eWARNING;
			st_work.nEqpStatus	= dWARNING;
		}
		break;

		//==========================================================//
		// Grip 사용 모드
		//==========================================================//
	case 50:
		// [0],[1],[2],[3] Grip Off
		nRet = OnProc_Grip(15, IO_OFF);
		if (nRet == CTLBD_RET_GOOD)
		{
			m_nGirpSum = 0;
			m_nStep_BufferConvClear = 80;
		}
		break;

	case 80:
		// yangkyu [2015.02.22]
		// 번호는 메인 설비 정면 기준으로 0(앞쪽 좌), 1(앞쪽 우), 2(뒤쪽 좌), 3(뒤쪽 우)
		// Buffer Conv에 자재가 존재 하는지 확인
		nRetData[0] = OnCheck_FrontAccySupply(IO_ON, CHK_NOT_EXIST_, SIDE_LEFT_);		// Buffer Conv Front Accy 확인
		nRetData[1] = OnCheck_FrontAccySupply(IO_ON, CHK_NOT_EXIST_, SIDE_RIGHT_);		// Buffer Conv Front Accy 확인		
		nRetData[2] = OnCheck_RearAccySupply(IO_ON, CHK_NOT_EXIST_, SIDE_LEFT_);		// Buffer Conv Rear Accy 확인
		nRetData[3] = OnCheck_RearAccySupply(IO_ON, CHK_NOT_EXIST_, SIDE_RIGHT_);		// Buffer Conv Rear Accy 확인

		if (st_basic.n_mode_device == WITHOUT_DVC_)
		{
			for(i=0; i<MAX_PICKER_; i++)
			{
				nRetData[i] = st_map.nBufferCovAccyExist[i];
			}
		}

		// kilee [2015.03.17]
		for(i=0; i<MAX_PICKER_; i++)
		{
			m_nSensor[i] = nRetData[i];
		}
		
		m_nGirpSum = (nRetData[0] * 1) + (nRetData[1] * 2) + (nRetData[2] * 4) + (nRetData[3] * 8);
		
		// 그립퍼 사용 모드인 경우
		if (st_basic.nMode_GripUsing == GRIP_USING)
		{
			m_nStep_BufferConvClear = 200;
		}
		else if (st_basic.nMode_VacUsing == VAC_USING)
		{
			m_nStep_BufferConvClear = 300;
		}
		break;
		
		//==========================================================//
		// 그립퍼 사용 모드
		//==========================================================//
	case 200:
		// yangkyu [2015.03.05]
		nRet = CTL_Lib.OnSingleMove(m_nMotZ, st_motor[m_nMotZ].d_pos[Z_RBT_ACC_BUFFER_CONV_PICK_], (int)st_handler.md_run_speed);
		if (nRet == CTLBD_RET_GOOD)
		{
			m_nStep_BufferConvClear = 250;
		}
		else if (nRet == CTLBD_RET_ERROR || nRet == CTLBD_RET_RETRY)
		{
			// 071004 0 00 "BARCODE_ROBOT_Z_RBT_ACC_BUFFER_CONV_PICK_MOVE_ERR."
			alarm.mstr_code		= "071004";
			alarm.mn_count_mode	= 0;
			alarm.mn_type_mode	= eWARNING;
			st_work.nEqpStatus	= dWARNING;
		}
		break;
		
	case 250:
		// 악세사리 존재하는 그립퍼 동작시킴
		nRet = OnProc_Grip(m_nGirpSum, IO_ON);
		if (nRet == CTLBD_RET_GOOD)
		{
			m_nStep_BufferConvClear = 400;
		}
		break;

	case 260:
		nRet = CTL_Lib.OnSingleMove(m_nMotZ, st_motor[m_nMotZ].d_pos[Z_RBT_SAFETY_], (int)st_handler.md_run_speed);
		if (nRet == CTLBD_RET_GOOD)
		{
			m_nStep_BufferConvClear = 500;
		}
		else if (nRet == CTLBD_RET_ERROR || nRet == CTLBD_RET_RETRY)
		{
			// 071005 0 07 "BARCODE_ROBOT_Z_RBT_SAFETY_MOVE_ERR."
			alarm.mstr_code		= "071005";
			alarm.mn_count_mode	= 0;
			alarm.mn_type_mode	= eWARNING;
			st_work.nEqpStatus	= dWARNING;
		}
		break;
		//==========================================================//

		//==========================================================//
		// Vacuum 사용 모드
		//==========================================================//
	case 300:
		m_nRepickCount = 0;  // [리셋] 자재 집기 시도 횟수

		// 전체 피커 갯수 가운데
		for(i=0; i<MAX_PICKER_; i++)
		{
			m_nPicker[TYPE_FLAG_][i] = CTL_NO;	// [리셋] 플래그 정보
			
			// 악세사리 존재하는 버퍼에 대해서만 Vacuum 동작함
			//if (nRetData[i] == IO_ON)
			// kilee [2015.03.17]
			if (m_nSensor[i] == IO_ON)
			{
				m_nPicker[TYPE_FLAG_][i] = CTL_YES;	// 동작할 Vacuum으로 설정
			}
		}
		m_nStep_BufferConvClear = 310;
		break;

	case 310:
		// Z축 모터를 NG 버퍼에서 악세사리 집기 위한 위치로 이동
		nRet = COMI.Start_SingleMove(m_nMotZ, st_motor[m_nMotZ].d_pos[Z_RBT_ACC_BUFFER_CONV_PICK_], (int)st_handler.md_run_speed);
		if (nRet == CTLBD_RET_GOOD)
		{
			// 동작 상 무리가 없어 보이고 동작 시간 줄이기 위해 이곳에서 동작시킴
			// - m_nPicker[FLAG_INFO] : [case 300:]에서 설정됨
			OnSet_SolVacuum(IO_ON, m_nPicker[TYPE_FLAG_]);	// 그립퍼 Vacuum [ON:진공설정, OFF:진공해제]
			m_nStep_BufferConvClear = 320;
		}
		else if (nRet == CTLBD_RET_ERROR || nRet == CTLBD_RET_SAFETY)
		{
			//m_nStep_NG_Buff = 310;
			// kilee [2015.03.17]
			m_nStep_BufferConvClear = 310;

			// 071004 0 00 "BARCODE_ROBOT_Z_RBT_ACC_BUFFER_CONV_PICK_MOVE_ERR."
			alarm.mstr_code		= "071004";
			alarm.mn_count_mode	= 0;
			alarm.mn_type_mode	= eWARNING;
			st_work.nEqpStatus	= dWARNING;
		}
		break;

	case 320:
		//nRet = COMI.Check_SingleMove(m_nMotZ, st_motor[m_nMotZ].d_pos[Z_RBT_ACC_NG_BUFFER_PICK_]);
		// kilee [2015.03.17]
		nRet = COMI.Check_SingleMove(m_nMotZ, st_motor[m_nMotZ].d_pos[Z_RBT_ACC_BUFFER_CONV_PICK_]);
		if (nRet == CTLBD_RET_GOOD)
		{
			m_nStep_BufferConvClear = 330;
		}
		else if (nRet == CTLBD_RET_ERROR || nRet == CTLBD_RET_SAFETY)
		{
			m_nStep_BufferConvClear = 310;
			
			// 071004 0 00 "BARCODE_ROBOT_Z_RBT_ACC_BUFFER_CONV_PICK_MOVE_ERR."
			alarm.mstr_code		= "071004";
			alarm.mn_count_mode	= 0;
			alarm.mn_type_mode	= eWARNING;
			st_work.nEqpStatus	= dWARNING;
		}
		else if (nRet == CTLBD_RET_RETRY)
		{
			m_nStep_BufferConvClear = 310;
		}
		break;

	case 330:
		nRet = OnGet_SolVacuum(IO_ON, m_nPicker[TYPE_FLAG_], m_nPicker[TYPE_SEN_]);
		// 어찌되었던 동작이 완료될때까지 대기
		// - 피커를 들고 알람을 출력시키기 위함
		if (nRet == CTL_GOOD || nRet == CTL_ERROR)
		{
			m_nStep_BufferConvClear = 340;
		}
		break;

	case 340:
		nRet = CTL_Lib.OnSingleMove(m_nMotZ, st_motor[m_nMotZ].d_pos[Z_RBT_SAFETY_], (int)st_handler.md_run_speed);
		if (nRet == CTLBD_RET_GOOD)
		{
			m_lTime_GoesBy[0] = GetCurrentTime();
			m_nStep_BufferConvClear = 350;
		}
		else if (nRet == CTLBD_RET_ERROR || nRet == CTLBD_RET_RETRY)
		{
			// 071005 0 07 "BARCODE_ROBOT_Z_RBT_SAFETY_MOVE_ERR."
			alarm.mstr_code		= "071005";
			alarm.mn_count_mode	= 0;
			alarm.mn_type_mode	= eWARNING;
			st_work.nEqpStatus	= dWARNING;
		}
		break;

	case 350:
		// 그립퍼의 자재 상태 반환
		// - m_nPicker : [case 300:]에서 설정됨
		nRet = Func.OnGet_PickerStatus(0, CTL_YES, m_nPicker);
		if (nRet == CTL_ERROR)
		{
			m_lTime_GoesBy[1] = GetCurrentTime();
			m_lTime_GoesBy[2] = m_lTime_GoesBy[1] - m_lTime_GoesBy[0];
			if (m_lTime_GoesBy[2] < 0)
			{
				m_lTime_GoesBy[0] = GetCurrentTime();
				break;
			}
			
			if (m_lTime_GoesBy[2] < 10)
			{
				break;
			}
		}
		// [자재 정상] : 곧바로 밑에 부분 실행
		// [자재 에러] : 일정 시간 대기 후에 밑에 부분 실행

		// 전체 그립퍼 갯수 가운데
		for(i=0; i<MAX_PICKER_; i++)
		{
			// 악세사리 집기 동작 진행한 그리퍼에 한해서 악세사리가 Vacuum 센서에 감지된 경우
			if (m_nPicker[TYPE_FLAG_][i] == CTL_YES && m_nPicker[TYPE_SEN_][i] == CTL_YES)
			{
				// 그립퍼의 구조체 정보 갱신 [자재 지었음]
				st_map.nXYZRbtPickerInfo[i]	= CTL_YES;
				m_nPicker[TYPE_FLAG_][i]	= CTL_NO;
			}
		}

		// OnGet_PickerStatus() 함수에서는 [CTL_GOOD/CTL_ERROR] 반환되었을 것임
		if (nRet == CTL_GOOD)
		{
			m_nStep_BufferConvClear = 500;
		}
		else
		{
			m_nRepickCount++;	// 재시도 횟수 증가
			if (m_nRepickCount > 2)
			{
				m_nRepickCount = 2;
			}
			m_nStep_BufferConvClear = 310;	// 악세사리 집기 동작 재시도

			if (m_nRepickCount >= 2)
			{
				m_nRepickCount = 0;	// [리셋] 자재 집기 시도 횟수

				// OnGet_PickerStatus() 함수 안에서 알람 코드 설정됨
				alarm.mn_count_mode	= 0;
				alarm.mn_type_mode	= eWARNING;
				st_work.nEqpStatus	= dWARNING;
			}
		}
		break;
		//==========================================================//

	case 500:
		// yangkyu [2015.02.22]
		// 번호는 메인 설비 정면 기준으로 0(앞쪽 좌), 1(앞쪽 우), 2(뒤쪽 좌), 3(뒤쪽 우)
		// Buffer Conv에 자재가 존재 하는지 확인
		nRetData[0] = OnCheck_FrontAccySupply(IO_ON, CHK_NOT_EXIST_, SIDE_LEFT_);		// Buffer Conv Front Accy 확인
		nRetData[1] = OnCheck_FrontAccySupply(IO_ON, CHK_NOT_EXIST_, SIDE_RIGHT_);		// Buffer Conv Front Accy 확인		
		nRetData[2] = OnCheck_RearAccySupply(IO_ON, CHK_NOT_EXIST_, SIDE_LEFT_);		// Buffer Conv Rear Accy 확인
		nRetData[3] = OnCheck_RearAccySupply(IO_ON, CHK_NOT_EXIST_, SIDE_RIGHT_);		// Buffer Conv Rear Accy 확인

		for (i = 0; i < MAX_PICKER_; i++)
		{
			if(st_map.nXYZRbtPickerInfo[i] == IO_ON)
			{
				if (nRetData[i] != IO_OFF)
				{
					// 못집은 악세사리 존재함
					// Vacuum 센서가 문제가 있어 실재로 못 집었는데 감지된 경우
					iCheckCount++;
				}
			}
		}

		if (iCheckCount > 0)
		{
			m_nStep_BufferConvClear = 0;

			// 142000 0 00 "PS1106_PS1107_PS1108_PS1109_ACCY_CONV_ACCY_EXSIT_CHK_ERR."
			alarm.mstr_code		= "142000";
			alarm.mn_count_mode	= 0;
			alarm.mn_type_mode	= eWARNING;
			st_work.nEqpStatus	= dWARNING;
			break;
		}
		else
		{
			for (i = 0; i < MAX_PICKER_; i++)
			{
				if(st_map.nXYZRbtPickerInfo[i] == CTL_YES)
				{
					st_map.nBCR_State[i] = BCR_READ_BAD_;
				}
				else
				{
					st_map.nBCR_State[i] = BCR_READ_GOOD_;
				}
			}
			m_nStep_BufferConvClear = 1000;
		}
		break;
		
	case 1000:
		// Gripper가 잡고 있는 Accy 배출 (SIDE_FRONT_ : 1, 2번 Gripper, SIDE_REAR_ : 3, 4번 Gripper)
		nRet = OnProc_AccyOut(st_map.nBCR_State, SIDE_REAR_);
		if (nRet == CTLBD_RET_GOOD)
		{
			m_nStep_BufferConvClear = 1100;
		}
		break;
		
	case 1100:
		// Gripper가 잡고 있는 Accy 배출 (SIDE_FRONT_ : 1, 2번 Gripper, SIDE_REAR_ : 3, 4번 Gripper)
		nRet = OnProc_AccyOut(st_map.nBCR_State, SIDE_FRONT_);
		if (nRet == CTLBD_RET_GOOD)
		{
			m_nStep_BufferConvClear = 1200;
		}
		break;
		
	case 1200:
		nRet = CTL_Lib.OnSingleMove(m_nMotY, st_motor[m_nMotY].d_pos[Y_RBT_ACC_NG_BUFFER_], (int)st_handler.md_run_speed);
		if (nRet == CTLBD_RET_GOOD)
		{
			m_nStep_BufferConvClear = 2000;
		}
		else if (nRet == CTLBD_RET_ERROR || nRet == CTLBD_RET_RETRY)
		{
			// 051008 0 00 "BARCODE_ROBOT_Y_RBT_ACC_NG_BUFFER_MOVE_ERR."
			alarm.mstr_code		= "051008";
			alarm.mn_count_mode	= 0;
			alarm.mn_type_mode	= eWARNING;
			st_work.nEqpStatus	= dWARNING;
		}
		break;

	case 2000:
		memset(st_map.nBufferCovAccyExist, ACCY_NO_, sizeof(st_map.nBufferCovAccyExist));
		if (st_handler.cwnd_main != NULL)
		{
			st_handler.cwnd_main->PostMessage(WM_UPDATE_MAIN, PLACE_BUFFER_CONV_);	// 화면 표시 요청
		}
		m_nStep_BufferConvClear = 0;
		nFuncRet = CTL_GOOD;
		break;
	}
	
	return nFuncRet;
}

//////////////////////////////////////////////////////////////////////////
// 바코드 상태가 Bad일 경우 처리하는 함수
//////////////////////////////////////////////////////////////////////////
int CSeq_XYZRobot::OnProc_BCRStateBad()
{
	int nFuncRet = CTL_PROCEED;
	
	int nRet = VAR_INIT_;
	int nRetData[4] = {0,};
	int i = 0;
	int iCheckCount = 0;
	int nSupplyMathCount = 0;

	Func.OnTrace_ThreadStep(11, m_nStep_BCRBad);	// 쓰레드 스텝 정보 TRACE
	
	switch(m_nStep_BCRBad)
	{
	case 0:
		// yangkyu [2015.02.22]
		// 번호는 메인 설비 정면 기준으로 0(앞쪽 좌), 1(앞쪽 우), 2(뒤쪽 좌), 3(뒤쪽 우)
		// NG Buffer 자재 확인
		nRetData[0] = OnCheck_NGBufferFrontAccy(IO_ON, CHK_EXIST_, SIDE_LEFT_);
		nRetData[1] = OnCheck_NGBufferFrontAccy(IO_ON, CHK_EXIST_, SIDE_RIGHT_);
		nRetData[2] = OnCheck_NGBufferRearAccy(IO_ON, CHK_EXIST_, SIDE_LEFT_);
		nRetData[3] = OnCheck_NGBufferRearAccy(IO_ON, CHK_EXIST_, SIDE_RIGHT_);

		if (st_basic.n_mode_device == WITHOUT_DVC_)
		{
			nRetData[0] = st_map.nNGBuffer[0];
			nRetData[1] = st_map.nNGBuffer[1];
			nRetData[2] = st_map.nNGBuffer[2];
			nRetData[3] = st_map.nNGBuffer[3];
			
		}

		for (i = 0; i < 4; i++)
		{
			if (st_map.nNGBuffer[i] != nRetData[i])
			{
				iCheckCount++;
			}
		}

		if (iCheckCount > 0)
		{
			// 151000 0 00 "PS1204_PS1205_PS1206_PS1207_NG_BUFFER_DATA_MISS_MATH."
			alarm.mstr_code		= "151000";
			alarm.mn_count_mode	= 0;
			alarm.mn_type_mode	= eWARNING;
			st_work.nEqpStatus	= dWARNING;
			break;
		}

		// 1번 Gripper : NG Buffer(1, 3) 확인
		if(st_map.nBCR_State[0] == BCR_READ_BAD_)
		{
			if (nRetData[0] == IO_ON)
			{
				nSupplyMathCount++;
				nRetData[0] = IO_OFF;
			}
			else if (nRetData[2] == IO_ON)
			{
				nSupplyMathCount++;
				nRetData[2] = IO_OFF;
			}
		}
		else if(st_map.nBCR_State[0] == BCR_READ_GOOD_)
		{
			nSupplyMathCount++;
		}

		// 2번 Gripper : NG Buffer(2, 4) 확인
		if(st_map.nBCR_State[1] == BCR_READ_BAD_)
		{
			if (nRetData[1] == IO_ON)
			{
				nSupplyMathCount++;
				nRetData[1] = IO_OFF;
			}
			else if (nRetData[3] == IO_ON)
			{
				nSupplyMathCount++;
				nRetData[3] = IO_OFF;
			}
		}
		else if(st_map.nBCR_State[1] == BCR_READ_GOOD_)
		{
			nSupplyMathCount++;
		}

		// 3번 Gripper : NG Buffer(3, 4) 확인
		if(st_map.nBCR_State[2] == BCR_READ_BAD_)
		{
			if (nRetData[2] == IO_ON)
			{
				nSupplyMathCount++;
				nRetData[2] = IO_OFF;
			}
			else if (nRetData[0] == IO_ON)
			{
				nSupplyMathCount++;
				nRetData[0] = IO_OFF;
			}
		}
		else if(st_map.nBCR_State[2] == BCR_READ_GOOD_)
		{
			nSupplyMathCount++;
		}

		// 4번 Gripper : NG Buffer(3, 4) 확인
		if(st_map.nBCR_State[3] == BCR_READ_BAD_)
		{
			if (nRetData[3] == IO_ON)
			{
				nSupplyMathCount++;
				nRetData[3] = IO_OFF;
			}
			else if (nRetData[1] == IO_ON)
			{
				nSupplyMathCount++;
				nRetData[1] = IO_OFF;
			}
		}
		else if(st_map.nBCR_State[3] == BCR_READ_GOOD_)
		{
			nSupplyMathCount++;
		}

		// 보급 할 자재가 있을 경우
		if (nSupplyMathCount == 4)
		{
			m_nStep_BCRBad = 1000;
		}
		// 보급 할 자재가 없는 경우 NG Buffer와 중복되는 Gripper를 제거 한 후 Accy 보급
		else
		{
			m_nStep_BCRBad = 8000;
		}
		break;

	case 1000:
		// Gripper가 잡고 있는 Accy 배출 (SIDE_FRONT_ : 1, 2번 Gripper, SIDE_REAR_ : 3, 4번 Gripper)
		nRet = OnProc_AccyOut(st_map.nBCR_State, SIDE_FRONT_);

		if (nRet == CTL_GOOD)
		{
			m_nStep_BCRBad = 1100;
		}
		break;

	case 1100:
		// Gripper가 잡고 있는 Accy 배출 (SIDE_FRONT_ : 1, 2번 Gripper, SIDE_REAR_ : 3, 4번 Gripper)
		nRet = OnProc_AccyOut(st_map.nBCR_State, SIDE_REAR_);

		if (nRet == CTL_GOOD)
		{
			stSync.nReq_XYZRbt2BufferAlaignConv_Work = SYNC_REQ_BUFFER_LOADING_READY_;
			m_nStep_BCRBad = 1300;
		}
		break;

	case 1300:
		// 규이리 수정 [2015.03.25]
		// [1:4개씩, 0:2개씩]
		if (st_basic.nMode_PlaceType == 0)
		{
			nRet = OnProc_BufferPlace();
		}
		else
		{
			nRet = OnProc_4BufferPlace();	// [Main<-Accy] 공급용 레일에 4개 악세사리 한꺼번에 내려놓기
		}

		if (nRet == CTL_GOOD)
		{
			m_nStep_BCRBad = 1800;
		}
		break;

	case 1800:
		// yangkyu [2015.02.22]
		// 번호는 메인 설비 정면 기준으로 0(앞쪽 좌), 1(앞쪽 우), 2(뒤쪽 좌), 3(뒤쪽 우)
		// NG Buffer 자재 확인
		nRetData[0] = OnCheck_NGBufferFrontAccy(IO_ON, CHK_EXIST_, SIDE_LEFT_);
		nRetData[1] = OnCheck_NGBufferFrontAccy(IO_ON, CHK_EXIST_, SIDE_RIGHT_);
		nRetData[2] = OnCheck_NGBufferRearAccy(IO_ON, CHK_EXIST_, SIDE_LEFT_);
		nRetData[3] = OnCheck_NGBufferRearAccy(IO_ON, CHK_EXIST_, SIDE_RIGHT_);

		if (st_basic.n_mode_device == WITHOUT_DVC_)
		{
			for (i = 0; i < 4; i++)
			{
				nRetData[i] = st_map.nNGBuffer[i];
			}
		}

		for (i = 0; i < 4; i++)
		{
			if (st_map.nNGBuffer[i] != nRetData[i])
			{
				iCheckCount++;
			}
		}
		
		if (iCheckCount > 0)
		{
			// 151000 0 00 "PS1204_PS1205_PS1206_PS1207_NG_BUFFER_DATA_MISS_MATH."
			alarm.mstr_code		= "151000";
			alarm.mn_count_mode	= 0;
			alarm.mn_type_mode	= eWARNING;
			st_work.nEqpStatus	= dWARNING;
			break;
		}
		
		// Gripper 와 NG Buffer 간의 1:1 비교 
		if (st_map.nBCR_State[0] == BCR_READ_BAD_ && nRetData[0] == IO_ON ||
			st_map.nBCR_State[1] == BCR_READ_BAD_ && nRetData[1] == IO_ON ||
			st_map.nBCR_State[2] == BCR_READ_BAD_ && nRetData[2] == IO_ON ||
			st_map.nBCR_State[3] == BCR_READ_BAD_ && nRetData[3] == IO_ON)
		{
			// 정상 적인 위치에 보급 자재가 있는 경우
			m_nNGBufferPickSite = SIDE_BOTH_; 
		}		
		// 같은 Line 선상 비교
		// Gripper 0 또는 1의 BCR 상태가 Bad인 경우 NG Buffer Rear의 자재를 확인
		else if(st_map.nBCR_State[0] == BCR_READ_BAD_ && nRetData[2] == IO_ON || st_map.nBCR_State[1] == BCR_READ_BAD_ && nRetData[3] == IO_ON )
		{
			m_nNGBufferPickSite = SIDE_REAR_; 
		}
		// Gripper 2 또는 3의 BCR 상태가 Bad인 경우 NG Buffer Front의 자재를 확인
		else if(st_map.nBCR_State[2] == BCR_READ_BAD_ && nRetData[0] == IO_ON || st_map.nBCR_State[3] == BCR_READ_BAD_ && nRetData[1] == IO_ON)
		{
			m_nNGBufferPickSite = SIDE_FRONT_; 
		}
		m_nStep_BCRBad = 2000;
		break;

	case 2000:
		// m_nNGBufferPickSite의 위치는 [case 1800:]에서 지정
		nRet = OnProc_NGBufferPick(m_nNGBufferPickSite);
		if (nRet == CTL_GOOD)
		{
			m_nStep_BCRBad = 2100;	
		}
		break;

	case 2100:
		// 규이리 수정 [2015.03.25]
		// [1:4개씩, 0:2개씩]
		if (st_basic.nMode_PlaceType == 0)
		{
			nRet = OnProc_BufferPlace();
		}
		else
		{
			nRet = OnProc_4BufferPlace();	// [Main<-Accy] 공급용 레일에 4개 악세사리 한꺼번에 내려놓기
		}

		if (nRet == CTL_GOOD)
		{
			// BCR 상태가 All Good 이면 완료 Step으로 이동
			if(st_map.nBCR_State[0] == BCR_READ_GOOD_ &&
				st_map.nBCR_State[1] == BCR_READ_GOOD_ &&
				st_map.nBCR_State[2] == BCR_READ_GOOD_ &&
				st_map.nBCR_State[3] == BCR_READ_GOOD_)
			{
				stSync.nReq_XYZRbt2BufferAlaignConv_Work = SYNC_REQ_WORK_COMPLETE_;
				m_nStep_BCRBad = 10000;
			}
			// BCR 상태가 Bad가 있을 경우 
			// 다른 위치의 악세사리 보급을 위해 1800 Step로 이동
			else if(st_map.nBCR_State[0] == BCR_READ_BAD_ || st_map.nBCR_State[1] == BCR_READ_BAD_ || st_map.nBCR_State[2] == BCR_READ_BAD_ || st_map.nBCR_State[3] == BCR_READ_BAD_)
			{
				m_nStep_BCRBad = 1800;
			}
		}
		break;

		// 같은 Line 위치에 보급 자재가 없는 경우 NG Buffer  공급
	case 8000:
		nRet = OnProc_NGBufferPlace();
		if (nRet == CTL_GOOD)
		{
			m_nStep_BCRBad = 10000;
		}
		break;
		
	case 10000:
		m_nStep_BCRBad = 0;
		nFuncRet = CTL_GOOD;
		break;
	}
	
	return nFuncRet;
}

//////////////////////////////////////////////////////////////////////////
// Accy 바코드 읽는 작업
//////////////////////////////////////////////////////////////////////////
int CSeq_XYZRobot::OnProc_ReadMove()
{
	int nFuncRet = CTL_PROCEED;
	
	int nRet = VAR_INIT_;
	int nRetData[4] = {0,};
	
	Func.OnTrace_ThreadStep(13, m_nStep_ReadMove);	// 쓰레드 스텝 정보 TRACE

	switch(m_nStep_ReadMove)
	{
		// KILEE [2015.03.23]
	case 0:
		nRet = CTL_Lib.OnSingleMove(m_nMotZ, st_motor[m_nMotZ].d_pos[Z_RBT_SAFETY_], (int)st_handler.md_run_speed);
		if (nRet == CTLBD_RET_GOOD)
		{
			// [Box Lifter -> XYZRbt] LIFT COMPLETE_ 요청 대기
			if(stSync.nReq_Lifter2XYZRbt_Work == SYNC_REQ_ACC_LIFT_COMPLETE_)
			{
				// [Box Lifter <- XYZRbt] 작업 중응답
				stSync.nResp_XYZRbt2Lifter_Work = SYNC_RESP_WORK_;
				
				memset(st_map.nBCR_State, -1, sizeof(st_map.nBCR_State));
				m_nStep_ReadMove = 100;
			}
			else
			{
				m_nStep_ReadMove = 50;
			}
		}
		else if (nRet == CTLBD_RET_ERROR || nRet == CTLBD_RET_RETRY)
		{
			// 071005 0 0 "BARCODE_ROBOT_Z_RBT_SAFETY_MOVE_ERR"
			alarm.mstr_code		= "071005";
			alarm.mn_count_mode	= 0;
			alarm.mn_type_mode	= eWARNING;
			st_work.nEqpStatus	= dWARNING;
		}
		break;

	//case 0:
	case 50:
		// [Box Lifter -> XYZRbt] LIFT COMPLETE_ 요청 대기
		if(stSync.nReq_Lifter2XYZRbt_Work == SYNC_REQ_ACC_LIFT_COMPLETE_)
		{
			// [Box Lifter <- XYZRbt] 작업 중응답
			stSync.nResp_XYZRbt2Lifter_Work = SYNC_RESP_WORK_;

			memset(st_map.nBCR_State, -1, sizeof(st_map.nBCR_State));
			m_nStep_ReadMove = 100;
		}
		break;

	case 100:
		// Y_RBT_ACC_BCR_ 위치에 d_Y_Gripper_Size를 (st_map.nLiftWorkSite * 2) + Site만큼을 곱한 위치로 이동함.
		// st_map.nLiftWorkSite(SIDE_FRONT = 0, SIDE_REAR = 1)
		m_dTargetPos = st_motor[m_nMotY].d_pos[Y_RBT_ACC_BCR_] - (st_accy.d_Y_Gripper_Size * ( (st_map.nLiftWorkSite * 2) + SIDE_FRONT_) );
		nRet = CTL_Lib.OnSingleMove(m_nMotY, m_dTargetPos, (int)st_handler.md_run_speed);
		
		if(nRet == CTLBD_RET_GOOD)
		{
			m_nStep_ReadMove = 200;
		}
		else if (nRet == CTLBD_RET_ERROR || nRet == CTLBD_RET_RETRY)
		{
			// 051001 0 00 "BARCODE_ROBOT_Y_RBT_ACC_BCR_1_MOVE_ERR."
			// 051002 0 00 "BARCODE_ROBOT_Y_RBT_ACC_BCR_2_MOVE_ERR."
			// 051003 0 00 "BARCODE_ROBOT_Y_RBT_ACC_BCR_3_MOVE_ERR."
			// 051004 0 00 "BARCODE_ROBOT_Y_RBT_ACC_BCR_4_MOVE_ERR."
			alarm.mstr_code.Format("05100%d", 1 + ( (st_map.nLiftWorkSite * 2) + SIDE_FRONT_) );
			alarm.mn_count_mode	= 0;
			alarm.mn_type_mode	= eWARNING;
			st_work.nEqpStatus	= dWARNING;
		}	
		break;

	case 200:
		// Lift 1번에서 공급된 Accy 바코드 읽기 작업
		nRet = OnBCRRead(SIDE_LEFT_);
		if (nRet == CTL_GOOD)
		{
			// 자재가 없는 경우에는 Rand 확률을 이용하여 구분 하도록 설정
			if (st_basic.n_mode_device == WITHOUT_DVC_)
			{
				srand((unsigned)time(NULL));
				int nRand = rand() % 10;
				
				if(nRand < 8)
				{
					st_map.nBCR_State[0] = BCR_READ_GOOD_;
				}
				else
				{
					st_map.nBCR_State[0] = BCR_READ_BAD_;
				}
			}
			else
			{
				if (st_work.sRbtBCR_Data[0] == st_work.m_sAccyMathCode)
				{
					st_map.nBCR_State[0] = BCR_READ_GOOD_;
				}
				else
				{
					st_map.nBCR_State[0] = BCR_READ_BAD_;
				}
			}
			if (st_handler.cwnd_main != NULL)
			{
				// 바코드 상태 표시 초기화 요청
				st_handler.cwnd_main->PostMessage(WM_UPDATE_MAIN, READ_BCR_DATA);
			}
			m_nStep_ReadMove = 300;
			
		}
		break;

	
	case 300:
		// Lift 2번에서 공급된 Accy 바코드 읽기 작업
		nRet = OnBCRRead(SIDE_RIGHT_);
		if (nRet == CTL_GOOD)
		{
			// 자재가 없는 경우에는 Rand 확률을 이용하여 구분 하도록 설정
			if (st_basic.n_mode_device == WITHOUT_DVC_)
			{
				srand((unsigned)time(NULL));
				int nRand = rand() % 10;
				
				if(nRand < 8)
				{
					st_map.nBCR_State[1] = BCR_READ_GOOD_;
				}
				else
				{
					st_map.nBCR_State[1] = BCR_READ_BAD_;
				}
			}
			else
			{
				if (st_work.sRbtBCR_Data[1] == st_work.m_sAccyMathCode)
				{
					st_map.nBCR_State[1] = BCR_READ_GOOD_;
				}
				else
				{
					st_map.nBCR_State[1] = BCR_READ_BAD_;
				}
			}
			if (st_handler.cwnd_main != NULL)
			{
				// 바코드 상태 표시 초기화 요청
				st_handler.cwnd_main->PostMessage(WM_UPDATE_MAIN, READ_BCR_DATA);
			}
			m_nStep_ReadMove = 600;
		}
		break;

	case 600:
		// Y_RBT_ACC_BCR_ 위치에 d_Y_Gripper_Size를 (st_map.nLiftWorkSite * 2) + Site만큼을 곱한 위치로 이동함.
		// st_map.nLiftWorkSite(SIDE_FRONT = 0, SIDE_REAR = 1)
		m_dTargetPos = st_motor[m_nMotY].d_pos[Y_RBT_ACC_BCR_] - (st_accy.d_Y_Gripper_Size * ( (st_map.nLiftWorkSite * 2) + SIDE_REAR_) );
		nRet = CTL_Lib.OnSingleMove(m_nMotY, m_dTargetPos, (int)st_handler.md_run_speed);
		
		if(nRet == CTLBD_RET_GOOD)
		{
			m_nStep_ReadMove = 800;
		}
		else if (nRet == CTLBD_RET_ERROR || nRet == CTLBD_RET_RETRY)
		{
			// 051001 0 00 "BARCODE_ROBOT_Y_RBT_ACC_BCR_1_MOVE_ERR."
			// 051002 0 00 "BARCODE_ROBOT_Y_RBT_ACC_BCR_2_MOVE_ERR."
			// 051003 0 00 "BARCODE_ROBOT_Y_RBT_ACC_BCR_3_MOVE_ERR."
			// 051004 0 00 "BARCODE_ROBOT_Y_RBT_ACC_BCR_4_MOVE_ERR."
			alarm.mstr_code.Format("05100%d", 1 + ( (st_map.nLiftWorkSite * 2) + SIDE_REAR_) );
			alarm.mn_count_mode	= 0;
			alarm.mn_type_mode	= eWARNING;
			st_work.nEqpStatus	= dWARNING;
		}
		break;

	case 800:
		// Lift 4번에서 공급된 Accy 바코드 읽기 작업
		nRet = OnBCRRead(SIDE_RIGHT_);
		if (nRet == CTL_GOOD)
		{
			// 자재가 없는 경우에는 Rand 확률을 이용하여 구분 하도록 설정
			if (st_basic.n_mode_device == WITHOUT_DVC_)
			{
				srand((unsigned)time(NULL));
				int nRand = rand() % 10;
				
				if(nRand < 8)
				{
					st_map.nBCR_State[3] = BCR_READ_GOOD_;
				}
				else
				{
					st_map.nBCR_State[3] = BCR_READ_BAD_;
				}
			}
			else
			{
				if (st_work.sRbtBCR_Data[3] == st_work.m_sAccyMathCode)
				{
					st_map.nBCR_State[3] = BCR_READ_GOOD_;
				}
				else
				{
					st_map.nBCR_State[3] = BCR_READ_BAD_;
				}
			}
			if (st_handler.cwnd_main != NULL)
			{
				// 바코드 상태 표시 초기화 요청
				st_handler.cwnd_main->PostMessage(WM_UPDATE_MAIN, READ_BCR_DATA);
			}
			m_nStep_ReadMove = 900;
		}
		break;

	case 900:
		// Lift 3번에서 공급된 Accy 바코드 읽기 작업
		nRet = OnBCRRead(SIDE_LEFT_);
		if (nRet == CTL_GOOD)
		{
			// 자재가 없는 경우에는 Rand 확률을 이용하여 구분 하도록 설정
			if (st_basic.n_mode_device == WITHOUT_DVC_)
			{
				srand((unsigned)time(NULL));
				int nRand = rand() % 10;
				
				if(nRand < 8)
				{
					st_map.nBCR_State[2] = BCR_READ_GOOD_;
				}
				else
				{
					st_map.nBCR_State[2] = BCR_READ_BAD_;
				}
			}
			else
			{
				if (st_work.sRbtBCR_Data[2] == st_work.m_sAccyMathCode)
				{
					st_map.nBCR_State[2] = BCR_READ_GOOD_;
				}
				else
				{
					st_map.nBCR_State[2] = BCR_READ_BAD_;
				}
			}
			if (st_handler.cwnd_main != NULL)
			{
				// 바코드 상태 표시 초기화 요청
				st_handler.cwnd_main->PostMessage(WM_UPDATE_MAIN, READ_BCR_DATA);
			}
			m_nStep_ReadMove = 1000;
		}
		break;

	case 1000:
		if (st_map.nBCR_State[0] == BCR_READ_BAD_ && 
			st_map.nBCR_State[1] == BCR_READ_BAD_ && 
			st_map.nBCR_State[2] == BCR_READ_BAD_ && 
			st_map.nBCR_State[3] == BCR_READ_BAD_)
		{
			if (m_nBCRReadAllBadCount >= 2)
			{
				m_nBCRReadAllBadCount = 0;
				m_nStep_ReadMove = 0;
				st_work.nForceDischarge = FORCEDISCHARGE_ON;
				Func.OnSet_EqpStatusStop();
			}
			else
			{
				m_nBCRReadAllBadCount++;
				m_nStep_ReadMove = 2000;
			}
		}
		else
		{
			m_nBCRReadAllBadCount = 0;
			m_nStep_ReadMove = 2000;
		}
		break;

	case 2000:
		nFuncRet = CTL_GOOD;
		m_nStep_ReadMove = 0;
		break;
	}
	return nFuncRet;
}

//////////////////////////////////////////////////////////////////////////
// BCR Read 함수
// nzMode = 0 이면 왼쪽으로 이동하여 BCR Read
// nzMode = 1 이면 오른쪽으로 이동하여 BCR Read
//////////////////////////////////////////////////////////////////////////
int CSeq_XYZRobot::OnBCRRead(int nzMode)
{
	Func.OnTrace_ThreadStep(14, m_nStep_BCRRead);	// 쓰레드 스텝 정보 TRACE
	int nFuncRet = -1;

	int nRet = VAR_INIT_;
	int nRetData[4] = {0,};
	double dOffset;

	switch(m_nStep_BCRRead)
	{
		// KILEE [2015.03.23]
	case 0:
		nRet = CTL_Lib.OnSingleMove(m_nMotZ, st_motor[m_nMotZ].d_pos[Z_RBT_SAFETY_], (int)st_handler.md_run_speed);
		if (nRet == CTLBD_RET_GOOD)
		{
			m_nStep_BCRRead = 50;
		}
		else if (nRet == CTLBD_RET_ERROR || nRet == CTLBD_RET_RETRY)
		{
			// 071005 0 0 "BARCODE_ROBOT_Z_RBT_SAFETY_MOVE_ERR"
			alarm.mstr_code		= "071005";
			alarm.mn_count_mode	= 0;
			alarm.mn_type_mode	= eWARNING;
			st_work.nEqpStatus	= dWARNING;
		}
		break;

		// KILEE [2015.03.23]
	//case 0:
	case 50:
		// X_RBT_ACC_BCR_ 위치에 d_X_Gripper_Size를 nzMode만큼을 곱한 위치로 이동함.
		// nzMode(SIDE_LEFT = 0, SIDE_RIGHT = 1)
		m_dTargetPos = st_motor[m_nMotX].d_pos[X_RBT_ACC_BCR_] + (st_accy.d_X_Gripper_Size * nzMode);
		nRet = CTL_Lib.OnSingleMove(m_nMotX, m_dTargetPos, (int)st_handler.md_run_speed);
		if (nRet == CTLBD_RET_GOOD)
		{
			// 자재가 없는 경우 이므로 BCR을 Read를 수행 하지 않고 완료 Step으로 이동
			if (st_basic.n_mode_device == WITHOUT_DVC_)
			{
				m_nStep_BCRRead = 5000;
				break;
			}
			m_nStep_BCRRead = 100;
		}
		else if (nRet == CTLBD_RET_ERROR || nRet == CTLBD_RET_RETRY)
		{
			// 061000 0 00 "BARCODE_ROBOT_X_RBT_ACC_BCR_POS_MOVE_ERR."
			alarm.mstr_code = "061000";
			alarm.mn_count_mode	= 0;
			alarm.mn_type_mode	= eWARNING;
			st_work.nEqpStatus	= dWARNING;
		}
		break;

	case 100:
		m_nResp_Move = CTL_NO;
		// BCR 읽기 실패 시 [상/하] 이동하여 BCR 읽기 작업 진행함
		// - 이 때 사용할 변수 리셋
		m_nNearby = -1;
		m_nRetryCount = 0;	// [리셋] 통신 시도 횟수 정보

		m_nStep_BCRRead = 110;
		break;

	case 110:
		if (m_nResp_Move == CTL_NO)
		{
			// 바코드 읽기 요청
     		evBCR.OnReq_ACCY();
		}
		m_nStep_BCRRead = 120;
		break;
	
	case 120:
		if (m_nResp_Move == CTL_NO)
		{
			nRet = evBCR.OnGet_ACCY();
		}
		else
		{
			nRet = REPLY_CORRECT_;
		}

		if (nRet == REPLY_CORRECT_)
		{
			m_nResp_Move = CTL_YES;
		}

		if (m_nResp_Move == CTL_YES)
		{
			m_nResp_Move = CTL_NO;
			// 완료 Step 이동
			m_nStep_BCRRead = 5000;
		}
		else if (nRet == REPLY_ERROR_)
		{
			// BCR 읽기 작업 시도 횟수 검사
			if (m_nRetryCount > st_basic.nInspectRetry)
			{
				m_nStep_BCRRead = 200;
			}
			else
			{
				m_nRetryCount++;
				m_nStep_BCRRead = 110;
			}
		}
		break;

	case 200:
		// [티칭 위치]->[좌측]->[우측] 순으로 BCR 읽기 재시도
		if (m_nNearby == -1)
		{
			m_nRetryCount = 0;	// [리셋] 통신 시도

			// 초기에는 하단 위치로 옵셋만큼 이동 후 BCR 읽기 작업
			m_nNearby = SIDE_LEFT_;
			m_nStep_BCRRead = 300;
		}
		else if (m_nNearby == SIDE_LEFT_)
		{
			m_nRetryCount = 0;	// [리셋] 통신 시도

			// 하단 위치 시도 완료
			// 상단 위치 시도함
			m_nNearby = SIDE_RIGHT_;
			m_nStep_BCRRead = 300;
		}
		else
		{
			m_nStep_BCRRead = 5000;
		}
		break;

	case 300:
		// BCR Read Retry 시 m_dPos_Target은 X_RBT_ACC_BCR_값에 d_X_Gripper_Size * nzMode를 곱한 값을 더한 위치이다.
		// nzMode(SIDE_LEFT=0, SIDE_RIGHT=1)
		m_dPos_Target[0] = st_motor[m_nMotX].d_pos[X_RBT_ACC_BCR_] + (st_accy.d_X_Gripper_Size * nzMode);
		dOffset = st_motor[m_nMotX].d_pos[X_RBT_ACC_BCR_OFFSET_];

		if (m_nNearby == SIDE_LEFT_)
		{
			// [OFFSET] 범위를 [5mm] 이내로 제한
			if (dOffset > 5)
			{
				dOffset = 1;
			}
			// Y축 모터를 하단으로 이동할 위치 정보 설정
			m_dPos_Target[0] += dOffset;
		}
		else if (m_nNearby == SIDE_RIGHT_)
		{
			if (dOffset > 5)
			{
				dOffset = 1;
			}
			// Y축 모터를 상단으로 이동할 위치 정보 설정
			m_dPos_Target[0] -= dOffset;
		}
		m_nStep_BCRRead = 310;
		break;

	case 310:
		// Y축을 Offset 만큼 이동
		nRet = CTL_Lib.OnSingleMove(m_nMotX, m_dPos_Target[0], (int)st_handler.md_run_speed);
		if (nRet == CTLBD_RET_GOOD)
		{
			m_nStep_BCRRead = 110;
		}
		else if (nRet == CTLBD_RET_ERROR || nRet == CTLBD_RET_RETRY)
		{
			// 069001 0 00 "BARCODE_ROBOT_X_RBT_ACC_BCR_RETRY_OFFSET_MOVE_ERR."
			alarm.mstr_code		= "069001";
			alarm.mn_count_mode	= 0;
			alarm.mn_type_mode	= eWARNING;
			st_work.nEqpStatus	= dWARNING;
		}
		break;

	case 5000:
		nFuncRet = CTL_GOOD;
		m_nStep_BCRRead = 0;
		break;
	}
	return nFuncRet;
}

//////////////////////////////////////////////////////////////////////////
//  Grip Motor 제어 함수
//  nzSite : 동작을 수행할 Gripper 값
//  nzOnOff = ON : Grip 상태가 된다
//  nzOnOff = OFF : Open 상태가 된다
//////////////////////////////////////////////////////////////////////////
// 규이리 수정 [2015.02.25]
int CSeq_XYZRobot::OnProc_Grip(int nzSite, int nzOnOff) 
{
	int nFuncRet = CTL_PROCEED;

	int nRetData[4] = {0,};
	int nRet = 0;
	// 규이리 추가 [2015.02.25]
	int i;
	
	switch(m_nStep_Grip)
	{
	case 0:
		for(i=0; i<4; i++)
		{
			m_nResp_Grip[i] = CTL_NO;
		}
		// kilee [2015.02.28]
		m_nStep_Grip = 500;
		break;

	case 500:
		if (nzSite == 0)
		{
			nRetData[0] = CTLBD_RET_GOOD;
			nRetData[1] = CTLBD_RET_GOOD;
			nRetData[2] = CTLBD_RET_GOOD;
			nRetData[3] = CTLBD_RET_GOOD;
		}
		else if (nzSite == 1)
		{
			nRetData[0] = COMI.Start_SingleMove(m_nMotGrip1, st_motor[m_nMotGrip1].d_pos[nzOnOff], (int)st_handler.md_run_speed);
			nRetData[1] = CTLBD_RET_GOOD;
			nRetData[2] = CTLBD_RET_GOOD;
			nRetData[3] = CTLBD_RET_GOOD;
		}
		else if (nzSite == 2)
		{
			nRetData[0] = CTLBD_RET_GOOD;
			nRetData[1] = COMI.Start_SingleMove(m_nMotGrip2, st_motor[m_nMotGrip2].d_pos[nzOnOff], (int)st_handler.md_run_speed);
			nRetData[2] = CTLBD_RET_GOOD;
			nRetData[3] = CTLBD_RET_GOOD;
		}
		else if (nzSite == 3)
		{
			nRetData[0] = COMI.Start_SingleMove(m_nMotGrip1, st_motor[m_nMotGrip1].d_pos[nzOnOff], (int)st_handler.md_run_speed);
			nRetData[1] = COMI.Start_SingleMove(m_nMotGrip2, st_motor[m_nMotGrip2].d_pos[nzOnOff], (int)st_handler.md_run_speed);
			nRetData[2] = CTLBD_RET_GOOD;
			nRetData[3] = CTLBD_RET_GOOD;
		}
		else if (nzSite == 4)
		{
			nRetData[0] = CTLBD_RET_GOOD;
			nRetData[1] = CTLBD_RET_GOOD;
			nRetData[2] = COMI.Start_SingleMove(m_nMotGrip3, st_motor[m_nMotGrip3].d_pos[nzOnOff], (int)st_handler.md_run_speed);
			nRetData[3] = CTLBD_RET_GOOD;
		}
		else if (nzSite == 5)
		{
			nRetData[0] = COMI.Start_SingleMove(m_nMotGrip1, st_motor[m_nMotGrip1].d_pos[nzOnOff], (int)st_handler.md_run_speed);
			nRetData[1] = CTLBD_RET_GOOD;
			nRetData[2] = COMI.Start_SingleMove(m_nMotGrip3, st_motor[m_nMotGrip3].d_pos[nzOnOff], (int)st_handler.md_run_speed);
			nRetData[3] = CTLBD_RET_GOOD;
		}
		else if (nzSite == 6)
		{
			nRetData[0] = CTLBD_RET_GOOD;
			nRetData[1] = COMI.Start_SingleMove(m_nMotGrip2, st_motor[m_nMotGrip2].d_pos[nzOnOff], (int)st_handler.md_run_speed);
			nRetData[2] = COMI.Start_SingleMove(m_nMotGrip3, st_motor[m_nMotGrip3].d_pos[nzOnOff], (int)st_handler.md_run_speed);
			nRetData[3] = CTLBD_RET_GOOD;
		}
		else if (nzSite == 7)
		{
			nRetData[0] = COMI.Start_SingleMove(m_nMotGrip1, st_motor[m_nMotGrip1].d_pos[nzOnOff], (int)st_handler.md_run_speed);
			nRetData[1] = COMI.Start_SingleMove(m_nMotGrip2, st_motor[m_nMotGrip2].d_pos[nzOnOff], (int)st_handler.md_run_speed);
			nRetData[2] = COMI.Start_SingleMove(m_nMotGrip3, st_motor[m_nMotGrip3].d_pos[nzOnOff], (int)st_handler.md_run_speed);
			nRetData[3] = CTLBD_RET_GOOD;
		}
		else if (nzSite == 8)
		{
			nRetData[0] = CTLBD_RET_GOOD;
			nRetData[1] = CTLBD_RET_GOOD;
			nRetData[2] = CTLBD_RET_GOOD;
			nRetData[3] = COMI.Start_SingleMove(m_nMotGrip4, st_motor[m_nMotGrip4].d_pos[nzOnOff], (int)st_handler.md_run_speed);
		}
		else if (nzSite == 9)
		{
			nRetData[0] = COMI.Start_SingleMove(m_nMotGrip1, st_motor[m_nMotGrip1].d_pos[nzOnOff], (int)st_handler.md_run_speed);
			nRetData[1] = CTLBD_RET_GOOD;
			nRetData[2] = CTLBD_RET_GOOD;
			nRetData[3] = COMI.Start_SingleMove(m_nMotGrip4, st_motor[m_nMotGrip4].d_pos[nzOnOff], (int)st_handler.md_run_speed);
		}
		else if (nzSite == 10)
		{
			nRetData[0] = CTLBD_RET_GOOD;
			nRetData[1] = COMI.Start_SingleMove(m_nMotGrip2, st_motor[m_nMotGrip2].d_pos[nzOnOff], (int)st_handler.md_run_speed);
			nRetData[2] = CTLBD_RET_GOOD;
			nRetData[3] = COMI.Start_SingleMove(m_nMotGrip4, st_motor[m_nMotGrip4].d_pos[nzOnOff], (int)st_handler.md_run_speed);
		}
		else if (nzSite == 11)
		{
			nRetData[0] = COMI.Start_SingleMove(m_nMotGrip1, st_motor[m_nMotGrip1].d_pos[nzOnOff], (int)st_handler.md_run_speed);
			nRetData[1] = COMI.Start_SingleMove(m_nMotGrip2, st_motor[m_nMotGrip2].d_pos[nzOnOff], (int)st_handler.md_run_speed);
			nRetData[2] = CTLBD_RET_GOOD;
			nRetData[3] = COMI.Start_SingleMove(m_nMotGrip4, st_motor[m_nMotGrip4].d_pos[nzOnOff], (int)st_handler.md_run_speed);
		}
		else if (nzSite == 12)
		{
			nRetData[0] = CTLBD_RET_GOOD;
			nRetData[1] = CTLBD_RET_GOOD;
			nRetData[2] = COMI.Start_SingleMove(m_nMotGrip3, st_motor[m_nMotGrip3].d_pos[nzOnOff], (int)st_handler.md_run_speed);
			nRetData[3] = COMI.Start_SingleMove(m_nMotGrip4, st_motor[m_nMotGrip4].d_pos[nzOnOff], (int)st_handler.md_run_speed);
		}
		else if (nzSite == 13)
		{
			nRetData[0] = COMI.Start_SingleMove(m_nMotGrip1, st_motor[m_nMotGrip1].d_pos[nzOnOff], (int)st_handler.md_run_speed);
			nRetData[1] = CTLBD_RET_GOOD;
			nRetData[2] = COMI.Start_SingleMove(m_nMotGrip3, st_motor[m_nMotGrip3].d_pos[nzOnOff], (int)st_handler.md_run_speed);
			nRetData[3] = COMI.Start_SingleMove(m_nMotGrip4, st_motor[m_nMotGrip4].d_pos[nzOnOff], (int)st_handler.md_run_speed);
		}
		else if (nzSite == 14)
		{
			nRetData[0] = CTLBD_RET_GOOD;
			nRetData[1] = COMI.Start_SingleMove(m_nMotGrip2, st_motor[m_nMotGrip2].d_pos[nzOnOff], (int)st_handler.md_run_speed);
			nRetData[2] = COMI.Start_SingleMove(m_nMotGrip3, st_motor[m_nMotGrip3].d_pos[nzOnOff], (int)st_handler.md_run_speed);
			nRetData[3] = COMI.Start_SingleMove(m_nMotGrip4, st_motor[m_nMotGrip4].d_pos[nzOnOff], (int)st_handler.md_run_speed);
		}
		else if (nzSite == 15)
		{
			nRetData[0] = COMI.Start_SingleMove(m_nMotGrip1, st_motor[m_nMotGrip1].d_pos[nzOnOff], (int)st_handler.md_run_speed);
			nRetData[1] = COMI.Start_SingleMove(m_nMotGrip2, st_motor[m_nMotGrip2].d_pos[nzOnOff], (int)st_handler.md_run_speed);
			nRetData[2] = COMI.Start_SingleMove(m_nMotGrip3, st_motor[m_nMotGrip3].d_pos[nzOnOff], (int)st_handler.md_run_speed);
			nRetData[3] = COMI.Start_SingleMove(m_nMotGrip4, st_motor[m_nMotGrip4].d_pos[nzOnOff], (int)st_handler.md_run_speed);
		}
		else
		{
			m_nStep_Grip = 0;
			nFuncRet = CTL_ERROR;
			break;
		}

		if (nRetData[0] == CTLBD_RET_GOOD)
		{
			m_nResp_Grip[0] = CTL_YES;
		}
		if (nRetData[1] == CTLBD_RET_GOOD)
		{
			m_nResp_Grip[1] = CTL_YES;
		}
		if (nRetData[2] == CTLBD_RET_GOOD)
		{
			m_nResp_Grip[2] = CTL_YES;
		}
		if (nRetData[3] == CTLBD_RET_GOOD)
		{
			m_nResp_Grip[3] = CTL_YES;
		}

		if (m_nResp_Grip[0] == CTL_YES &&
			m_nResp_Grip[1] == CTL_YES &&
			m_nResp_Grip[2] == CTL_YES &&
			m_nResp_Grip[3] == CTL_YES)
		{
			for(i=0; i<4; i++)
			{
				m_nResp_Grip[i] = CTL_NO;
			}
			m_nStep_Grip = 520;
		}
		else if (nRetData[0] == CTLBD_RET_RETRY ||
			nRetData[1] == CTLBD_RET_RETRY ||
			nRetData[2] == CTLBD_RET_RETRY ||
			nRetData[3] == CTLBD_RET_RETRY)
		{
			m_nStep_Grip = 0;
		}
		else if (nRetData[0] != CTLBD_RET_PROCEED && nRetData[0] != CTLBD_RET_GOOD)
		{
			m_nStep_Grip = 0;
			
			// 081000 0 08 "ROBOT_GRIP_1_GRIP_RBT_OPEN_MOVE_ERR."
			// 081001 0 08 "ROBOT_GRIP_1_GRIP_RBT_GRIPPER_MOVE_ERR."
			alarm.mstr_code.Format("08100%d", nzOnOff);
			alarm.mn_count_mode	= 0;
			alarm.mn_type_mode	= eWARNING;
			st_work.nEqpStatus	= dWARNING;
		}
		else if (nRetData[1] != CTLBD_RET_PROCEED && nRetData[1] != CTLBD_RET_GOOD)
		{
			m_nStep_Grip = 0;
			
			// 091000 0 09 "ROBOT_GRIP_2_GRIP_RBT_OPEN_MOVE_ERR."
			// 091001 0 09 "ROBOT_GRIP_2_GRIP_RBT_GRIPPER_MOVE_ERR."
			alarm.mstr_code.Format("09100%d", nzOnOff);
			alarm.mn_count_mode	= 0;
			alarm.mn_type_mode	= eWARNING;
			st_work.nEqpStatus	= dWARNING;
		}
		else if (nRetData[2] != CTLBD_RET_PROCEED && nRetData[2] != CTLBD_RET_GOOD)
		{
			m_nStep_Grip = 0;
			
			// 101000 0 10 "ROBOT_GRIP_3_GRIP_RBT_OPEN_MOVE_ERR."
			// 101001 0 10 "ROBOT_GRIP_3_GRIP_RBT_GRIPPER_MOVE_ERR."
			alarm.mstr_code.Format("10100%d", nzOnOff);
			alarm.mn_count_mode	= 0;
			alarm.mn_type_mode	= eWARNING;
			st_work.nEqpStatus	= dWARNING;
		}
		else if (nRetData[3] != CTLBD_RET_PROCEED && nRetData[3] != CTLBD_RET_GOOD)
		{
			m_nStep_Grip = 0;
			
			// 111000 0 11 "ROBOT_GRIP_4_GRIP_RBT_OPEN_MOVE_ERR."
			// 111001 0 11 "ROBOT_GRIP_4_GRIP_RBT_GRIPPER_MOVE_ERR."
			alarm.mstr_code.Format("11100%d", nzOnOff);
			alarm.mn_count_mode	= 0;
			alarm.mn_type_mode	= eWARNING;
			st_work.nEqpStatus	= dWARNING;
		}
		break;

	case 520:
		if (nzSite == 0)
		{
			nRetData[0] = CTLBD_RET_GOOD;
			nRetData[1] = CTLBD_RET_GOOD;
			nRetData[2] = CTLBD_RET_GOOD;
			nRetData[3] = CTLBD_RET_GOOD;
		}
		else if (nzSite == 1)
		{
			nRetData[0] = COMI.Check_SingleMove(m_nMotGrip1, st_motor[m_nMotGrip1].d_pos[nzOnOff]);
			nRetData[1] = CTLBD_RET_GOOD;
			nRetData[2] = CTLBD_RET_GOOD;
			nRetData[3] = CTLBD_RET_GOOD;
		}
		else if (nzSite == 2)
		{
			nRetData[0] = CTLBD_RET_GOOD;
			nRetData[1] = COMI.Check_SingleMove(m_nMotGrip2, st_motor[m_nMotGrip2].d_pos[nzOnOff]);
			nRetData[2] = CTLBD_RET_GOOD;
			nRetData[3] = CTLBD_RET_GOOD;
		}
		else if (nzSite == 3)
		{
			nRetData[0] = COMI.Check_SingleMove(m_nMotGrip1, st_motor[m_nMotGrip1].d_pos[nzOnOff]);
			nRetData[1] = COMI.Check_SingleMove(m_nMotGrip2, st_motor[m_nMotGrip2].d_pos[nzOnOff]);
			nRetData[2] = CTLBD_RET_GOOD;
			nRetData[3] = CTLBD_RET_GOOD;
		}
		else if (nzSite == 4)
		{
			nRetData[0] = CTLBD_RET_GOOD;
			nRetData[1] = CTLBD_RET_GOOD;
			nRetData[2] = COMI.Check_SingleMove(m_nMotGrip3, st_motor[m_nMotGrip3].d_pos[nzOnOff]);
			nRetData[3] = CTLBD_RET_GOOD;
		}
		else if (nzSite == 5)
		{
			nRetData[0] = COMI.Check_SingleMove(m_nMotGrip1, st_motor[m_nMotGrip1].d_pos[nzOnOff]);
			nRetData[1] = CTLBD_RET_GOOD;
			nRetData[2] = COMI.Check_SingleMove(m_nMotGrip3, st_motor[m_nMotGrip3].d_pos[nzOnOff]);
			nRetData[3] = CTLBD_RET_GOOD;
		}
		else if (nzSite == 6)
		{
			nRetData[0] = CTLBD_RET_GOOD;
			nRetData[1] = COMI.Check_SingleMove(m_nMotGrip2, st_motor[m_nMotGrip2].d_pos[nzOnOff]);
			nRetData[2] = COMI.Check_SingleMove(m_nMotGrip3, st_motor[m_nMotGrip3].d_pos[nzOnOff]);
			nRetData[3] = CTLBD_RET_GOOD;
		}
		else if (nzSite == 7)
		{
			nRetData[0] = COMI.Check_SingleMove(m_nMotGrip1, st_motor[m_nMotGrip1].d_pos[nzOnOff]);
			nRetData[1] = COMI.Check_SingleMove(m_nMotGrip2, st_motor[m_nMotGrip2].d_pos[nzOnOff]);
			nRetData[2] = COMI.Check_SingleMove(m_nMotGrip3, st_motor[m_nMotGrip3].d_pos[nzOnOff]);
			nRetData[3] = CTLBD_RET_GOOD;
		}
		else if (nzSite == 8)
		{
			nRetData[0] = CTLBD_RET_GOOD;
			nRetData[1] = CTLBD_RET_GOOD;
			nRetData[2] = CTLBD_RET_GOOD;
			nRetData[3] = COMI.Check_SingleMove(m_nMotGrip4, st_motor[m_nMotGrip4].d_pos[nzOnOff]);
		}
		else if (nzSite == 9)
		{
			nRetData[0] = COMI.Check_SingleMove(m_nMotGrip1, st_motor[m_nMotGrip1].d_pos[nzOnOff]);
			nRetData[1] = CTLBD_RET_GOOD;
			nRetData[2] = CTLBD_RET_GOOD;
			nRetData[3] = COMI.Check_SingleMove(m_nMotGrip4, st_motor[m_nMotGrip4].d_pos[nzOnOff]);
		}
		else if (nzSite == 10)
		{
			nRetData[0] = CTLBD_RET_GOOD;
			nRetData[1] = COMI.Check_SingleMove(m_nMotGrip2, st_motor[m_nMotGrip2].d_pos[nzOnOff]);
			nRetData[2] = CTLBD_RET_GOOD;
			nRetData[3] = COMI.Check_SingleMove(m_nMotGrip4, st_motor[m_nMotGrip4].d_pos[nzOnOff]);
		}
		else if (nzSite == 11)
		{
			nRetData[0] = COMI.Check_SingleMove(m_nMotGrip1, st_motor[m_nMotGrip1].d_pos[nzOnOff]);
			nRetData[1] = COMI.Check_SingleMove(m_nMotGrip2, st_motor[m_nMotGrip2].d_pos[nzOnOff]);
			nRetData[2] = CTLBD_RET_GOOD;
			nRetData[3] = COMI.Check_SingleMove(m_nMotGrip4, st_motor[m_nMotGrip4].d_pos[nzOnOff]);
		}
		else if (nzSite == 12)
		{
			nRetData[0] = CTLBD_RET_GOOD;
			nRetData[1] = CTLBD_RET_GOOD;
			nRetData[2] = COMI.Check_SingleMove(m_nMotGrip3, st_motor[m_nMotGrip3].d_pos[nzOnOff]);
			nRetData[3] = COMI.Check_SingleMove(m_nMotGrip4, st_motor[m_nMotGrip4].d_pos[nzOnOff]);
		}
		else if (nzSite == 13)
		{
			nRetData[0] = COMI.Check_SingleMove(m_nMotGrip1, st_motor[m_nMotGrip1].d_pos[nzOnOff]);
			nRetData[1] = CTLBD_RET_GOOD;
			nRetData[2] = COMI.Check_SingleMove(m_nMotGrip3, st_motor[m_nMotGrip3].d_pos[nzOnOff]);
			nRetData[3] = COMI.Check_SingleMove(m_nMotGrip4, st_motor[m_nMotGrip4].d_pos[nzOnOff]);
		}
		else if (nzSite == 14)
		{
			nRetData[0] = CTLBD_RET_GOOD;
			nRetData[1] = COMI.Check_SingleMove(m_nMotGrip2, st_motor[m_nMotGrip2].d_pos[nzOnOff]);
			nRetData[2] = COMI.Check_SingleMove(m_nMotGrip3, st_motor[m_nMotGrip3].d_pos[nzOnOff]);
			nRetData[3] = COMI.Check_SingleMove(m_nMotGrip4, st_motor[m_nMotGrip4].d_pos[nzOnOff]);
		}
		else if (nzSite == 15)
		{
			nRetData[0] = COMI.Check_SingleMove(m_nMotGrip1, st_motor[m_nMotGrip1].d_pos[nzOnOff]);
			nRetData[1] = COMI.Check_SingleMove(m_nMotGrip2, st_motor[m_nMotGrip2].d_pos[nzOnOff]);
			nRetData[2] = COMI.Check_SingleMove(m_nMotGrip3, st_motor[m_nMotGrip3].d_pos[nzOnOff]);
			nRetData[3] = COMI.Check_SingleMove(m_nMotGrip4, st_motor[m_nMotGrip4].d_pos[nzOnOff]);
		}

		if (nRetData[0] == CTLBD_RET_GOOD)
		{
			m_nResp_Grip[0] = CTL_YES;
		}
		if (nRetData[1] == CTLBD_RET_GOOD)
		{
			m_nResp_Grip[1] = CTL_YES;
		}
		if (nRetData[2] == CTLBD_RET_GOOD)
		{
			m_nResp_Grip[2] = CTL_YES;
		}
		if (nRetData[3] == CTLBD_RET_GOOD)
		{
			m_nResp_Grip[3] = CTL_YES;
		}
		
		if (m_nResp_Grip[0] == CTL_YES &&
			m_nResp_Grip[1] == CTL_YES &&
			m_nResp_Grip[2] == CTL_YES &&
			m_nResp_Grip[3] == CTL_YES)
		{
			for(i=0; i<4; i++)
			{
				m_nResp_Grip[i] = CTL_NO;
			}
			m_nStep_Grip = 1000;
		}
		else if (nRetData[0] == CTLBD_RET_RETRY ||
			nRetData[1] == CTLBD_RET_RETRY ||
			nRetData[2] == CTLBD_RET_RETRY ||
			nRetData[3] == CTLBD_RET_RETRY)
		{
			m_nStep_Grip = 500;
		}

		else if (nRetData[0] != CTLBD_RET_PROCEED && nRetData[0] != CTLBD_RET_GOOD)
		{
			m_nStep_Grip = 500;
			
			// 081000 0 08 "ROBOT_GRIP_1_GRIP_RBT_OPEN_MOVE_ERR."
			// 081001 0 08 "ROBOT_GRIP_1_GRIP_RBT_GRIPPER_MOVE_ERR."
			alarm.mstr_code.Format("08100%d", nzOnOff);
			alarm.mn_count_mode	= 0;
			alarm.mn_type_mode	= eWARNING;
			st_work.nEqpStatus	= dWARNING;
		}
		else if (nRetData[1] != CTLBD_RET_PROCEED && nRetData[1] != CTLBD_RET_GOOD)
		{
			m_nStep_Grip = 500;
			
			// 091000 0 09 "ROBOT_GRIP_2_GRIP_RBT_OPEN_MOVE_ERR."
			// 091001 0 09 "ROBOT_GRIP_2_GRIP_RBT_GRIPPER_MOVE_ERR."
			alarm.mstr_code.Format("09100%d", nzOnOff);
			alarm.mn_count_mode	= 0;
			alarm.mn_type_mode	= eWARNING;
			st_work.nEqpStatus	= dWARNING;
		}
		else if (nRetData[2] != CTLBD_RET_PROCEED && nRetData[2] != CTLBD_RET_GOOD)
		{
			m_nStep_Grip = 500;

			// 101000 0 10 "ROBOT_GRIP_3_GRIP_RBT_OPEN_MOVE_ERR."
			// 101001 0 10 "ROBOT_GRIP_3_GRIP_RBT_GRIPPER_MOVE_ERR."
			alarm.mstr_code.Format("10100%d", nzOnOff);
			alarm.mn_count_mode	= 0;
			alarm.mn_type_mode	= eWARNING;
			st_work.nEqpStatus	= dWARNING;
		}
		else if (nRetData[3] != CTLBD_RET_PROCEED && nRetData[3] != CTLBD_RET_GOOD)
		{
			m_nStep_Grip = 500;

			// 111000 0 11 "ROBOT_GRIP_4_GRIP_RBT_OPEN_MOVE_ERR."
			// 111001 0 11 "ROBOT_GRIP_4_GRIP_RBT_GRIPPER_MOVE_ERR."
			alarm.mstr_code.Format("11100%d", nzOnOff);
			alarm.mn_count_mode	= 0;
			alarm.mn_type_mode	= eWARNING;
			st_work.nEqpStatus	= dWARNING;
		}
		break;

	case 1000:
		// 그립퍼에는 별도의 센서가 없어 자재가 존재하는지 여부를 확인할 수 없음
		// - 집는 동작이면 자재 존재한다고 설정, 내려놓는 동작이면 자재 없다고 설정
		// - 버퍼 영역에서 자재 내려놓으 후 자재 존재 여부 확인해야 함
		if (nzSite == 1)
		{
			st_map.nXYZRbtPickerInfo[0] = nzOnOff;
		}
		else if (nzSite == 2)
		{
			st_map.nXYZRbtPickerInfo[1] = nzOnOff;
		}
		else if (nzSite == 3)
		{
			st_map.nXYZRbtPickerInfo[0] = nzOnOff;
			st_map.nXYZRbtPickerInfo[1] = nzOnOff;
		}
		else if (nzSite == 4)
		{
			st_map.nXYZRbtPickerInfo[2] = nzOnOff;
		}
		else if (nzSite == 5)
		{
			st_map.nXYZRbtPickerInfo[0] = nzOnOff;
			st_map.nXYZRbtPickerInfo[2] = nzOnOff;
		}
		else if (nzSite == 6)
		{
			st_map.nXYZRbtPickerInfo[1] = nzOnOff;
			st_map.nXYZRbtPickerInfo[2] = nzOnOff;
		}
		else if (nzSite == 7)
		{
			st_map.nXYZRbtPickerInfo[0] = nzOnOff;
			st_map.nXYZRbtPickerInfo[1] = nzOnOff;
			st_map.nXYZRbtPickerInfo[2] = nzOnOff;
		}
		else if (nzSite == 8)
		{
			st_map.nXYZRbtPickerInfo[3] = nzOnOff;
		}
		else if (nzSite == 9)
		{
			st_map.nXYZRbtPickerInfo[0] = nzOnOff;
			st_map.nXYZRbtPickerInfo[3] = nzOnOff;
		}
		else if (nzSite == 10)
		{
			st_map.nXYZRbtPickerInfo[1] = nzOnOff;
			st_map.nXYZRbtPickerInfo[3] = nzOnOff;
		}
		else if (nzSite == 11)
		{
			st_map.nXYZRbtPickerInfo[0] = nzOnOff;
			st_map.nXYZRbtPickerInfo[1] = nzOnOff;
			st_map.nXYZRbtPickerInfo[3] = nzOnOff;
		}
		else if (nzSite == 12)
		{
			st_map.nXYZRbtPickerInfo[2] = nzOnOff;
			st_map.nXYZRbtPickerInfo[3] = nzOnOff;
		}
		else if (nzSite == 13)
		{
			st_map.nXYZRbtPickerInfo[0] = nzOnOff;
			st_map.nXYZRbtPickerInfo[2] = nzOnOff;
			st_map.nXYZRbtPickerInfo[3] = nzOnOff;
		}
		else if (nzSite == 14)
		{
			st_map.nXYZRbtPickerInfo[1] = nzOnOff;
			st_map.nXYZRbtPickerInfo[2] = nzOnOff;
			st_map.nXYZRbtPickerInfo[3] = nzOnOff;
		}
		else if (nzSite == 15)
		{
			st_map.nXYZRbtPickerInfo[0] = nzOnOff;
			st_map.nXYZRbtPickerInfo[1] = nzOnOff;
			st_map.nXYZRbtPickerInfo[2] = nzOnOff;
			st_map.nXYZRbtPickerInfo[3] = nzOnOff;
		}
		nFuncRet = CTL_GOOD;
		m_nStep_Grip = 0;
		break;
	}
	return nFuncRet;
}

int CSeq_XYZRobot::OnRcvy_RobotPos()
{
	int nFuncRet = CTL_PROCEED;
	
	int nRet[7], nResp;
	int i, nRcvyCount;

	switch(m_nStep_Rcvy)
	{
	case 0:
		nRet[0] = COMI.Check_MotPosRange(m_nMotZ, COMI.md_cmdpos_backup[m_nMotZ], st_motor[m_nMotZ].mn_allow);
		nRet[1] = COMI.Check_MotPosRange(m_nMotX, COMI.md_cmdpos_backup[m_nMotX], st_motor[m_nMotX].mn_allow);
		nRet[2] = COMI.Check_MotPosRange(m_nMotY, COMI.md_cmdpos_backup[m_nMotY], st_motor[m_nMotY].mn_allow);
		nRet[3] = COMI.Check_MotPosRange(m_nMotGrip1, COMI.md_cmdpos_backup[m_nMotGrip1], st_motor[m_nMotGrip1].mn_allow);
		nRet[4] = COMI.Check_MotPosRange(m_nMotGrip2, COMI.md_cmdpos_backup[m_nMotGrip2], st_motor[m_nMotGrip2].mn_allow);
		nRet[5] = COMI.Check_MotPosRange(m_nMotGrip3, COMI.md_cmdpos_backup[m_nMotGrip3], st_motor[m_nMotGrip3].mn_allow);
		nRet[6] = COMI.Check_MotPosRange(m_nMotGrip4, COMI.md_cmdpos_backup[m_nMotGrip4], st_motor[m_nMotGrip4].mn_allow);

		nRcvyCount = 0;	// [리셋] 복구할 모터 갯수 정보
		for(i=0; i<3; i++)
		{
			m_nReq_Rcvy[i] = CTL_NO;
			// 모터 위치가 변경됨 [복구 동작 필요]
			if (nRet[i] == BD_ERROR)
			{
				m_nReq_Rcvy[i] = CTL_YES;
				nRcvyCount++;
			}
		}

		// 복구 동작 불필요
		if (nRcvyCount == 0)
		{
			m_nStep_Rcvy = 9000;
		}
		// 복구 동작 필요
		else
		{
			// Z축 모터 안전 위치로 우선 이동 [충돌 방지]
			m_dPos_TmpRcvyZ = COMI.md_cmdpos_backup[m_nMotZ];
			m_nStep_Rcvy = 100;
		}
		break;

	case 100:
		// Z축 모터 안전 위치로 이동 [충돌 방지]
		nResp = COMI.Start_SingleMove(m_nMotZ, st_motor[m_nMotZ].d_pos[Z_RBT_SAFETY_], (int)st_handler.md_run_speed);
		if (nResp == CTLBD_RET_GOOD)
		{
			m_nStep_Rcvy = 110;
		}
		else if (nResp == CTLBD_RET_ERROR || nResp == CTLBD_RET_SAFETY)
		{
			// 071005 0 0 "BARCODE_ROBOT_Z_RBT_SAFETY_MOVE_ERR"
			alarm.mstr_code		= "071005";
			alarm.mn_count_mode	= 0;
			alarm.mn_type_mode	= eWARNING;
			st_work.nEqpStatus	= dWARNING;
		}
		break;

	case 110:
		nResp = COMI.Check_SingleMove(m_nMotZ, st_motor[m_nMotZ].d_pos[Z_RBT_SAFETY_]);
		if (nResp == CTLBD_RET_GOOD)
		{
			// 안전 위치로 이동시키기 전 위치로 복구 위치 설정
			COMI.md_cmdpos_backup[m_nMotZ] = m_dPos_TmpRcvyZ;
			m_nStep_Rcvy = 1000;
		}
		else if (nResp == CTLBD_RET_ERROR || nResp == CTLBD_RET_SAFETY)
		{
			m_nStep_Rcvy = 100;

			// 071005 0 0 "BARCODE_ROBOT_Z_RBT_SAFETY_MOVE_ERR"
			alarm.mstr_code		= "071005";
			alarm.mn_count_mode	= 0;
			alarm.mn_type_mode	= eWARNING;
			st_work.nEqpStatus	= dWARNING;
		}
		else if (nResp == CTLBD_RET_RETRY)
		{
			m_nStep_Rcvy = 100;
		}
		break;

	case 1000:
		if (m_nReq_Rcvy[1] == CTL_NO)
		{
			m_nStep_Rcvy = 2000;
			break;
		}
		// X 모터 복구 동작
		nResp = COMI.Start_SingleMove(m_nMotX, COMI.md_cmdpos_backup[m_nMotX], (int)st_handler.md_run_speed);
		if (nResp == CTLBD_RET_GOOD)
		{
			m_nStep_Rcvy = 1010;
		}
		else if (nResp == CTLBD_RET_ERROR || nResp == CTLBD_RET_SAFETY)
		{
			// 060008 0 00 "BARCODE_ROBOT_X_RECOVERY_POS_MOVE_ERR."
			alarm.mstr_code		= "060008";
			alarm.mn_count_mode	= 0;
			alarm.mn_type_mode	= eWARNING;
			st_work.nEqpStatus	= dWARNING;
		}
		break;

	case 1010:
		nResp = COMI.Check_SingleMove(m_nMotX, COMI.md_cmdpos_backup[m_nMotX]);
		if (nResp == CTLBD_RET_GOOD)
		{
			m_nStep_Rcvy = 2000;
		}
		else if (nResp == CTLBD_RET_ERROR || nResp == CTLBD_RET_SAFETY)
		{
			m_nStep_Rcvy = 1000;

			// 060008 0 00 "BARCODE_ROBOT_X_RECOVERY_POS_MOVE_ERR."
			alarm.mstr_code		= "060008";
			alarm.mn_count_mode	= 0;
			alarm.mn_type_mode	= eWARNING;
			st_work.nEqpStatus	= dWARNING;
		}
		else if (nResp == CTLBD_RET_RETRY)
		{
			m_nStep_Rcvy = 1000;
		}
		break;

	case 2000:
		if (m_nReq_Rcvy[2] == CTL_NO)
		{
			m_nStep_Rcvy = 3000;
			break;
		}
		// Y 모터 복구 동작
		nResp = COMI.Start_SingleMove(m_nMotY, COMI.md_cmdpos_backup[m_nMotY], (int)st_handler.md_run_speed);
		if (nResp == CTLBD_RET_GOOD)
		{
			m_nStep_Rcvy = 2010;
		}
		else if (nResp == CTLBD_RET_ERROR || nResp == CTLBD_RET_SAFETY)
		{
			// 050008 0 0 "BARCODE_ROBOT_Y_RECOVERY_POS_MOVE_ERR"
			alarm.mstr_code		= "050008";
			alarm.mn_count_mode	= 0;
			alarm.mn_type_mode	= eWARNING;
			st_work.nEqpStatus	= dWARNING;
		}
		break;

	case 2010:
		nResp = COMI.Check_SingleMove(m_nMotY, COMI.md_cmdpos_backup[m_nMotY]);
		if (nResp == CTLBD_RET_GOOD)
		{
			m_nStep_Rcvy = 3000;
		}
		else if (nResp == CTLBD_RET_ERROR || nResp == CTLBD_RET_SAFETY)
		{
			m_nStep_Rcvy = 2000;

			// 050008 0 0 "BARCODE_ROBOT_Y_RECOVERY_POS_MOVE_ERR"
			alarm.mstr_code		= "050008";
			alarm.mn_count_mode	= 0;
			alarm.mn_type_mode	= eWARNING;
			st_work.nEqpStatus	= dWARNING;
		}
		else if (nResp == CTLBD_RET_RETRY)
		{
			m_nStep_Rcvy = 2000;
		}
		break;

	case 3000:
		if (m_nReq_Rcvy[3] == CTL_NO)
		{
			m_nStep_Rcvy = 4000;
			break;
		}
		nResp = COMI.Start_SingleMove(m_nMotGrip1, COMI.md_cmdpos_backup[m_nMotGrip1], (int)st_handler.md_run_speed);
		if (nResp == CTLBD_RET_GOOD)
		{
			m_nStep_Rcvy = 3010;
		}
		else if (nResp == CTLBD_RET_ERROR || nResp == CTLBD_RET_SAFETY)
		{
			// 080008 0 0 "ROBOT_GRIP_1_RECOVERY_POS_MOVE_ERR"
			alarm.mstr_code		= "080008";
			alarm.mn_count_mode	= 0;
			alarm.mn_type_mode	= eWARNING;
			st_work.nEqpStatus	= dWARNING;
		}
		break;

	case 3010:
		nResp = COMI.Check_SingleMove(m_nMotGrip1, COMI.md_cmdpos_backup[m_nMotGrip1]);
		if (nResp == CTLBD_RET_GOOD)
		{
			m_nStep_Rcvy = 4000;
		}
		else if (nResp == CTLBD_RET_ERROR || nResp == CTLBD_RET_SAFETY)
		{
			m_nStep_Rcvy = 3000;

			// 080008 0 0 "ROBOT_GRIP_1_RECOVERY_POS_MOVE_ERR"
			alarm.mstr_code		= "080008";
			alarm.mn_count_mode	= 0;
			alarm.mn_type_mode	= eWARNING;
			st_work.nEqpStatus	= dWARNING;
		}
		else if (nResp == CTLBD_RET_RETRY)
		{
			m_nStep_Rcvy = 3000;
		}
		break;

	case 4000:
		if (m_nReq_Rcvy[4] == CTL_NO)
		{
			m_nStep_Rcvy = 5000;
			break;
		}
		nResp = COMI.Start_SingleMove(m_nMotGrip2, COMI.md_cmdpos_backup[m_nMotGrip2], (int)st_handler.md_run_speed);
		if (nResp == CTLBD_RET_GOOD)
		{
			m_nStep_Rcvy = 4010;
		}
		else if (nResp == CTLBD_RET_ERROR || nResp == CTLBD_RET_SAFETY)
		{
			// 090008 0 0 "ROBOT_GRIP_2_RECOVERY_POS_MOVE_ERR"
			alarm.mstr_code		= "090008";
			alarm.mn_count_mode	= 0;
			alarm.mn_type_mode	= eWARNING;
			st_work.nEqpStatus	= dWARNING;
		}
		break;

	case 4010:
		nResp = COMI.Check_SingleMove(m_nMotGrip2, COMI.md_cmdpos_backup[m_nMotGrip2]);
		if (nResp == CTLBD_RET_GOOD)
		{
			m_nStep_Rcvy = 5000;
		}
		else if (nResp == CTLBD_RET_ERROR || nResp == CTLBD_RET_SAFETY)
		{
			m_nStep_Rcvy = 4000;

			// 090008 0 0 "ROBOT_GRIP_2_RECOVERY_POS_MOVE_ERR"
			alarm.mstr_code		= "090008";
			alarm.mn_count_mode	= 0;
			alarm.mn_type_mode	= eWARNING;
			st_work.nEqpStatus	= dWARNING;
		}
		else if (nResp == CTLBD_RET_RETRY)
		{
			m_nStep_Rcvy = 4000;
		}
		break;

	case 5000:
		if (m_nReq_Rcvy[5] == CTL_NO)
		{
			m_nStep_Rcvy = 6000;
			break;
		}
		nResp = COMI.Start_SingleMove(m_nMotGrip3, COMI.md_cmdpos_backup[m_nMotGrip3], (int)st_handler.md_run_speed);
		if (nResp == CTLBD_RET_GOOD)
		{
			m_nStep_Rcvy = 5010;
		}
		else if (nResp == CTLBD_RET_ERROR || nResp == CTLBD_RET_SAFETY)
		{
			// 100008 0 0 "ROBOT_GRIP_3_RECOVERY_POS_MOVE_ERR"
			alarm.mstr_code		= "100008";
			alarm.mn_count_mode	= 0;
			alarm.mn_type_mode	= eWARNING;
			st_work.nEqpStatus	= dWARNING;
		}
		break;

	case 5010:
		nResp = COMI.Check_SingleMove(m_nMotGrip3, COMI.md_cmdpos_backup[m_nMotGrip3]);
		if (nResp == CTLBD_RET_GOOD)
		{
			m_nStep_Rcvy = 6000;
		}
		else if (nResp == CTLBD_RET_ERROR || nResp == CTLBD_RET_SAFETY)
		{
			m_nStep_Rcvy = 5000;

			// 100008 0 0 "ROBOT_GRIP_3_RECOVERY_POS_MOVE_ERR"
			alarm.mstr_code		= "100008";
			alarm.mn_count_mode	= 0;
			alarm.mn_type_mode	= eWARNING;
			st_work.nEqpStatus	= dWARNING;
		}
		else if (nResp == CTLBD_RET_RETRY)
		{
			m_nStep_Rcvy = 5000;
		}
		break;

	case 6000:
		if (m_nReq_Rcvy[6] == CTL_NO)
		{
			m_nStep_Rcvy = 7000;
			break;
		}
		nResp = COMI.Start_SingleMove(m_nMotGrip4, COMI.md_cmdpos_backup[m_nMotGrip4], (int)st_handler.md_run_speed);
		if (nResp == CTLBD_RET_GOOD)
		{
			m_nStep_Rcvy = 6010;
		}
		else if (nResp == CTLBD_RET_ERROR || nResp == CTLBD_RET_SAFETY)
		{
			// 110008 0 0 "ROBOT_GRIP_4_RECOVERY_POS_MOVE_ERR"
			alarm.mstr_code		= "110008";
			alarm.mn_count_mode	= 0;
			alarm.mn_type_mode	= eWARNING;
			st_work.nEqpStatus	= dWARNING;
		}
		break;

	case 6010:
		nResp = COMI.Check_SingleMove(m_nMotGrip4, COMI.md_cmdpos_backup[m_nMotGrip4]);
		if (nResp == CTLBD_RET_GOOD)
		{
			m_nStep_Rcvy = 7000;
		}
		else if (nResp == CTLBD_RET_ERROR || nResp == CTLBD_RET_SAFETY)
		{
			m_nStep_Rcvy = 6000;

			// 110008 0 0 "ROBOT_GRIP_4_RECOVERY_POS_MOVE_ERR"
			alarm.mstr_code		= "110008";
			alarm.mn_count_mode	= 0;
			alarm.mn_type_mode	= eWARNING;
			st_work.nEqpStatus	= dWARNING;
		}
		else if (nResp == CTLBD_RET_RETRY)
		{
			m_nStep_Rcvy = 6000;
		}
		break;

	case 7000:
		if (m_nReq_Rcvy[0] == CTL_NO)
		{
			m_nStep_Rcvy = 9000;
			break;
		}
		nResp = COMI.Start_SingleMove(m_nMotZ, COMI.md_cmdpos_backup[m_nMotZ], (int)st_handler.md_run_speed);
		if (nResp == CTLBD_RET_GOOD)
		{
			m_nStep_Rcvy = 7010;
		}
		else if (nResp == CTLBD_RET_ERROR || nResp == CTLBD_RET_SAFETY)
		{
			// 070008 0 0 "BARCODE_ROBOT_Z_RECOVERY_POS_MOVE_ERR"
			alarm.mstr_code		= "070008";
			alarm.mn_count_mode	= 0;
			alarm.mn_type_mode	= eWARNING;
			st_work.nEqpStatus	= dWARNING;
		}
		break;

	case 7010:
		nResp = COMI.Check_SingleMove(m_nMotZ, COMI.md_cmdpos_backup[m_nMotZ]);
		if (nResp == CTLBD_RET_GOOD)
		{
			m_nStep_Rcvy = 9000;
		}
		else if (nResp == CTLBD_RET_ERROR || nResp == CTLBD_RET_SAFETY)
		{
			m_nStep_Rcvy = 7000;

			// 070008 0 0 "BARCODE_ROBOT_Z_RECOVERY_POS_MOVE_ERR"
			alarm.mstr_code		= "070008";
			alarm.mn_count_mode	= 0;
			alarm.mn_type_mode	= eWARNING;
			st_work.nEqpStatus	= dWARNING;
		}
		else if (nResp == CTLBD_RET_RETRY)
		{
			m_nStep_Rcvy = 7000;
		}
		break;

	case 9000:
		nFuncRet = CTL_GOOD;
		m_nStep_Rcvy = 0;
		break;

	}
	return nFuncRet;
}

//==================================================================//
// 악세사리 못집은 경우 리트라이 동작
//==================================================================//
int CSeq_XYZRobot::OnProc_GripRetry(int nzMode) 
{
	Func.OnTrace_ThreadStep(16, m_nStep_GripRetry);	// 쓰레드 스텝 정보 TRACE
	int nFuncRet = CTL_PROCEED;

	int nRet = VAR_INIT_;
	int i=0;
	int nRetData[4] = {0,};

	switch(m_nStep_GripRetry)
	{
	case 0:
		// 그립퍼 사용 모드인 경우
		if (nzMode == 0)
		{
			// 그립퍼의 오버로드 센서 확인
			nRetData[0] = OnCheck_GripperGripAccy0(IO_ON);
			nRetData[1] = OnCheck_GripperGripAccy1(IO_ON);
			nRetData[2] = OnCheck_GripperGripAccy2(IO_ON);
			nRetData[3] = OnCheck_GripperGripAccy3(IO_ON);
		}
		// Vacuum 사용 모드인 경우
		else if (nzMode == 1)
		{
			// 그립퍼의 Vacuum 센서 상태 확인
			nRetData[0] = g_ioMgr.get_in_bit(stIO.i_Chk_GripRbt_VacOn[SIDE_FRONT_][SIDE_LEFT_]);
			nRetData[1] = g_ioMgr.get_in_bit(stIO.i_Chk_GripRbt_VacOn[SIDE_FRONT_][SIDE_RIGHT_]);
			nRetData[2] = g_ioMgr.get_in_bit(stIO.i_Chk_GripRbt_VacOn[SIDE_REAR_][SIDE_LEFT_]);
			nRetData[3] = g_ioMgr.get_in_bit(stIO.i_Chk_GripRbt_VacOn[SIDE_REAR_][SIDE_RIGHT_]);
		}

		// 앞좌 그립퍼
		if (nRetData[0] == IO_OFF)
		{
			dAccyLiftPos[0] = COMI.Get_MotCurrentPos(m_nMotZ0);
			//dAccyLiftPos[0] += st_motor[m_nMotZ0].d_pos[Z_ACC_LIFT_OFFSET_];
			dAccyLiftPos[0] += 2;
			// 규이리 추가 [2015.03.25]
			if (dAccyLiftPos[0] > st_motor[m_nMotZ0].d_pos[Z_ACC_LIFT_LIMIT_])
			{
				dAccyLiftPos[0] = st_motor[m_nMotZ0].d_pos[Z_ACC_LIFT_LIMIT_];
			}
		}
		// 앞우 그립퍼
		if (nRetData[1] == IO_OFF)
		{
			dAccyLiftPos[1] = COMI.Get_MotCurrentPos(m_nMotZ1);
			//dAccyLiftPos[1] += st_motor[m_nMotZ1].d_pos[Z_ACC_LIFT_OFFSET_];
			dAccyLiftPos[1] += 2;
			// 규이리 추가 [2015.03.25]
			if (dAccyLiftPos[1] > st_motor[m_nMotZ1].d_pos[Z_ACC_LIFT_LIMIT_])
			{
				dAccyLiftPos[1] = st_motor[m_nMotZ1].d_pos[Z_ACC_LIFT_LIMIT_];
			}
		}
		// 뒤좌 그립퍼
		if (nRetData[2] == IO_OFF)
		{
			dAccyLiftPos[2] = COMI.Get_MotCurrentPos(m_nMotZ2);
			//dAccyLiftPos[2] += st_motor[m_nMotZ2].d_pos[Z_ACC_LIFT_OFFSET_];
			dAccyLiftPos[2] += 2;
			// 규이리 추가 [2015.03.25]
			if (dAccyLiftPos[2] > st_motor[m_nMotZ2].d_pos[Z_ACC_LIFT_LIMIT_])
			{
				dAccyLiftPos[2] = st_motor[m_nMotZ2].d_pos[Z_ACC_LIFT_LIMIT_];
			}
		}
		// 뒤우 그립퍼
		if (nRetData[3] == IO_OFF)
		{
			dAccyLiftPos[3] = COMI.Get_MotCurrentPos(m_nMotZ3);
			//dAccyLiftPos[3] += st_motor[m_nMotZ3].d_pos[Z_ACC_LIFT_OFFSET_];
			dAccyLiftPos[3] += 2;
			// 규이리 추가 [2015.03.25]
			if (dAccyLiftPos[3] > st_motor[m_nMotZ3].d_pos[Z_ACC_LIFT_LIMIT_])
			{
				dAccyLiftPos[3] = st_motor[m_nMotZ3].d_pos[Z_ACC_LIFT_LIMIT_];
			}
		}
		m_nStep_GripRetry = 1000;
		break;

	case 1000:
		for(i=0; i<4; i++)
		{
			m_nResp_Lift[i] = CTL_NO;
		}

		// dAccyLiftPos : OnProc_GripRetry() 함수 호출전에 0으로 리셋됨
		if (dAccyLiftPos[0] != 0)
		{
			nRetData[0] = COMI.Start_SingleMove(m_nMotZ0, dAccyLiftPos[0], (int)st_handler.md_run_speed);
		}
		else
		{
			nRetData[0] = CTLBD_RET_GOOD;
		}

		if (dAccyLiftPos[1] != 0)
		{
			nRetData[1] = COMI.Start_SingleMove(m_nMotZ1, dAccyLiftPos[1], (int)st_handler.md_run_speed);
		}
		else
		{
			nRetData[1] = CTLBD_RET_GOOD;
		}

		if (dAccyLiftPos[2] != 0)
		{
			nRetData[2] = COMI.Start_SingleMove(m_nMotZ2, dAccyLiftPos[2], (int)st_handler.md_run_speed);
		}
		else
		{
			nRetData[2] = CTLBD_RET_GOOD;
		}

		if (dAccyLiftPos[3] != 0)
		{
			nRetData[3] = COMI.Start_SingleMove(m_nMotZ3, dAccyLiftPos[3], (int)st_handler.md_run_speed);
		}
		else
		{
			nRetData[3] = CTLBD_RET_GOOD;
		}

		if (nRetData[0] == CTLBD_RET_GOOD)
		{
			m_nResp_Lift[0] = CTL_YES;
		}
		if (nRetData[1] == CTLBD_RET_GOOD)
		{
			m_nResp_Lift[1] = CTL_YES;
		}
		if (nRetData[2] == CTLBD_RET_GOOD)
		{
			m_nResp_Lift[2] = CTL_YES;
		}
		if (nRetData[3] == CTLBD_RET_GOOD)
		{
			m_nResp_Lift[3] = CTL_YES;
		}

		if (m_nResp_Lift[0] == CTL_YES &&
			m_nResp_Lift[1] == CTL_YES &&
			m_nResp_Lift[2] == CTL_YES &&
			m_nResp_Lift[3] == CTL_YES)
		{
			for(i=0; i<4; i++)
			{
				m_nResp_Lift[i] = CTL_NO;
			}
			m_nStep_GripRetry = 1100;
		}
		else if (nRetData[0] == CTLBD_RET_RETRY ||
			nRetData[1] == CTLBD_RET_RETRY ||
			nRetData[2] == CTLBD_RET_RETRY ||
			nRetData[3] == CTLBD_RET_RETRY)
		{
			m_nStep_GripRetry = 1000;
		}
		else if (nRetData[0] != CTLBD_RET_PROCEED && nRetData[0] != CTLBD_RET_GOOD)
		{
			m_nStep_GripRetry = 1000;
			// 001003 0 00 "LIFTER_UP_DOWN_SHIFT1_Z_ACC_LIFT_OFFSET_MOVE_ERR."
			alarm.mstr_code		= "001003";
			alarm.mn_count_mode	= 0;
			alarm.mn_type_mode	= eWARNING;
			st_work.nEqpStatus	= dWARNING;
		}
		else if (nRetData[1] != CTLBD_RET_PROCEED && nRetData[1] != CTLBD_RET_GOOD)
		{
			m_nStep_GripRetry = 1000;
			// 011003 0 00 "LIFTER_UP_DOWN_SHIFT2_Z_ACC_LIFT_OFFSET_MOVE_ERR."
			alarm.mstr_code		= "011003";
			alarm.mn_count_mode	= 0;
			alarm.mn_type_mode	= eWARNING;
			st_work.nEqpStatus	= dWARNING;
		}
		else if (nRetData[2] != CTLBD_RET_PROCEED && nRetData[2] != CTLBD_RET_GOOD)
		{
			m_nStep_GripRetry = 1000;
			// 021003 0 00 "LIFTER_UP_DOWN_SHIFT3_Z_ACC_LIFT_OFFSET_MOVE_ERR."
			alarm.mstr_code		= "021003";
			alarm.mn_count_mode	= 0;
			alarm.mn_type_mode	= eWARNING;
			st_work.nEqpStatus	= dWARNING;
		}
		else if (nRetData[3] != CTLBD_RET_PROCEED && nRetData[3] != CTLBD_RET_GOOD)
		{
			m_nStep_GripRetry = 1000;
			// 031003 0 00 "LIFTER_UP_DOWN_SHIFT4_Z_ACC_LIFT_OFFSET_MOVE_ERR."
			alarm.mstr_code		= "031003";
			alarm.mn_count_mode	= 0;
			alarm.mn_type_mode	= eWARNING;
			st_work.nEqpStatus	= dWARNING;
		}
		break;

	case 1100:
		if (dAccyLiftPos[0] != 0)
		{
			nRetData[0] = COMI.Check_SingleMove(m_nMotZ0, dAccyLiftPos[0]);
		}
		else
		{
			nRetData[0] = CTLBD_RET_GOOD;
		}
		
		if (dAccyLiftPos[1] != 0)
		{
			nRetData[1] = COMI.Check_SingleMove(m_nMotZ1, dAccyLiftPos[1]);
		}
		else
		{
			nRetData[1] = CTLBD_RET_GOOD;
		}
		
		if (dAccyLiftPos[2] != 0)
		{
			nRetData[2] = COMI.Check_SingleMove(m_nMotZ2, dAccyLiftPos[2]);
		}
		else
		{
			nRetData[2] = CTLBD_RET_GOOD;
		}
		
		if (dAccyLiftPos[3] != 0)
		{
			nRetData[3] = COMI.Check_SingleMove(m_nMotZ3, dAccyLiftPos[3]);
		}
		else
		{
			nRetData[3] = CTLBD_RET_GOOD;
		}

		if (nRetData[0] == CTLBD_RET_GOOD)
		{
			m_nResp_Lift[0] = CTL_YES;
		}
		if (nRetData[1] == CTLBD_RET_GOOD)
		{
			m_nResp_Lift[1] = CTL_YES;
		}
		if (nRetData[2] == CTLBD_RET_GOOD)
		{
			m_nResp_Lift[2] = CTL_YES;
		}
		if (nRetData[3] == CTLBD_RET_GOOD)
		{
			m_nResp_Lift[3] = CTL_YES;
		}
		
		if (m_nResp_Lift[0] == CTL_YES &&
			m_nResp_Lift[1] == CTL_YES &&
			m_nResp_Lift[2] == CTL_YES &&
			m_nResp_Lift[3] == CTL_YES)
		{
			for(i=0; i<4; i++)
			{
				dAccyLiftPos[i] = 0;
				m_nResp_Lift[i] = CTL_NO;
			}
			m_nStep_GripRetry = 10000;
		}
		else if (nRetData[0] == CTLBD_RET_RETRY ||
			nRetData[1] == CTLBD_RET_RETRY ||
			nRetData[2] == CTLBD_RET_RETRY ||
			nRetData[3] == CTLBD_RET_RETRY)
		{
			m_nStep_GripRetry = 1000;
		}
		else if (nRetData[0] != CTLBD_RET_PROCEED && nRetData[0] != CTLBD_RET_GOOD)
		{
			m_nStep_GripRetry = 1000;
			// 001003 0 00 "LIFTER_UP_DOWN_SHIFT1_Z_ACC_LIFT_OFFSET_MOVE_ERR."
			alarm.mstr_code		= "001003";
			alarm.mn_count_mode	= 0;
			alarm.mn_type_mode	= eWARNING;
			st_work.nEqpStatus	= dWARNING;
		}
		else if (nRetData[1] != CTLBD_RET_PROCEED && nRetData[1] != CTLBD_RET_GOOD)
		{
			m_nStep_GripRetry = 1000;
			// 011003 0 00 "LIFTER_UP_DOWN_SHIFT2_Z_ACC_LIFT_OFFSET_MOVE_ERR."
			alarm.mstr_code		= "011003";
			alarm.mn_count_mode	= 0;
			alarm.mn_type_mode	= eWARNING;
			st_work.nEqpStatus	= dWARNING;
		}
		else if (nRetData[2] != CTLBD_RET_PROCEED && nRetData[2] != CTLBD_RET_GOOD)
		{
			m_nStep_GripRetry = 1000;
			// 021003 0 00 "LIFTER_UP_DOWN_SHIFT3_Z_ACC_LIFT_OFFSET_MOVE_ERR."
			alarm.mstr_code		= "021003";
			alarm.mn_count_mode	= 0;
			alarm.mn_type_mode	= eWARNING;
			st_work.nEqpStatus	= dWARNING;
		}
		else if (nRetData[3] != CTLBD_RET_PROCEED && nRetData[3] != CTLBD_RET_GOOD)
		{
			m_nStep_GripRetry = 1000;
			// 031003 0 00 "LIFTER_UP_DOWN_SHIFT4_Z_ACC_LIFT_OFFSET_MOVE_ERR."
			alarm.mstr_code		= "031003";
			alarm.mn_count_mode	= 0;
			alarm.mn_type_mode	= eWARNING;
			st_work.nEqpStatus	= dWARNING;
		}
		break;

	case 10000:
		if (nzMode == 0)
		{
			// 그립퍼의 오버로드 센서 상태 확인
			nRetData[0] = OnCheck_GripperGripAccy0(IO_ON);
			nRetData[1] = OnCheck_GripperGripAccy1(IO_ON);
			nRetData[2] = OnCheck_GripperGripAccy2(IO_ON);
			nRetData[3] = OnCheck_GripperGripAccy3(IO_ON);
		}
		else if (nzMode == 1)
		{
			// 그립퍼의 Vacuum 센서 상태 확인
			nRetData[0] = g_ioMgr.get_in_bit(stIO.i_Chk_GripRbt_VacOn[SIDE_FRONT_][SIDE_LEFT_]);
			nRetData[1] = g_ioMgr.get_in_bit(stIO.i_Chk_GripRbt_VacOn[SIDE_FRONT_][SIDE_RIGHT_]);
			nRetData[2] = g_ioMgr.get_in_bit(stIO.i_Chk_GripRbt_VacOn[SIDE_REAR_][SIDE_LEFT_]);
			nRetData[3] = g_ioMgr.get_in_bit(stIO.i_Chk_GripRbt_VacOn[SIDE_REAR_][SIDE_RIGHT_]);
		}

		if (nRetData[0] == IO_ON && nRetData[1] == IO_ON && nRetData[2] == IO_ON && nRetData[3] == IO_ON)
		{
			m_nStep_GripRetry = 0;
			nFuncRet = CTL_GOOD;
		}
		else
		{
			m_nGripRetryCnt++;	// 리프터 올리는 동작 시도 횟수 증가

			// 규이리 추가 [2015.03.25]
			if (m_nGripRetryCnt > 20)
			{
				m_nGripRetryCnt = 20;
			}
			m_nStep_GripRetry = 0;

			// 규이리 추가 [2015.03.25]
			if (m_nGripRetryCnt >= 20)
			{
				nFuncRet = CTL_ERROR;	// 강제로 종료시킴
			}
		}
		break;
	}
	return nFuncRet;
}

//////////////////////////////////////////////////////////////////////////
// 박스 배출 작업
//////////////////////////////////////////////////////////////////////////
int CSeq_XYZRobot::OnRun_ForceDischarge() 
{
	int nFuncRet = true;
	int nRet, nChk = 0, i;
	int nRetData[4] = {0,};

	Func.OnTrace_ThreadStep(17, m_nStep_ForceDischarge);	// 쓰레드 스텝 정보 TRACE

	// Box 배출 대기
	if(st_work.nForceDischarge != FORCEDISCHARGE_ON)
	{
		return true;
	}

	switch(m_nStep_ForceDischarge)
	{
	case 0:
		if(stSync.nForceDischargeComplete[SITE_XYZ_ROBOT_] != CTL_YES)
		{
			//memset(st_map.nBCR_State, BCR_READ_BAD_, sizeof(st_map.nBCR_State));
			m_nStep_ForceDischarge = 100;
		}
		break;
		
	case 100:
		nRet = CTL_Lib.OnSingleMove(m_nMotZ, st_motor[m_nMotZ].d_pos[Z_RBT_SAFETY_], (int)st_handler.md_run_speed);
		if (nRet == CTLBD_RET_GOOD)
		{
			m_nStep_ForceDischarge = 200;
		}
		else if (nRet == CTLBD_RET_ERROR || nRet == CTLBD_RET_RETRY)
		{
			// 071005 0 0 "BARCODE_ROBOT_Z_RBT_SAFETY_MOVE_ERR"
			alarm.mstr_code		= "071005";
			alarm.mn_count_mode	= 0;
			alarm.mn_type_mode	= eWARNING;
			st_work.nEqpStatus	= dWARNING;
		}
		break;

	case 200:
		for (i = 0; i < MAX_PICKER_; i++)
		{
			if (st_map.nXYZRbtPickerInfo[i] == CTL_YES)
			{
				st_map.nBCR_State[i] = BCR_READ_BAD_;
				nChk++;
			}
		}

		if (nChk > 0)
		{
			m_nStep_ForceDischarge = 1000;
		}
		else
		{
			m_nStep_ForceDischarge = 3000;
		}

		break;
		
	case 1000:
		// Gripper가 잡고 있는 Accy 배출 (SIDE_FRONT_ : 1, 2번 Gripper, SIDE_REAR_ : 3, 4번 Gripper)
		nRet = OnProc_AccyOut(st_map.nBCR_State, SIDE_FRONT_);
		if (nRet == CTLBD_RET_GOOD)
		{
			m_nStep_ForceDischarge = 2000;
		}
		break;
		
	case 2000:
		// Gripper가 잡고 있는 Accy 배출 (SIDE_FRONT_ : 1, 2번 Gripper, SIDE_REAR_ : 3, 4번 Gripper)
		nRet = OnProc_AccyOut(st_map.nBCR_State, SIDE_REAR_);
		if (nRet == CTLBD_RET_GOOD)
		{
			m_nStep_ForceDischarge = 3000;
		}
		break;

	case 3000:
		// yangkyu [2015.02.22]
		// 번호는 메인 설비 정면 기준으로 0(앞쪽 좌), 1(앞쪽 우), 2(뒤쪽 좌), 3(뒤쪽 우)
		// NG Buffer 자재 확인
		nRetData[0] = OnCheck_NGBufferFrontAccy(IO_ON, CHK_EXIST_, SIDE_LEFT_);
		nRetData[1] = OnCheck_NGBufferFrontAccy(IO_ON, CHK_EXIST_, SIDE_RIGHT_);
		nRetData[2] = OnCheck_NGBufferRearAccy(IO_ON, CHK_EXIST_, SIDE_LEFT_);
		nRetData[3] = OnCheck_NGBufferRearAccy(IO_ON, CHK_EXIST_, SIDE_RIGHT_);

		if (st_basic.n_mode_device == WITHOUT_DVC_)
		{
			for(i=0; i<MAX_PICKER_; i++)
			{
				nRetData[i] = st_map.nNGBuffer[i];
			}
		}

		if (nRetData[0] == IO_OFF && nRetData[1] == IO_OFF &&
			nRetData[2] == IO_OFF && nRetData[3] == IO_OFF)
		{
			memset(st_map.nNGBuffer, ACCY_NO_, sizeof(st_map.nNGBuffer));
			m_nStep_ForceDischarge = 3200;
		}
		else
		{
			m_nStep_ForceDischarge = 3100;
		}
		break;
		
	case 3100:
		// NG Buffer Clear
		nRet = OnProc_NGBufferClear();	// NG 버퍼의 악세사리 배출
		if (nRet == CTLBD_RET_GOOD)
		{
			m_nStep_ForceDischarge = 3000;
		}
		break;
		
	case 3200:
		// Buffer Conv 자재 확인
		nRetData[0] = OnCheck_FrontAccySupply(IO_ON);		// Buffer Conv Front Accy 확인
		nRetData[1] = OnCheck_RearAccySupply(IO_ON);		// Buffer Conv Rear Accy 확인
		
		if (nRetData[0] == IO_OFF && nRetData[1] == IO_OFF)
		{
			memset(st_map.nBufferCovAccyExist, ACCY_NO_, sizeof(st_map.nBufferCovAccyExist));
			if (st_handler.cwnd_main != NULL)
			{
				st_handler.cwnd_main->PostMessage(WM_UPDATE_MAIN, PLACE_BUFFER_CONV_);	// 화면 표시 요청
			}
			m_nStep_ForceDischarge = 10000;
		}
		else
		{
			m_nStep_ForceDischarge = 3250;
		}
		break;

	case 3250:
		// Buffer Conv 강제 배출 작업이 완료 될때까지 대기
		if (stSync.nForceDischargeComplete[SITE_BUFFER_CONV] == CTL_YES)
		{
			m_nStep_ForceDischarge = 3300;
		}
		break;
		
	case 3300:
		// Buffer Conv 자재 Clear
		nRet = OnProc_BufferConvClear();
		if (nRet == CTLBD_RET_GOOD)
		{
			m_nStep_ForceDischarge = 3200;
		}
		break;

	case 10000:
		m_nStep_BCRRead = 0;
		m_nStep_BCRBad = 0;
		m_nStep_ReadMove = 0;
		m_nStep_NG_Buff = 0;
		m_nStep_BufferConvClear = 0;
		m_nStep_NGAccyOut = 0;
		m_nStep_GripRetry = 0;
		m_nGripRetryCnt = 0;
		m_nStep_ForceDischarge = 0;
		m_nGirpSum = 0;
		m_nStep_BufferConvPlace = 0;
		m_nStep_AccyVacPick = 0;
		m_nStep_AccyGripPick = 0;
		m_nStep_WorkSiteChange = 0;
		m_nStep_AccyPlace = 0;
		m_nStep_NGBufferPlace = 0;
		m_nStep_NGBufferPick = 0;

		m_nStep_Run = 0;

		st_map.nResp_AccyReadyCNT = 0;
		st_map.nBoxChange = TRUE;

		stSync.nForceDischargeComplete[SITE_XYZ_ROBOT_] = CTL_YES;
		stSync.nResp_XYZRbt2Lifter_Work = SYNC_RESP_RESET_;
		stSync.nReq_XYZRbt2BufferAlaignConv_Work = SYNC_REQ_RESET_;
		memset(st_map.nBCR_State, -1, sizeof(st_map.nBCR_State));

		// 중복 되는 Accy를 버리기 위해 Bad 처리 하엿으므로 바코드 표시를 다시 함.
		if (st_handler.cwnd_main != NULL)
		{
			st_handler.cwnd_main->PostMessage(WM_UPDATE_MAIN, READ_BCR_DATA);
		}
		break;
	}

	return nFuncRet;
}

//////////////////////////////////////////////////////////////////////////
// NG Accy를 보급 받은 후 바코드 상태를 변경 해주는 작업
//////////////////////////////////////////////////////////////////////////
// 0 : Front, 1 : Rear
void CSeq_XYZRobot::OnBCRStateChange(int nzMode)
{
	switch(m_nGirpSum)
	{
	case 1:
		st_map.nBCR_State[0] = BCR_READ_GOOD_;
		if (nzMode == 1)
		{
			st_map.nNGBuffer[2] = ACCY_NO_;
			st_work.sRbtBCR_Data[0] = st_work.sNGBufferBCR_Data[2];
			st_work.sNGBufferBCR_Data[2] = "";
		}
		else
		{
			st_map.nNGBuffer[0] = ACCY_NO_;
			st_work.sRbtBCR_Data[0] = st_work.sNGBufferBCR_Data[0];
			st_work.sNGBufferBCR_Data[0] = "";
		}
		break;
	case 2:
		st_map.nBCR_State[1] = BCR_READ_GOOD_;
		if (nzMode == 1)
		{
			st_map.nNGBuffer[3] = ACCY_NO_;
			st_work.sRbtBCR_Data[1] = st_work.sNGBufferBCR_Data[3];
			st_work.sNGBufferBCR_Data[3] = "";
		}
		else
		{
			st_map.nNGBuffer[1] = ACCY_NO_;
			st_work.sRbtBCR_Data[1] = st_work.sNGBufferBCR_Data[1];
			st_work.sNGBufferBCR_Data[1] = "";
		}
		break;
	case 3:
		st_map.nBCR_State[0] = BCR_READ_GOOD_;
		st_map.nBCR_State[1] = BCR_READ_GOOD_;
		if (nzMode == 1)
		{
			st_map.nNGBuffer[2] = ACCY_NO_;
			st_map.nNGBuffer[3] = ACCY_NO_;
			st_work.sRbtBCR_Data[0] = st_work.sNGBufferBCR_Data[2];
			st_work.sRbtBCR_Data[1] = st_work.sNGBufferBCR_Data[3];
			st_work.sNGBufferBCR_Data[2] = "";
			st_work.sNGBufferBCR_Data[3] = "";
		}
		else
		{
			st_map.nNGBuffer[0] = ACCY_NO_;
			st_map.nNGBuffer[1] = ACCY_NO_;
			st_work.sRbtBCR_Data[0] = st_work.sNGBufferBCR_Data[0];
			st_work.sRbtBCR_Data[1] = st_work.sNGBufferBCR_Data[1];
			st_work.sNGBufferBCR_Data[0] = "";
			st_work.sNGBufferBCR_Data[1] = "";
		}
		break;
	case 4:
		st_map.nBCR_State[2] = BCR_READ_GOOD_;
		if (nzMode == 0)
		{
			st_map.nNGBuffer[0] = ACCY_NO_;
			st_work.sRbtBCR_Data[2] = st_work.sNGBufferBCR_Data[0];
			st_work.sNGBufferBCR_Data[0] = "";
		}
		else
		{
			st_map.nNGBuffer[2] = ACCY_NO_;
			st_work.sRbtBCR_Data[2] = st_work.sNGBufferBCR_Data[2];
			st_work.sNGBufferBCR_Data[2] = "";
		}
		break;
	case 5:
		st_map.nBCR_State[0] = BCR_READ_GOOD_;
		st_map.nBCR_State[2] = BCR_READ_GOOD_;
		st_map.nNGBuffer[0] = ACCY_NO_;
		st_map.nNGBuffer[2] = ACCY_NO_;
		st_work.sRbtBCR_Data[0] = st_work.sNGBufferBCR_Data[0];
		st_work.sRbtBCR_Data[2] = st_work.sNGBufferBCR_Data[2];
		st_work.sNGBufferBCR_Data[0] = "";
		st_work.sNGBufferBCR_Data[2] = "";
		break;
	case 6:
		st_map.nBCR_State[1] = BCR_READ_GOOD_;
		st_map.nBCR_State[2] = BCR_READ_GOOD_;
		st_map.nNGBuffer[1] = ACCY_NO_;
		st_map.nNGBuffer[2] = ACCY_NO_;
		st_work.sRbtBCR_Data[1] = st_work.sNGBufferBCR_Data[1];
		st_work.sRbtBCR_Data[2] = st_work.sNGBufferBCR_Data[2];
		st_work.sNGBufferBCR_Data[1] = "";
		st_work.sNGBufferBCR_Data[2] = "";
		break;
	case 7:
		st_map.nBCR_State[0] = BCR_READ_GOOD_;
		st_map.nBCR_State[1] = BCR_READ_GOOD_;
		st_map.nBCR_State[2] = BCR_READ_GOOD_;
		st_map.nNGBuffer[0] = ACCY_NO_;
		st_map.nNGBuffer[1] = ACCY_NO_;
		st_map.nNGBuffer[2] = ACCY_NO_;
		st_work.sRbtBCR_Data[0] = st_work.sNGBufferBCR_Data[0];
		st_work.sRbtBCR_Data[1] = st_work.sNGBufferBCR_Data[1];
		st_work.sRbtBCR_Data[2] = st_work.sNGBufferBCR_Data[2];
		st_work.sNGBufferBCR_Data[0] = "";
		st_work.sNGBufferBCR_Data[1] = "";
		st_work.sNGBufferBCR_Data[2] = "";
		break;
	case 8:
		st_map.nBCR_State[3] = BCR_READ_GOOD_;
		if (nzMode == 0)
		{
			st_map.nNGBuffer[1] = ACCY_NO_;
			st_work.sRbtBCR_Data[3] = st_work.sNGBufferBCR_Data[1];
			st_work.sNGBufferBCR_Data[1] = "";
		}
		else
		{
			st_map.nNGBuffer[3] = ACCY_NO_;
			st_work.sRbtBCR_Data[3] = st_work.sNGBufferBCR_Data[3];
			st_work.sNGBufferBCR_Data[3] = "";
		}
		break;
	case 9:
		st_map.nBCR_State[0] = BCR_READ_GOOD_;
		st_map.nBCR_State[3] = BCR_READ_GOOD_;
		st_map.nNGBuffer[0] = ACCY_NO_;
		st_map.nNGBuffer[3] = ACCY_NO_;
		st_work.sRbtBCR_Data[0] = st_work.sNGBufferBCR_Data[0];
		st_work.sRbtBCR_Data[3] = st_work.sNGBufferBCR_Data[3];
		st_work.sNGBufferBCR_Data[0] = "";
		st_work.sNGBufferBCR_Data[3] = "";
		break;
	case 10:
		st_map.nBCR_State[1] = BCR_READ_GOOD_;
		st_map.nBCR_State[3] = BCR_READ_GOOD_;
		st_map.nNGBuffer[1] = ACCY_NO_;
		st_map.nNGBuffer[3] = ACCY_NO_;
		st_work.sRbtBCR_Data[1] = st_work.sNGBufferBCR_Data[1];
		st_work.sRbtBCR_Data[3] = st_work.sNGBufferBCR_Data[3];
		st_work.sNGBufferBCR_Data[1] = "";
		st_work.sNGBufferBCR_Data[3] = "";
		break;
	case 11:
		st_map.nBCR_State[0] = BCR_READ_GOOD_;
		st_map.nBCR_State[1] = BCR_READ_GOOD_;
		st_map.nBCR_State[3] = BCR_READ_GOOD_;
		st_map.nNGBuffer[0] = ACCY_NO_;
		st_map.nNGBuffer[1] = ACCY_NO_;
		st_map.nNGBuffer[3] = ACCY_NO_;
		st_work.sRbtBCR_Data[0] = st_work.sNGBufferBCR_Data[0];
		st_work.sRbtBCR_Data[1] = st_work.sNGBufferBCR_Data[1];
		st_work.sRbtBCR_Data[3] = st_work.sNGBufferBCR_Data[3];
		st_work.sNGBufferBCR_Data[0] = "";
		st_work.sNGBufferBCR_Data[1] = "";
		st_work.sNGBufferBCR_Data[3] = "";
		break;
	case 12:
		st_map.nBCR_State[2] = BCR_READ_GOOD_;
		st_map.nBCR_State[3] = BCR_READ_GOOD_;
		if (nzMode == 0)
		{
			st_map.nNGBuffer[0] = ACCY_NO_;
			st_map.nNGBuffer[1] = ACCY_NO_;
			st_work.sRbtBCR_Data[2] = st_work.sNGBufferBCR_Data[0];
			st_work.sRbtBCR_Data[3] = st_work.sNGBufferBCR_Data[1];
			st_work.sNGBufferBCR_Data[0] = "";
			st_work.sNGBufferBCR_Data[1] = "";
		}
		else
		{
			st_map.nNGBuffer[2] = ACCY_NO_;
			st_map.nNGBuffer[3] = ACCY_NO_;
			st_work.sRbtBCR_Data[2] = st_work.sNGBufferBCR_Data[2];
			st_work.sRbtBCR_Data[3] = st_work.sNGBufferBCR_Data[3];
			st_work.sNGBufferBCR_Data[2] = "";
			st_work.sNGBufferBCR_Data[3] = "";
		}
		break;
	case 13:
		st_map.nBCR_State[0] = BCR_READ_GOOD_;
		st_map.nBCR_State[2] = BCR_READ_GOOD_;
		st_map.nBCR_State[3] = BCR_READ_GOOD_;
		st_map.nNGBuffer[0] = ACCY_NO_;
		st_map.nNGBuffer[2] = ACCY_NO_;
		st_map.nNGBuffer[3] = ACCY_NO_;
		st_work.sRbtBCR_Data[0] = st_work.sNGBufferBCR_Data[0];
		st_work.sRbtBCR_Data[2] = st_work.sNGBufferBCR_Data[2];
		st_work.sRbtBCR_Data[3] = st_work.sNGBufferBCR_Data[3];
		st_work.sNGBufferBCR_Data[0] = "";
		st_work.sNGBufferBCR_Data[2] = "";
		st_work.sNGBufferBCR_Data[3] = "";
		break;
	case 14:
		st_map.nBCR_State[1] = BCR_READ_GOOD_;
		st_map.nBCR_State[2] = BCR_READ_GOOD_;
		st_map.nBCR_State[3] = BCR_READ_GOOD_;
		st_map.nNGBuffer[1] = ACCY_NO_;
		st_map.nNGBuffer[2] = ACCY_NO_;
		st_map.nNGBuffer[3] = ACCY_NO_;
		st_work.sRbtBCR_Data[1] = st_work.sNGBufferBCR_Data[1];
		st_work.sRbtBCR_Data[2] = st_work.sNGBufferBCR_Data[2];
		st_work.sRbtBCR_Data[3] = st_work.sNGBufferBCR_Data[3];
		st_work.sNGBufferBCR_Data[1] = "";
		st_work.sNGBufferBCR_Data[2] = "";
		st_work.sNGBufferBCR_Data[3] = "";
		break;
	case 15:
		st_map.nBCR_State[0] = BCR_READ_GOOD_;
		st_map.nBCR_State[1] = BCR_READ_GOOD_;
		st_map.nBCR_State[2] = BCR_READ_GOOD_;
		st_map.nBCR_State[3] = BCR_READ_GOOD_;
		st_map.nNGBuffer[0] = ACCY_NO_;
		st_map.nNGBuffer[1] = ACCY_NO_;
		st_map.nNGBuffer[2] = ACCY_NO_;
		st_map.nNGBuffer[3] = ACCY_NO_;
		st_work.sRbtBCR_Data[0] = st_work.sNGBufferBCR_Data[0];
		st_work.sRbtBCR_Data[1] = st_work.sNGBufferBCR_Data[1];
		st_work.sRbtBCR_Data[2] = st_work.sNGBufferBCR_Data[2];
		st_work.sRbtBCR_Data[3] = st_work.sNGBufferBCR_Data[3];
		st_work.sNGBufferBCR_Data[0] = "";
		st_work.sNGBufferBCR_Data[1] = "";
		st_work.sNGBufferBCR_Data[2] = "";
		st_work.sNGBufferBCR_Data[3] = "";
		break;
	}

	m_nGirpSum = 0;
}
//==================================================================//
// 악세사리 박스가 공급 되는 방향에서 Front 2*2 센서 확인
//==================================================================//
int CSeq_XYZRobot::OnCheck_NGBufferFrontAccy(int nzOnOff, int nzMode, int nzSite) 
{
	if (nzSite < SIDE_LEFT_ || nzSite > SIDE_RIGHT_)
	{
		nzSite = SIDE_BOTH_;
	}

	int nReadIO[2] = {0,};
	// 센서가 B접이라 센서 상태 확인 시 반전 사용
	nReadIO[0] = !g_ioMgr.get_in_bit(stIO.i_Chk_NGBufferTratAccyDetection[SIDE_FRONT_][SIDE_LEFT_]);
	nReadIO[1] = !g_ioMgr.get_in_bit(stIO.i_Chk_NGBufferTratAccyDetection[SIDE_FRONT_][SIDE_RIGHT_]);

	if (nzSite == SIDE_LEFT_)
	{
		// [Right] 센서 입력은 강제로 설정
		nReadIO[1] = nzOnOff;
	}
	else if (nzSite == SIDE_RIGHT_)
	{
		// [Left] 센서 입력은 강제로 설정
		nReadIO[0] = nzOnOff;
	}

	if (nzMode == CHK_EXIST_)
	{
		// 현재 WithOut 모드인지 확인
		// - 자재없이 돌리고 있으므로 감지되지 않기 때문에 강제로 설정함
		if (st_basic.n_mode_device == WITHOUT_DVC_)
		{
			nReadIO[0] = !nzOnOff;
			nReadIO[1] = !nzOnOff;
		}
	}

	if (nReadIO[0] == IO_ON && nReadIO[1] == IO_ON)
	{
		return IO_ON;	// 센서 감지
	}
	else	
	{
		return IO_OFF;	// 센서 미감지
	}
}

//==================================================================//
// 악세사리 박스가 공급 되는 방향에서 Rear 2*2 센서 확인
//==================================================================//
int CSeq_XYZRobot::OnCheck_NGBufferRearAccy(int nzOnOff, int nzMode, int nzSite) 
{
	if (nzSite < SIDE_LEFT_ || nzSite > SIDE_RIGHT_)
	{
		nzSite = SIDE_BOTH_;
	}
	
	int nReadIO[2] = {0,};
	// 센서가 B접이라 센서 상태 확인 시 반전 사용
	nReadIO[0] = !g_ioMgr.get_in_bit(stIO.i_Chk_NGBufferTratAccyDetection[SIDE_REAR_][SIDE_LEFT_]);
	nReadIO[1] = !g_ioMgr.get_in_bit(stIO.i_Chk_NGBufferTratAccyDetection[SIDE_REAR_][SIDE_RIGHT_]);
	
	if (nzSite == SIDE_LEFT_)
	{
		// [Right] 센서 입력은 강제로 설정
		nReadIO[1] = nzOnOff;
	}
	else if (nzSite == SIDE_RIGHT_)
	{
		// [Left] 센서 입력은 강제로 설정
		nReadIO[0] = nzOnOff;
	}
	
	if (nzMode == CHK_EXIST_)
	{
		// 현재 WithOut 모드인지 확인
		// - 자재없이 돌리고 있으므로 감지되지 않기 때문에 강제로 설정함
		if (st_basic.n_mode_device == WITHOUT_DVC_)
		{
			nReadIO[0] = !nzOnOff;
			nReadIO[1] = !nzOnOff;
		}
	}
	
	if (nReadIO[0] == IO_ON && nReadIO[1] == IO_ON)
	{
		return IO_ON;	// 센서 감지
	}
	else	
	{
		return IO_OFF;	// 센서 미감지
	}
}

//==================================================================//
// 악세사리가 공급 되는 방향에서 Front Buffer 센서 확인
//==================================================================//
int CSeq_XYZRobot::OnCheck_FrontAccySupply(int nzOnOff, int nzMode, int nzSite) 
{
	if (nzSite < SIDE_LEFT_ || nzSite > SIDE_RIGHT_)
	{
		nzSite = SIDE_BOTH_;
	}

	int nReadIO[2] = {0,};
	// 센서가 B접이라 센서 상태 확인 시 반전 사용
	nReadIO[0] = !g_ioMgr.get_in_bit(stIO.i_Chk_BufferTryAccyDetection[SIDE_FRONT_][SIDE_LEFT_]);
	nReadIO[1] = !g_ioMgr.get_in_bit(stIO.i_Chk_BufferTryAccyDetection[SIDE_FRONT_][SIDE_RIGHT_]);

	if (nzSite == SIDE_LEFT_)
	{
		// [Right] 센서 입력은 강제로 설정
		nReadIO[1] = nzOnOff;
	}
	else if (nzSite == SIDE_RIGHT_)
	{
		// [Left] 센서 입력은 강제로 설정
		nReadIO[0] = nzOnOff;
	}

	if (nzMode == CHK_EXIST_)
	{
		// 현재 WithOut 모드인지 확인
		// - 자재없이 돌리고 있으므로 감지되지 않기 때문에 강제로 설정함
		if (st_basic.n_mode_device == WITHOUT_DVC_)
		{
			if (st_map.nLoadingAccyBoxExist[1] == 0)
			{
				nReadIO[0] = st_map.nBufferCovAccyExist[0];
				nReadIO[1] = st_map.nBufferCovAccyExist[1];
			}
			else
			{
				nReadIO[0] = st_map.nBufferCovAccyExist[0];
				nReadIO[1] = st_map.nBufferCovAccyExist[1];
			}
		}
	}

	if (nReadIO[0] == IO_ON && nReadIO[1] == IO_ON)
	{
		return IO_ON;	// 센서 감지
	}
	else	
	{
		return IO_OFF;	// 센서 미감지
	}
}

//==================================================================//
// 악세사리가 공급 되는 방향에서 Rear Buffer 센서 확인
//==================================================================//
int CSeq_XYZRobot::OnCheck_RearAccySupply(int nzOnOff, int nzMode, int nzSite) 
{
	if (nzSite < SIDE_LEFT_ || nzSite > SIDE_RIGHT_)
	{
		nzSite = SIDE_BOTH_;
	}
	
	int nReadIO[2] = {0,};
	// 센서가 B접이라 센서 상태 확인 시 반전 사용
	nReadIO[0] = !g_ioMgr.get_in_bit(stIO.i_Chk_BufferTryAccyDetection[SIDE_REAR_][SIDE_LEFT_]);
	nReadIO[1] = !g_ioMgr.get_in_bit(stIO.i_Chk_BufferTryAccyDetection[SIDE_REAR_][SIDE_RIGHT_]);
	
	if (nzSite == SIDE_LEFT_)
	{
		// [Right] 센서 입력은 강제로 설정
		nReadIO[1] = nzOnOff;
	}
	else if (nzSite == SIDE_RIGHT_)
	{
		// [Left] 센서 입력은 강제로 설정
		nReadIO[0] = nzOnOff;
	}
	
	if (nzMode == CHK_EXIST_)
	{
		// 현재 WithOut 모드인지 확인
		// - 자재없이 돌리고 있으므로 감지되지 않기 때문에 강제로 설정함
		if (st_basic.n_mode_device == WITHOUT_DVC_)
		{
			if (st_map.nLoadingAccyBoxExist[1] == 0)
			{
				nReadIO[0] = st_map.nBufferCovAccyExist[2];
				nReadIO[1] = st_map.nBufferCovAccyExist[3];
			}
			else
			{
				nReadIO[0] = st_map.nBufferCovAccyExist[2];
				nReadIO[1] = st_map.nBufferCovAccyExist[3];
			}
		}
	}
	
	if (nReadIO[0] == IO_ON && nReadIO[1] == IO_ON)
	{
		return IO_ON;	// 센서 감지
	}
	else	
	{
		return IO_OFF;	// 센서 미감지
	}
}

//==================================================================//
// Gripper에 악세사리 감지 센서 확인
//==================================================================//
int CSeq_XYZRobot::OnCheck_GripperGripAccy0(int nzOnOff, int nzMode) 
{
	int nReadIO[2];
	// 센서 A접
	nReadIO[0] = g_ioMgr.get_in_bit(stIO.i_Chk_GripperAccy[0][SIDE_LEFT_]);
	nReadIO[1] = g_ioMgr.get_in_bit(stIO.i_Chk_GripperAccy[0][SIDE_RIGHT_]);
	
	// 자재 존재하는 경우에 대한 체크인지 확인
	if (nzMode == CHK_EXIST_)
	{
		// 현재 WithOut 모드인지 확인
		// - 자재없이 돌리고 있으므로 감지되지 않기 때문에 강제로 설정함
		if (st_basic.n_mode_device == WITHOUT_DVC_)
		{
			nReadIO[0] = nzOnOff;
			nReadIO[1] = nzOnOff;
		}
	}
	
	if (nReadIO[0] == IO_ON && nReadIO[1] == IO_ON)
	{
		return IO_ON;	// 센서 감지
	}
	else	
	{
		return IO_OFF;	// 센서 미감지
	}
}

//==================================================================//
// Gripper에 악세사리 감지 센서 확인
//==================================================================//
int CSeq_XYZRobot::OnCheck_GripperGripAccy1(int nzOnOff, int nzMode) 
{
	int nReadIO[2];
	// 센서 A접
	nReadIO[0] = g_ioMgr.get_in_bit(stIO.i_Chk_GripperAccy[1][SIDE_LEFT_]);
	nReadIO[1] = g_ioMgr.get_in_bit(stIO.i_Chk_GripperAccy[1][SIDE_RIGHT_]);
	
	// 자재 존재하는 경우에 대한 체크인지 확인
	if (nzMode == CHK_EXIST_)
	{
		// 현재 WithOut 모드인지 확인
		// - 자재없이 돌리고 있으므로 감지되지 않기 때문에 강제로 설정함
		if (st_basic.n_mode_device == WITHOUT_DVC_)
		{
			nReadIO[0] = nzOnOff;
			nReadIO[1] = nzOnOff;
		}
	}
	
	if (nReadIO[0] == IO_ON && nReadIO[1] == IO_ON)
	{
		return IO_ON;	// 센서 감지
	}
	else	
	{
		return IO_OFF;	// 센서 미감지
	}
}

//==================================================================//
// Gripper에 악세사리 감지 센서 확인
//==================================================================//
int CSeq_XYZRobot::OnCheck_GripperGripAccy2(int nzOnOff, int nzMode) 
{
	int nReadIO[2];
	// 센서 A접
	nReadIO[0] = g_ioMgr.get_in_bit(stIO.i_Chk_GripperAccy[2][SIDE_LEFT_]);
	nReadIO[1] = g_ioMgr.get_in_bit(stIO.i_Chk_GripperAccy[2][SIDE_RIGHT_]);
	
	// 자재 존재하는 경우에 대한 체크인지 확인
	if (nzMode == CHK_EXIST_)
	{
		// 현재 WithOut 모드인지 확인
		// - 자재없이 돌리고 있으므로 감지되지 않기 때문에 강제로 설정함
		if (st_basic.n_mode_device == WITHOUT_DVC_)
		{
			nReadIO[0] = nzOnOff;
			nReadIO[1] = nzOnOff;
		}
	}
	
	if (nReadIO[0] == IO_ON && nReadIO[1] == IO_ON)
	{
		return IO_ON;	// 센서 감지
	}
	else	
	{
		return IO_OFF;	// 센서 미감지
	}
}

//==================================================================//
// Gripper에 악세사리 감지 센서 확인
//==================================================================//
int CSeq_XYZRobot::OnCheck_GripperGripAccy3(int nzOnOff, int nzMode) 
{
	int nReadIO[2];
	// 센서 A접
	nReadIO[0] = g_ioMgr.get_in_bit(stIO.i_Chk_GripperAccy[3][SIDE_LEFT_]);
	nReadIO[1] = g_ioMgr.get_in_bit(stIO.i_Chk_GripperAccy[3][SIDE_RIGHT_]);
	
	// 자재 존재하는 경우에 대한 체크인지 확인
	if (nzMode == CHK_EXIST_)
	{
		// 현재 WithOut 모드인지 확인
		// - 자재없이 돌리고 있으므로 감지되지 않기 때문에 강제로 설정함
		if (st_basic.n_mode_device == WITHOUT_DVC_)
		{
			nReadIO[0] = nzOnOff;
			nReadIO[1] = nzOnOff;
		}
	}
	
	if (nReadIO[0] == IO_ON && nReadIO[1] == IO_ON)
	{
		return IO_ON;	// 센서 감지
	}
	else	
	{
		return IO_OFF;	// 센서 미감지
	}
}

// yangkyu [2015.03.05]
// Buffer Conv에 자재를 놓는 함수
int CSeq_XYZRobot::OnProc_BufferPlace()
{
	int nFuncRet = CTL_PROCEED;
	
	int nRet = VAR_INIT_;
	int nRetData[4] = {0,};
	int i = 0, iExist;
	int iCheckCount = 0;
	
	Func.OnTrace_ThreadStep(22, m_nStep_BufferConvPlace);	// 쓰레드 스텝 정보 TRACE

	switch(m_nStep_BufferConvPlace)
	{
	case 0:
		nRet = CTL_Lib.OnSingleMove(m_nMotZ, st_motor[m_nMotZ].d_pos[Z_RBT_SAFETY_], (int)st_handler.md_run_speed);
		if (nRet == CTLBD_RET_GOOD)
		{
			if (st_basic.nMode_GripUsing == GRIP_USING)
			{
				// Grip의 경우 st_map.nXYZRbtPickerInfo에 Accy 유무를 확인
				if (st_map.nXYZRbtPickerInfo[2] == ACCY_YES_ || st_map.nXYZRbtPickerInfo[3] == ACCY_YES_)
				{
					m_nStep_BufferConvPlace = 100;
				}
				else if(st_map.nXYZRbtPickerInfo[0] == ACCY_YES_ || st_map.nXYZRbtPickerInfo[1] == ACCY_YES_)
				{
					m_nStep_BufferConvPlace = 500;
				}
				else
				{
					m_nStep_BufferConvPlace = 1000;
				}
			}
			else if (st_basic.nMode_VacUsing == VAC_USING)
			{
				m_nStep_BufferConvPlace = 10;
			}
		}
		else if (nRet == CTLBD_RET_ERROR || nRet == CTLBD_RET_RETRY)
		{
			// 071005 0 0 "BARCODE_ROBOT_Z_RBT_SAFETY_MOVE_ERR"
			alarm.mstr_code		= "071005";
			alarm.mn_count_mode	= 0;
			alarm.mn_type_mode	= eWARNING;
			st_work.nEqpStatus	= dWARNING;
		}
		break;

		//==========================================================//
		// Vacuum 사용 모드
		//==========================================================//
	case 10:
		for(i=0; i<MAX_PICKER_; i++)
		{
			m_nPicker[TYPE_FLAG_][i] = st_map.nXYZRbtPickerInfo[i];
		}
		m_lTime_GoesBy[0] = GetCurrentTime();
		m_nStep_BufferConvPlace = 20;
		break;

	case 20:
		// 피커의 자재 존재 상태 반환
		nRet = Func.OnGet_PickerStatus(0, CTL_YES, m_nPicker);
		if (nRet == CTL_ERROR)
		{
			m_lTime_GoesBy[1] = GetCurrentTime();
			m_lTime_GoesBy[2] = m_lTime_GoesBy[1] - m_lTime_GoesBy[0];
			if (m_lTime_GoesBy[2] < 0)
			{
				m_lTime_GoesBy[0] = GetCurrentTime();
				break;
			}
			
			if (m_lTime_GoesBy[2] < 10)
			{
				break;
			}
		}
		
		// OnGet_PickerStatus() 함수에서는 [CTL_GOOD/CTL_ERROR] 반환되었을 것임
		if (nRet == CTL_GOOD)
		{
			m_nStep_BufferConvPlace = 50;
		}
		else
		{
			// OnGet_PickerStatus() 함수 안에서 알람 코드 설정됨
			alarm.mn_count_mode	= 0;
			alarm.mn_type_mode	= eWARNING;
			st_work.nEqpStatus	= dWARNING;
		}
		break;

	case 50:
		// 전체 피커 갯수 가운데
		for(i=0; i<MAX_PICKER_; i++)
		{
			m_nPicker[TYPE_FLAG_][i] = CTL_NO;
			
			// 자재 존재 여부를 검사 [구조체 플래그 정보]
			// - 악세사리 내려놓는 동작을 진행할 피커를 설정
			iExist = st_map.nXYZRbtPickerInfo[i];
			if (iExist == CTL_YES)
			{
				m_nPicker[TYPE_FLAG_][i] = CTL_YES;	// 동작할 피커로 설정
			}
		}

		// (m_nPicker[TYPE_FLAG_]에 Accy 유무를 확인
		if (m_nPicker[TYPE_FLAG_][2] == ACCY_YES_ || m_nPicker[TYPE_FLAG_][3] == ACCY_YES_)
		{
			m_nStep_BufferConvPlace = 100;
		}
		else if(m_nPicker[TYPE_FLAG_][0] == ACCY_YES_ || m_nPicker[TYPE_FLAG_][1] == ACCY_YES_)
		{
			m_nStep_BufferConvPlace = 500;
		}
		else
		{
			m_nStep_BufferConvPlace = 1000;
		}
		break;
		//==========================================================//

	case 100:
		// 이동할 모터 위치 설정
		m_dTargetPos = st_motor[m_nMotY].d_pos[Y_RBT_ACC_CONV_R_BUFF_];
		
		nRet = CTL_Lib.OnSingleMove(m_nMotY, m_dTargetPos, (int)st_handler.md_run_speed);
		if (nRet == CTLBD_RET_GOOD)
		{
			if (st_basic.nMode_GripUsing == GRIP_USING)
			{
				// [Conv->Xyz] 악세사리 공급 요청 기다림
				if (stSync.nResp_BufferAlaignConv2XYZRbt_Work == SYNC_RESP_LOADING_)
				{
					m_nStep_BufferConvPlace = 200;
				}
				{
					m_nStep_BufferConvPlace = 150;
				}
			}
			else if (st_basic.nMode_VacUsing == VAC_USING)
			{
				m_lTime_GoesBy[0] = GetCurrentTime();
				m_nStep_BufferConvPlace = 110;
			}
		}
		else if (nRet == CTLBD_RET_ERROR || nRet == CTLBD_RET_RETRY)
		{
			// 051011 0 0 "BARCODE_ROBOT_X_RBT_ACC_BUFFER_CONV_MOVE_ERR"
			alarm.mstr_code		= "051011";
			alarm.mn_count_mode	= 0;
			alarm.mn_type_mode	= eWARNING;
			st_work.nEqpStatus	= dWARNING;
		}
		break;

		//==========================================================//
		// Vacuum 사용 모드
		//==========================================================//
	case 110:
		// 피커의 자재 존재 상태 반환
		nRet = Func.OnGet_PickerStatus(0, CTL_YES, m_nPicker);
		if (nRet == CTL_ERROR)
		{
			m_lTime_GoesBy[1] = GetCurrentTime();
			m_lTime_GoesBy[2] = m_lTime_GoesBy[1] - m_lTime_GoesBy[0];
			if (m_lTime_GoesBy[2] < 0)
			{
				m_lTime_GoesBy[0] = GetCurrentTime();
				break;
			}
			
			if (m_lTime_GoesBy[2] < 10)
			{
				break;
			}
		}
		
		// OnGet_PickerStatus() 함수에서는 [CTL_GOOD/CTL_ERROR] 반환되었을 것임
		if (nRet == CTL_GOOD)
		{
			// [Conv->Xyz] 악세사리 공급 요청 기다림
			if (stSync.nResp_BufferAlaignConv2XYZRbt_Work == SYNC_RESP_LOADING_)
			{
				m_nStep_BufferConvPlace = 200;
			}
			else
			{
				m_nStep_BufferConvPlace = 150;
			}
		}
		else
		{
			// OnGet_PickerStatus() 함수 안에서 알람 코드 설정됨
			alarm.mn_count_mode	= 0;
			alarm.mn_type_mode	= eWARNING;
			st_work.nEqpStatus	= dWARNING;
		}
		break;
		//==========================================================//

	case 150:
		// [Conv->Xyz] 악세사리 공급 요청 기다림
		if (stSync.nResp_BufferAlaignConv2XYZRbt_Work == SYNC_RESP_LOADING_)
		{
			m_nStep_BufferConvPlace = 200;
		}
		else
		{
			m_nStep_BufferConvPlace = 160;

		}
		break;

	case 160:
		// Conv에 악세사리 내려놓는 시간을 줄이기 위하여 특정 위치까지 강제로 내림
		m_dTargetPos = st_motor[m_nMotZ].d_pos[Z_RBT_ACC_BUFFER_CONV_PLACE_] -40;

		nRet = CTL_Lib.OnSingleMove(m_nMotZ, m_dTargetPos, (int)st_handler.md_run_speed);
		if (nRet == CTLBD_RET_GOOD)
		{
			m_nStep_BufferConvPlace = 170;
		}
		else if (nRet == CTLBD_RET_ERROR || nRet == CTLBD_RET_RETRY)
		{
			// 071005 0 0 "BARCODE_ROBOT_Z_RBT_SAFETY_MOVE_ERR"
			alarm.mstr_code		= "071005";
			alarm.mn_count_mode	= 0;
			alarm.mn_type_mode	= eWARNING;
			st_work.nEqpStatus	= dWARNING;
		}
		break;

	case 170:
		// [Conv->Xyz] 악세사리 공급 요청 기다림
		if (stSync.nResp_BufferAlaignConv2XYZRbt_Work == SYNC_RESP_LOADING_)
		{
			m_nStep_BufferConvPlace = 200;
		}
		break;

	case 200:
		// 악세사리 내려놓는 위치로 Z축 모터 이동
		nRet = CTL_Lib.OnSingleMove(m_nMotZ, st_motor[m_nMotZ].d_pos[Z_RBT_ACC_BUFFER_CONV_PLACE_], (int)st_handler.md_run_speed);
		if (nRet == CTLBD_RET_GOOD)
		{
			if (st_basic.nMode_GripUsing == GRIP_USING)
			{
				m_nStep_BufferConvPlace = 300;	// Grip 사용 모드
			}
			else if (st_basic.nMode_VacUsing == VAC_USING)
			{
				m_nStep_BufferConvPlace = 400;	// Vacuum 사용 모드
			}
		}
		else if (nRet == CTLBD_RET_ERROR || nRet == CTLBD_RET_RETRY)
		{
			// 071004 0 0 "BARCODE_ROBOT_Z_RBT_ACC_BUFFER_CONV_MOVE_ERR"
			alarm.mstr_code		= "071004";
			alarm.mn_count_mode	= 0;
			alarm.mn_type_mode	= eWARNING;
			st_work.nEqpStatus	= dWARNING;
		}
		break;

		// 그립퍼 사용 시 처리 스텝
	case 300:
		// [0],[1],[2],[3] Grip Off
		nRet = OnProc_Grip(12, IO_OFF);
		if (nRet == CTLBD_RET_GOOD)
		{
			for(i=2; i<MAX_PICKER_; i++)
			{
				if (st_basic.n_mode_device == WITHOUT_DVC_)
				{
					stWithoutData.nBufferConv[i] = st_map.nBCR_State[i];
				}
				
				st_map.nBufferCovAccyExist[i] = st_map.nBCR_State[i];
				if (st_map.nBCR_State[i] == BCR_READ_GOOD_)
				{
					st_work.sBufferConvBCR_Data[i] = st_work.sRbtBCR_Data[i];
					st_work.sRbtBCR_Data[i] = "";
				}
			}

			if (st_handler.cwnd_main != NULL)
			{
				st_handler.cwnd_main->PostMessage(WM_UPDATE_MAIN, PLACE_BUFFER_CONV_);	// 화면 표시 요청
			}
			m_nStep_BufferConvPlace = 500;
		}
		break;

		//==========================================================//
		// Vacuum 사용 모드
		//==========================================================//
	case 400:
		// 전체 피커 갯수 가운데
		for(i=0; i<MAX_PICKER_; i++)
		{
			m_nPicker[TYPE_FLAG_][i] = CTL_NO;

			// 자재 존재 여부를 검사 [구조체 플래그 정보]
			// - 악세사리 내려놓는 동작을 진행할 피커를 설정
			iExist = st_map.nBCR_State[i];
			if (iExist == BCR_READ_GOOD_)
			{
				// Rear 부분만 동작하도록 함.
				if (i > 1)
				{
					m_nPicker[TYPE_FLAG_][i] = CTL_YES;	// 동작할 피커로 설정
				}
			}
		}
		m_nStep_BufferConvPlace = 430;
		break;

	case 430:
		OnSet_SolVacuum(IO_OFF, m_nPicker[TYPE_FLAG_]);	// 그립퍼 Vacuum [ON:진공설정, OFF:진공해제]
		m_nStep_BufferConvPlace = 450;
		break;

	case 450:
		nRet = OnGet_SolVacuum(IO_OFF, m_nPicker[TYPE_FLAG_], m_nPicker[TYPE_SEN_]);
		// 어찌되었던 동작이 완료될때까지 대기
		// - 피커를 들고 알람을 출력시키기 위함
		if (nRet == CTL_GOOD || nRet == CTL_ERROR)
		{
			m_nStep_BufferConvPlace = 460;
		}
		break;

	case 460:
		// 그립퍼의 악세사리 존재 여부 확인
		// - 악세사리를 Conv에 내려놓았으므로 감지되면 안됨
		// - m_nPicker : [case 400:]에서 설정됨
		nRet = Func.OnGet_PickerStatus(0, CTL_NO, m_nPicker);
		if (nRet == CTL_ERROR)
		{
			m_lTime_GoesBy[1] = GetCurrentTime();
			m_lTime_GoesBy[2] = m_lTime_GoesBy[1] - m_lTime_GoesBy[0];
			if (m_lTime_GoesBy[2] < 0)
			{
				m_lTime_GoesBy[0] = GetCurrentTime();
				break;
			}
			
			if (m_lTime_GoesBy[2] > 10)
			{
				// OnGet_PickerStatus() 함수 안에서 알람 코드 설정됨
				alarm.mn_count_mode	= 0;
				alarm.mn_type_mode	= eWARNING;
				st_work.nEqpStatus	= dWARNING;
			}
			break;
		}

		// 전체 피커 갯수 가운데
		for(i=2; i<MAX_PICKER_; i++)
		{
			// 악세사리 내려놓기 동작을 한 피커에 한해서 실재로 자재를 내려놓은 경우 (센서에 미감지)
			if (m_nPicker[TYPE_FLAG_][i] == CTL_YES && m_nPicker[TYPE_SEN_][i] == CTL_NO)
			{
				// 그립퍼의 구조체 정보 갱신 [자재 지었음]
				st_map.nXYZRbtPickerInfo[i]	= CTL_NO;

				// 위 스텝에서 다시 초기화 시킨 후 재설정하기 때문에 필요는 없지만..
				m_nPicker[TYPE_FLAG_][i]	= CTL_NO;
			}

			if (st_basic.n_mode_device == WITHOUT_DVC_)
			{
				stWithoutData.nBufferConv[i] = st_map.nBCR_State[i];
			}
			
			st_map.nBufferCovAccyExist[i] = st_map.nBCR_State[i];
			if (st_map.nBCR_State[i] == BCR_READ_GOOD_)
			{
				st_work.sBufferConvBCR_Data[i] = st_work.sRbtBCR_Data[i];
				st_work.sRbtBCR_Data[i] = "";
			}
		}

		if (st_handler.cwnd_main != NULL)
		{
			st_handler.cwnd_main->PostMessage(WM_UPDATE_MAIN, PLACE_BUFFER_CONV_);	// 화면 표시 요청
		}
		m_nStep_BufferConvPlace = 500;
		break;
		//==========================================================//

	case 500:
		// Front 위치에 악세사리 내려놓는 시간을 줄이기 위하여 Z_RBT_ACC_BUFFER_CONV_PLACE_ - 40 위치까지 올림
		m_dTargetPos = st_motor[m_nMotZ].d_pos[Z_RBT_ACC_BUFFER_CONV_PLACE_] -40;

		nRet = CTL_Lib.OnSingleMove(m_nMotZ, m_dTargetPos, (int)st_handler.md_run_speed);
		if (nRet == CTLBD_RET_GOOD)
		{
			if (st_basic.nMode_GripUsing == GRIP_USING)
			{
				if(st_map.nXYZRbtPickerInfo[0] == ACCY_YES_ || st_map.nXYZRbtPickerInfo[1] == ACCY_YES_)
				{
					m_nStep_BufferConvPlace = 600;
				}
				else
				{
					m_nStep_BufferConvPlace = 1000;
				}
			}
			else if (st_basic.nMode_VacUsing == VAC_USING)
			{
				m_lTime_GoesBy[0] = GetCurrentTime();
				m_nStep_BufferConvPlace = 510;	// Vacuum 사용 모드
			}
		}
		else if (nRet == CTLBD_RET_ERROR || nRet == CTLBD_RET_RETRY)
		{
			// 071005 0 0 "BARCODE_ROBOT_Z_RBT_SAFETY_MOVE_ERR"
			alarm.mstr_code		= "071005";
			alarm.mn_count_mode	= 0;
			alarm.mn_type_mode	= eWARNING;
			st_work.nEqpStatus	= dWARNING;
		}
		break;

		//==========================================================//
		// Vacuum 사용 모드
		//==========================================================//
	case 510:
		for(i=0; i<MAX_PICKER_; i++)
		{
			m_nPicker[TYPE_FLAG_][i] = st_map.nXYZRbtPickerInfo[i];
		}
		m_lTime_GoesBy[0] = GetCurrentTime();
		m_nStep_BufferConvPlace = 520;
		break;

	case 520:
		// 피커의 자재 존재 상태 반환
		nRet = Func.OnGet_PickerStatus(0, CTL_YES, m_nPicker);
		if (nRet == CTL_ERROR)
		{
			m_lTime_GoesBy[1] = GetCurrentTime();
			m_lTime_GoesBy[2] = m_lTime_GoesBy[1] - m_lTime_GoesBy[0];
			if (m_lTime_GoesBy[2] < 0)
			{
				m_lTime_GoesBy[0] = GetCurrentTime();
				break;
			}
			
			if (m_lTime_GoesBy[2] < 10)
			{
				break;
			}
		}
		
		// OnGet_PickerStatus() 함수에서는 [CTL_GOOD/CTL_ERROR] 반환되었을 것임
		if (nRet == CTL_GOOD)
		{
			m_nStep_BufferConvPlace = 550;
		}
		else
		{
			// OnGet_PickerStatus() 함수 안에서 알람 코드 설정됨
			alarm.mn_count_mode	= 0;
			alarm.mn_type_mode	= eWARNING;
			st_work.nEqpStatus	= dWARNING;
		}
		break;

	case 550:
		// 전체 피커 갯수 가운데
		for(i=0; i<MAX_PICKER_; i++)
		{
			m_nPicker[TYPE_FLAG_][i] = CTL_NO;
			
			// 자재 존재 여부를 검사 [구조체 플래그 정보]
			// - 악세사리 내려놓는 동작을 진행할 피커를 설정
			iExist = st_map.nXYZRbtPickerInfo[i];
			if (iExist == CTL_YES)
			{
				// Front 부분만 동작하도록 함.
				if (i < 2)
				{
					m_nPicker[TYPE_FLAG_][i] = CTL_YES;	// 동작할 피커로 설정
				}
			}
		}
		if(m_nPicker[TYPE_FLAG_][0] == ACCY_YES_ || m_nPicker[TYPE_FLAG_][1] == ACCY_YES_)
		{
			m_nStep_BufferConvPlace = 600;
		}
		else
		{
			m_nStep_BufferConvPlace = 1000;
		}
		break;
		//==========================================================//

	case 600:
		// 이동할 모터 위치 설정
		m_dTargetPos = st_motor[m_nMotY].d_pos[Y_RBT_ACC_CONV_F_BUFF_];
		
		nRet = CTL_Lib.OnSingleMove(m_nMotY, m_dTargetPos, (int)st_handler.md_run_speed);
		if (nRet == CTLBD_RET_GOOD)
		{
			if (st_basic.nMode_GripUsing == GRIP_USING)
			{
				// [Conv->Xyz] 악세사리 공급 요청 기다림
				if (stSync.nResp_BufferAlaignConv2XYZRbt_Work == SYNC_RESP_LOADING_)
				{
					m_nStep_BufferConvPlace = 800;
				}
				else
				{
					m_nStep_BufferConvPlace = 650;
				}
			}
			else if (st_basic.nMode_VacUsing == VAC_USING)
			{
				m_lTime_GoesBy[0] = GetCurrentTime();
				m_nStep_BufferConvPlace = 610;	// Vacuum 사용 모드
			}
		}
		else if (nRet == CTLBD_RET_ERROR || nRet == CTLBD_RET_RETRY)
		{
			// 051011 0 0 "BARCODE_ROBOT_X_RBT_ACC_BUFFER_CONV_MOVE_ERR"
			alarm.mstr_code		= "051011";
			alarm.mn_count_mode	= 0;
			alarm.mn_type_mode	= eWARNING;
			st_work.nEqpStatus	= dWARNING;
		}
		break;
	
		//==========================================================//
		// Vacuum 사용 모드
		//==========================================================//
	case 610:
		// 피커의 자재 존재 상태 반환
		nRet = Func.OnGet_PickerStatus(0, CTL_YES, m_nPicker);
		if (nRet == CTL_ERROR)
		{
			m_lTime_GoesBy[1] = GetCurrentTime();
			m_lTime_GoesBy[2] = m_lTime_GoesBy[1] - m_lTime_GoesBy[0];
			if (m_lTime_GoesBy[2] < 0)
			{
				m_lTime_GoesBy[0] = GetCurrentTime();
				break;
			}
			
			if (m_lTime_GoesBy[2] < 10)
			{
				break;
			}
		}
		
		// OnGet_PickerStatus() 함수에서는 [CTL_GOOD/CTL_ERROR] 반환되었을 것임
		if (nRet == CTL_GOOD)
		{
			// [Conv->Xyz] 악세사리 공급 요청 기다림
			if (stSync.nResp_BufferAlaignConv2XYZRbt_Work == SYNC_RESP_LOADING_)
			{
				m_nStep_BufferConvPlace = 800;
			}
			else
			{
				m_nStep_BufferConvPlace = 650;
			}
		}
		else
		{
			// OnGet_PickerStatus() 함수 안에서 알람 코드 설정됨
			alarm.mn_count_mode	= 0;
			alarm.mn_type_mode	= eWARNING;
			st_work.nEqpStatus	= dWARNING;
		}
		break;
		//==========================================================//

	case 650:
		// [Conv->Xyz] 악세사리 공급 요청 기다림
		if (stSync.nResp_BufferAlaignConv2XYZRbt_Work == SYNC_RESP_LOADING_)
		{
			m_nStep_BufferConvPlace = 800;
		}
		else
		{
			m_nStep_BufferConvPlace = 760;

		}
		break;

	case 760:
		// Conv에 악세사리 내려놓는 시간을 줄이기 위하여 특정 위치까지 강제로 내림
		m_dTargetPos = st_motor[m_nMotZ].d_pos[Z_RBT_ACC_BUFFER_CONV_PLACE_] -40;

		nRet = CTL_Lib.OnSingleMove(m_nMotZ, m_dTargetPos, (int)st_handler.md_run_speed);
		if (nRet == CTLBD_RET_GOOD)
		{
			m_nStep_BufferConvPlace = 770;
		}
		else if (nRet == CTLBD_RET_ERROR || nRet == CTLBD_RET_RETRY)
		{
			// 071005 0 0 "BARCODE_ROBOT_Z_RBT_SAFETY_MOVE_ERR"
			alarm.mstr_code		= "071005";
			alarm.mn_count_mode	= 0;
			alarm.mn_type_mode	= eWARNING;
			st_work.nEqpStatus	= dWARNING;
		}
		break;

	case 770:
		// [Conv->Xyz] 악세사리 공급 요청 기다림
		if (stSync.nResp_BufferAlaignConv2XYZRbt_Work == SYNC_RESP_LOADING_)
		{
			m_nStep_BufferConvPlace = 800;
		}
		break;

	case 800:
		// 악세사리 내려놓는 위치로 Z축 모터 이동
		nRet = CTL_Lib.OnSingleMove(m_nMotZ, st_motor[m_nMotZ].d_pos[Z_RBT_ACC_BUFFER_CONV_PLACE_], (int)st_handler.md_run_speed);
		if (nRet == CTLBD_RET_GOOD)
		{
			if (st_basic.nMode_GripUsing == GRIP_USING)
			{
				m_nStep_BufferConvPlace = 850;	// Grip 사용 모드
			}
			else if (st_basic.nMode_VacUsing == VAC_USING)
			{
				m_nStep_BufferConvPlace = 900;	// Vacuum 사용 모드
			}
		}
		else if (nRet == CTLBD_RET_ERROR || nRet == CTLBD_RET_RETRY)
		{
			// 071004 0 0 "BARCODE_ROBOT_Z_RBT_ACC_BUFFER_CONV_MOVE_ERR"
			alarm.mstr_code		= "071004";
			alarm.mn_count_mode	= 0;
			alarm.mn_type_mode	= eWARNING;
			st_work.nEqpStatus	= dWARNING;
		}
		break;

	case 850:
		// [0],[1],[2],[3] Grip Off
		nRet = OnProc_Grip(3, IO_OFF);
		if (nRet == CTLBD_RET_GOOD)
		{
			for(i=0; i<2; i++)
			{
				if (st_basic.n_mode_device == WITHOUT_DVC_)
				{
					stWithoutData.nBufferConv[i] = st_map.nBCR_State[i];
				}
				
				st_map.nBufferCovAccyExist[i] = st_map.nBCR_State[i];
				if (st_map.nBCR_State[i] == BCR_READ_GOOD_)
				{
					st_work.sBufferConvBCR_Data[i] = st_work.sRbtBCR_Data[i];
					st_work.sRbtBCR_Data[i] = "";
				}
			}

			if (st_handler.cwnd_main != NULL)
			{
				st_handler.cwnd_main->PostMessage(WM_UPDATE_MAIN, PLACE_BUFFER_CONV_);	// 화면 표시 요청
			}
			m_nStep_BufferConvPlace = 1000;
		}
		break;

		//==========================================================//
		// Vacuum 사용 모드
		//==========================================================//
	case 900:
		// 전체 피커 갯수 가운데
		for(i=0; i<MAX_PICKER_; i++)
		{
			m_nPicker[TYPE_FLAG_][i] = CTL_NO;

			// 자재 존재 여부를 검사 [구조체 플래그 정보]
			// - 악세사리 내려놓는 동작을 진행할 피커를 설정
			iExist = st_map.nBCR_State[i];
			if (iExist == BCR_READ_GOOD_)
			{
				// Front 부분만 동작하도록 함.
				if (i < 2)
				{
					m_nPicker[TYPE_FLAG_][i] = CTL_YES;	// 동작할 피커로 설정
				}
			}
		}
		m_nStep_BufferConvPlace = 930;
		break;

	case 930:
		OnSet_SolVacuum(IO_OFF, m_nPicker[TYPE_FLAG_]);	// 그립퍼 Vacuum [ON:진공설정, OFF:진공해제]
		m_nStep_BufferConvPlace = 950;
		break;

	case 950:
		nRet = OnGet_SolVacuum(IO_OFF, m_nPicker[TYPE_FLAG_], m_nPicker[TYPE_SEN_]);
		// 어찌되었던 동작이 완료될때까지 대기
		// - 피커를 들고 알람을 출력시키기 위함
		if (nRet == CTL_GOOD || nRet == CTL_ERROR)
		{
			m_nStep_BufferConvPlace = 960;
		}
		break;

	case 960:
		// 그립퍼의 악세사리 존재 여부 확인
		// - 악세사리를 Conv에 내려놓았으므로 감지되면 안됨
		// - m_nPicker : [case 400:]에서 설정됨
		nRet = Func.OnGet_PickerStatus(0, CTL_NO, m_nPicker);
		if (nRet == CTL_ERROR)
		{
			m_lTime_GoesBy[1] = GetCurrentTime();
			m_lTime_GoesBy[2] = m_lTime_GoesBy[1] - m_lTime_GoesBy[0];
			if (m_lTime_GoesBy[2] < 0)
			{
				m_lTime_GoesBy[0] = GetCurrentTime();
				break;
			}
			
			if (m_lTime_GoesBy[2] > 10)
			{
				// OnGet_PickerStatus() 함수 안에서 알람 코드 설정됨
				alarm.mn_count_mode	= 0;
				alarm.mn_type_mode	= eWARNING;
				st_work.nEqpStatus	= dWARNING;
			}
			break;
		}

		// 전체 피커 갯수 가운데
		for(i=0; i<2; i++)
		{
			// 악세사리 내려놓기 동작을 한 피커에 한해서 실재로 자재를 내려놓은 경우 (센서에 미감지)
			if (m_nPicker[TYPE_FLAG_][i] == CTL_YES && m_nPicker[TYPE_SEN_][i] == CTL_NO)
			{
				// 그립퍼의 구조체 정보 갱신 [자재 지었음]
				st_map.nXYZRbtPickerInfo[i]	= CTL_NO;

				// 위 스텝에서 다시 초기화 시킨 후 재설정하기 때문에 필요는 없지만..
				m_nPicker[TYPE_FLAG_][i]	= CTL_NO;
			}

			if (st_basic.n_mode_device == WITHOUT_DVC_)
			{
				stWithoutData.nBufferConv[i] = st_map.nBCR_State[i];
			}
			
			st_map.nBufferCovAccyExist[i] = st_map.nBCR_State[i];
			if (st_map.nBCR_State[i] == BCR_READ_GOOD_)
			{
				st_work.sBufferConvBCR_Data[i] = st_work.sRbtBCR_Data[i];
				st_work.sRbtBCR_Data[i] = "";
			}
		}

		if (st_handler.cwnd_main != NULL)
		{
			st_handler.cwnd_main->PostMessage(WM_UPDATE_MAIN, PLACE_BUFFER_CONV_);	// 화면 표시 요청
		}
		m_nStep_BufferConvPlace = 1000;
		break;
		//==========================================================//

	case 1000:
		// 규이리 수정 [2015.03.25]
		m_nStep_BufferConvPlace = 0;
		nFuncRet = CTL_GOOD;
		break;
	}

	return nFuncRet;
}

// yangkyu [2015.03.10]
//////////////////////////////////////////////////////////////////////////
// Grip 을 이용하여 자재를 짚는 함수
//////////////////////////////////////////////////////////////////////////
int CSeq_XYZRobot::OnProc_AccyGripPick()
{
	int nFuncRet = CTL_PROCEED;
	
	int nRet = VAR_INIT_;
	int nRetData[4] = {0,};
	int i = 0;
	int iCheckCount = 0;

	switch(m_nStep_AccyGripPick)
	{
	case 0:
		nRet = CTL_Lib.OnSingleMove(m_nMotZ, st_motor[m_nMotZ].d_pos[Z_RBT_SAFETY_], (int)st_handler.md_run_speed);
		if (nRet == CTLBD_RET_GOOD)
		{
			m_nStep_AccyGripPick = 10;
		}
		else if (nRet == CTLBD_RET_ERROR || nRet == CTLBD_RET_RETRY)
		{
			// 071005 0 0 "BARCODE_ROBOT_Z_RBT_SAFETY_MOVE_ERR"
			alarm.mstr_code		= "071005";
			alarm.mn_count_mode	= 0;
			alarm.mn_type_mode	= eWARNING;
			st_work.nEqpStatus	= dWARNING;
		}
		break;

	case 10:
		nRet = CTL_Lib.OnSingleMove(m_nMotY, st_motor[m_nMotY].d_pos[Y_RBT_ACC_GRIP_FRONT_ + st_map.nLiftWorkSite], (int)st_handler.md_run_speed);
		
		if(nRet == CTLBD_RET_GOOD)
		{
			m_nStep_AccyGripPick = 100;
		}
		else if (nRet == CTLBD_RET_ERROR || nRet == CTLBD_RET_RETRY)
		{
			// 051005 0 00 "BARCODE_ROBOT_Y_RBT_ACC_GRIP_FRONT_MOVE_ERR."
			// 051006 0 00 "BARCODE_ROBOT_Y_RBT_ACC_GRIP_REAR_MOVE_ERR."
			alarm.mstr_code.Format("05100%d", 5 + st_map.nLiftWorkSite);
			alarm.mn_count_mode	= 0;
			alarm.mn_type_mode	= eWARNING;
			st_work.nEqpStatus	= dWARNING;
		}
		break;

		//==========================================================//
		// Grip 사용 모드
		//==========================================================//
	case 100:
		// [0],[1],[2],[3] Grip Off
		nRet = OnProc_Grip(15, IO_OFF);
		
		if (nRet == CTLBD_RET_GOOD)
		{
			m_nStep_AccyGripPick = 200;
		}
		break;

	case 200:
		nRet = CTL_Lib.OnSingleMove(m_nMotZ, st_motor[m_nMotZ].d_pos[Z_RBT_ACC_GRIP_], (int)st_handler.md_run_speed);
		if (nRet == CTLBD_RET_GOOD)
		{
			m_nStep_AccyGripPick = 300;
		}
		else if (nRet == CTLBD_RET_ERROR || nRet == CTLBD_RET_RETRY)
		{
			// 071000 0 00 "BARCODE_ROBOT_Z_RBT_ACC_GRIP_MOVE_ERR."
			alarm.mstr_code		= "071000";
			alarm.mn_count_mode	= 0;
			alarm.mn_type_mode	= eWARNING;
			st_work.nEqpStatus	= dWARNING;
		}
		break;

	case 300:
		// Gripper Grip 센서 확인
		nRetData[0] = OnCheck_GripperGripAccy0(IO_ON);
		nRetData[1] = OnCheck_GripperGripAccy1(IO_ON);
		nRetData[2] = OnCheck_GripperGripAccy2(IO_ON);
		nRetData[3] = OnCheck_GripperGripAccy3(IO_ON);
		
		// yangkyu [2015.03.10]
		// - 자재없이 돌리고 있으므로 감지되지 않기 때문에 강제로 설정함
		if (st_basic.n_mode_device == WITHOUT_DVC_)
		{
			nRetData[0] = IO_ON;
			nRetData[1] = IO_ON;
			nRetData[2] = IO_ON;
			nRetData[3] = IO_ON;
		}

		if (nRetData[0] == IO_ON && nRetData[1] == IO_ON &&
			nRetData[2] == IO_ON && nRetData[3] == IO_ON)
		{
			m_nStep_AccyGripPick = 400;
		}
		// 센서 상태가 들어 오지 않을 경우 Grip Retry 수행
		else
		{
			memset(dAccyLiftPos, 0, sizeof(dAccyLiftPos));
			m_nStep_AccyGripPick = 310;
		}
		break;

		// 센서 상태가 들어 오지 않을 경우 Grip Retry 
	case 310:
		// 규이리 수정 [2015.03.25]
		nRet = OnProc_GripRetry(0);
		if (nRet == CTL_GOOD)
		{
			memset(dAccyLiftPos, 0, sizeof(dAccyLiftPos));
			m_nGripRetryCnt = 0;

			m_nStep_AccyGripPick = 300;
		}
		else if (nRet == CTL_ERROR)
		{
			nFuncRet = CTL_ERROR;

			stSync.nResp_XYZRbt2Lifter_Work = SYNC_RESP_PASS_;
			m_nGripRetryCnt = 0;
		}
		break;

	case 400:
		// [0],[1],[2],[3] Grip On
		nRet = OnProc_Grip(15, IO_ON);
		
		if (nRet == CTLBD_RET_GOOD)
		{
			m_nStep_AccyGripPick = 500;
		}
		break;

	case 500:
		nRet = CTL_Lib.OnSingleMove(m_nMotZ, st_motor[m_nMotZ].d_pos[Z_RBT_SAFETY_], (int)st_handler.md_run_speed);
		
		if (nRet == CTLBD_RET_GOOD)
		{
			stSync.nResp_XYZRbt2Lifter_Work = SYNC_RESP_WORK_COMPLETE_;
			m_nStep_AccyGripPick = 1000;
		}
		else if (nRet == CTLBD_RET_ERROR || nRet == CTLBD_RET_RETRY)
		{
			// 071005 0 0 "BARCODE_ROBOT_Z_RBT_SAFETY_MOVE_ERR"
			alarm.mstr_code		= "071005";
			alarm.mn_count_mode	= 0;
			alarm.mn_type_mode	= eWARNING;
			st_work.nEqpStatus	= dWARNING;
		}
		break;

	case 1000:
		// [Box Lifter -> XYZRbt] 리셋 요청 대기
		if(stSync.nReq_Lifter2XYZRbt_Work == SYNC_REQ_RESET_)
		{
			stSync.nResp_XYZRbt2Lifter_Work = SYNC_RESP_RESET_;
			nFuncRet = CTL_GOOD;
			m_nStep_AccyGripPick = 0;
		}
		break;

	}
	
	return nFuncRet;
}

// yangkyu [2015.03.10]
//////////////////////////////////////////////////////////////////////////
// Vacuum 을 이용하여 자재를 짚는 함수
//////////////////////////////////////////////////////////////////////////
int CSeq_XYZRobot::OnProc_AccyVacPick()
{
	int nFuncRet = CTL_PROCEED;
	
	int nRet = VAR_INIT_;
	int nRetData[4] = {0,};
	int i = 0;
	int iCheckCount = 0;

	switch(m_nStep_AccyVacPick)
	{
		// KILEE [2015.03.23]
	case 0:
		// Z축 모터 안전 위치로 이동
		nRet = CTL_Lib.OnSingleMove(m_nMotZ, st_motor[m_nMotZ].d_pos[Z_RBT_SAFETY_], (int)st_handler.md_run_speed);
		if (nRet == CTLBD_RET_GOOD)
		{
			m_nStep_AccyVacPick = 10;
		}
		else if (nRet == CTLBD_RET_ERROR || nRet == CTLBD_RET_RETRY)
		{
			// 071005 0 0 "BARCODE_ROBOT_Z_RBT_SAFETY_MOVE_ERR"
			alarm.mstr_code		= "071005";
			alarm.mn_count_mode	= 0;
			alarm.mn_type_mode	= eWARNING;
			st_work.nEqpStatus	= dWARNING;
		}
		break;

		// 규이리 추가 [2015.03.25]
	case 10:
		for(i=0; i<MAX_PICKER_; i++)
		{
			m_nPicker[TYPE_FLAG_][i] = CTL_YES;	// 동작할 Vacuum으로 설정
		}

		// 시간이 경과된 후에 트레이 감지될 수 있으므로 다시 검사
		m_lTime_GoesBy[0] = GetCurrentTime();
		m_nStep_AccyVacPick = 20;
		break;

		// 규이리 추가[2015.03.25]
	case 20:
		nRet = Func.OnGet_PickerStatus(0, CTL_NO, m_nPicker);
		if (nRet == CTL_ERROR)
		{
			m_lTime_GoesBy[1] = GetCurrentTime();
			m_lTime_GoesBy[2] = m_lTime_GoesBy[1] - m_lTime_GoesBy[0];
			if (m_lTime_GoesBy[2] < 0)
			{
				m_lTime_GoesBy[0] = GetCurrentTime();
				break;
			}
			
			if (m_lTime_GoesBy[2] > 10)
			{
				// OnGet_PickerStatus() 함수 안에서 알람 코드 설정됨
				alarm.mn_count_mode	= 0;
				alarm.mn_type_mode	= eWARNING;
				st_work.nEqpStatus	= dWARNING;
			}
			break;
		}
		m_nStep_AccyVacPick = 50;
		break;

	case 50:
		// 기본을 Y_RBT_ACC_GRIP_FRONT_로 하며, 작업 위치에 따라 이동을 하도록 수정
		nRet = CTL_Lib.OnSingleMove(m_nMotY, st_motor[m_nMotY].d_pos[Y_RBT_ACC_GRIP_FRONT_ + st_map.nLiftWorkSite], (int)st_handler.md_run_speed);
		if(nRet == CTLBD_RET_GOOD)
		{
			//m_nStep_AccyVacPick = 100;
			// 규이리 수정 [2015.03.25]
			m_nStep_AccyVacPick = 200;
		}
		else if (nRet == CTLBD_RET_ERROR || nRet == CTLBD_RET_RETRY)
		{
			// 051005 0 00 "BARCODE_ROBOT_Y_RBT_ACC_GRIP_FRONT_MOVE_ERR."
			// 051006 0 00 "BARCODE_ROBOT_Y_RBT_ACC_GRIP_REAR_MOVE_ERR."
			alarm.mstr_code.Format("05100%d", 5 + st_map.nLiftWorkSite);
			alarm.mn_count_mode	= 0;
			alarm.mn_type_mode	= eWARNING;
			st_work.nEqpStatus	= dWARNING;
		}
		break;

	case 200:
		nRet = COMI.Start_SingleMove(m_nMotZ, st_motor[m_nMotZ].d_pos[Z_RBT_ACC_GRIP_], (int)st_handler.md_run_speed);
		if (nRet == CTLBD_RET_GOOD)
		{
			// 동작 상 무리가 없어 보이고 동작 시간 줄이기 위해 이곳에서 동작시킴
			// - m_nPicker[FLAG_INFO] : [case 100:]에서 설정됨
			OnSet_SolVacuum(IO_ON, m_nPicker[TYPE_FLAG_]);	// 그립퍼 Vacuum [ON:진공설정, OFF:진공해제]
			m_nStep_AccyVacPick = 210;
		}
		else if (nRet == CTLBD_RET_ERROR || nRet == CTLBD_RET_RETRY)
		{
			// 071000 0 0 "BARCODE_ROBOT_Z_RBT_ACC_GRIP_MOVE_ERR"
			alarm.mstr_code		= "071000";
			alarm.mn_count_mode	= 0;
			alarm.mn_type_mode	= eWARNING;
			st_work.nEqpStatus	= dWARNING;
		}
		break;

	case 210:
		nRet = COMI.Check_SingleMove(m_nMotZ, st_motor[m_nMotZ].d_pos[Z_RBT_ACC_GRIP_]);
		if (nRet == CTLBD_RET_GOOD)
		{
			//OnSet_SolVacuum(IO_ON, m_nPicker[TYPE_FLAG_]);	// 그립퍼 Vacuum [ON:진공설정, OFF:진공해제]
			m_nStep_AccyVacPick = 300;
		}
		else if (nRet == CTLBD_RET_ERROR || nRet == CTLBD_RET_SAFETY)
		{
			m_nStep_AccyVacPick = 200;
			
			// 071000 0 00 "BARCODE_ROBOT_Z_RBT_ACC_GRIP_MOVE_ERR."
			alarm.mstr_code		= "071000";
			alarm.mn_count_mode	= 0;
			alarm.mn_type_mode	= eWARNING;
			st_work.nEqpStatus	= dWARNING;
		}
		else if (nRet == CTLBD_RET_RETRY)
		{
			m_nStep_AccyVacPick = 200;
		}
		break;

	case 300: 
		nRetData[0] = g_ioMgr.get_in_bit(stIO.i_Chk_GripRbt_VacOn[SIDE_FRONT_][SIDE_LEFT_]);
		nRetData[1] = g_ioMgr.get_in_bit(stIO.i_Chk_GripRbt_VacOn[SIDE_FRONT_][SIDE_RIGHT_]);
		nRetData[2] = g_ioMgr.get_in_bit(stIO.i_Chk_GripRbt_VacOn[SIDE_REAR_][SIDE_LEFT_]);
		nRetData[3] = g_ioMgr.get_in_bit(stIO.i_Chk_GripRbt_VacOn[SIDE_REAR_][SIDE_RIGHT_]);

		if (st_basic.n_mode_device == WITHOUT_DVC_)
		{
			m_nStep_AccyVacPick = 500;
			break;
		}
		if (nRetData[0] == IO_ON && nRetData[1] == IO_ON && nRetData[2] == IO_ON && nRetData[3] == IO_ON )
		{
			m_nStep_AccyVacPick = 500;
		}
		else
		{
			memset(dAccyLiftPos, 0, sizeof(dAccyLiftPos));
			m_nStep_AccyVacPick = 310;
		}
		break;

		// 센서에 악세사리 감지되지 않은 포켓에 대해서 리프터 Up 시킴
	case 310:
		nRet = OnProc_GripRetry(1);
		if (nRet == CTL_GOOD)
		{
			memset(dAccyLiftPos, 0, sizeof(dAccyLiftPos));
			m_nGripRetryCnt = 0;
			m_nStep_AccyVacPick = 300;
		}
		else if (nRet == CTL_ERROR)
		{
			nFuncRet = CTL_ERROR;

			stSync.nResp_XYZRbt2Lifter_Work = SYNC_RESP_PASS_;
			m_nGripRetryCnt = 0;
			m_nStep_AccyVacPick = 0;
		}
		break;

	case 500:
		nRet = CTL_Lib.OnSingleMove(m_nMotZ, st_motor[m_nMotZ].d_pos[Z_RBT_SAFETY_], (int)st_handler.md_run_speed);
		if (nRet == CTLBD_RET_GOOD)
		{
			m_lTime_GoesBy[0] = GetCurrentTime();
			m_nStep_AccyVacPick = 510;
		}
		else if (nRet == CTLBD_RET_ERROR || nRet == CTLBD_RET_RETRY)
		{
			// 071005 0 0 "BARCODE_ROBOT_Z_RBT_SAFETY_MOVE_ERR"
			alarm.mstr_code		= "071005";
			alarm.mn_count_mode	= 0;
			alarm.mn_type_mode	= eWARNING;
			st_work.nEqpStatus	= dWARNING;
		}
		break;

	case 510:
		// 그립퍼의 자재 상태 반환
		// - m_nPicker : [case 100:]에서 설정됨
		nRet = Func.OnGet_PickerStatus(0, CTL_YES, m_nPicker);
		if (nRet == CTL_ERROR)
		{
			m_lTime_GoesBy[1] = GetCurrentTime();
			m_lTime_GoesBy[2] = m_lTime_GoesBy[1] - m_lTime_GoesBy[0];
			if (m_lTime_GoesBy[2] < 0)
			{
				m_lTime_GoesBy[0] = GetCurrentTime();
				break;
			}
			
			if (m_lTime_GoesBy[2] < 10)
			{
				break;
			}
		}

		// 전체 그립퍼 갯수 가운데
		for(i=0; i<MAX_PICKER_; i++)
		{
			// 악세사리 집기 동작 진행한 그리퍼에 한해서 악세사리가 Vacuum 센서에 감지된 경우
			if (m_nPicker[TYPE_FLAG_][i] == CTL_YES && m_nPicker[TYPE_SEN_][i] == CTL_YES)
			{
				// 그립퍼의 구조체 정보 갱신 [악세사리 집었음]
				st_map.nXYZRbtPickerInfo[i]	= CTL_YES;
				m_nPicker[TYPE_FLAG_][i]	= CTL_NO;
			}
		}

		// OnGet_PickerStatus() 함수에서는 [CTL_GOOD/CTL_ERROR] 반환되었을 것임
		if (nRet == CTL_GOOD)
		{
			m_nStep_AccyVacPick = 1000;
			stSync.nResp_XYZRbt2Lifter_Work = SYNC_RESP_WORK_COMPLETE_;
		}
		else
		{
			m_nStep_AccyVacPick = 600;
		}
		break;

		//==========================================================//
		// 알람시 방생 부분
		//==========================================================//
	case 600:
		nRet = CTL_Lib.OnSingleMove(m_nMotY, st_motor[m_nMotY].d_pos[Y_RBT_ACC_NG_BUFFER_], (int)st_handler.md_run_speed);
		if(nRet == CTLBD_RET_GOOD)
		{
			m_nStep_AccyVacPick = 510;
			// OnGet_PickerStatus() 함수 안에서 알람 코드 설정됨
			alarm.mn_count_mode	= 0;
			alarm.mn_type_mode	= eWARNING;
			st_work.nEqpStatus	= dWARNING;
		}
		else if (nRet == CTLBD_RET_ERROR || nRet == CTLBD_RET_RETRY)
		{
			// 051008 0 00 "BARCODE_ROBOT_Y_RBT_ACC_NG_BUFFER_MOVE_ERR."
			alarm.mstr_code		= "051008";
			alarm.mn_count_mode	= 0;
			alarm.mn_type_mode	= eWARNING;
			st_work.nEqpStatus	= dWARNING;
		}
		break;
		//==========================================================//

	case 1000:
		// [Box Lifter -> XYZRbt] 리셋 요청 대기
		if (stSync.nReq_Lifter2XYZRbt_Work == SYNC_REQ_RESET_)
		{
			stSync.nResp_XYZRbt2Lifter_Work = SYNC_RESP_RESET_;

			nFuncRet = CTL_GOOD;
			m_nStep_AccyVacPick = 0;
		}
		break;
	}
	return nFuncRet;
}

// yangkyu [2015.03.10]
//////////////////////////////////////////////////////////////////////////
// Lift Z축을 2mm씩 최대 획수 까지 올린 후 Gripper의 센서가 감지가 되지 않앗을 경우
// Lift Z축을 내리면서 작업 위치를 변경
//////////////////////////////////////////////////////////////////////////
int CSeq_XYZRobot::OnProc_WorkSiteChange()
{
	int nFuncRet = CTL_PROCEED;
	
	int nRet = VAR_INIT_;
	int nRetData[4] = {0,};
	int i = 0;
	int iCheckCount = 0;

	switch(m_nStep_WorkSiteChange)
	{
	case 0:
		// yangkyu [2015.02.28]
		// Grip, Vac 사용 모드 추가
		if (st_basic.nMode_GripUsing == GRIP_USING)
		{
			m_nStep_WorkSiteChange = 100;	// Grip 사용 모드
		}
		else if (st_basic.nMode_VacUsing == VAC_USING)
		{
			m_nStep_WorkSiteChange = 200;	// Vacuum 사용 모드
		}
		break;

		//==========================================================//
		// Grip 사용 모드
		//==========================================================//
	case 100:
		// [0],[1],[2],[3] Grip Off
		nRet = OnProc_Grip(15, IO_OFF);
		
		if (nRet == CTLBD_RET_GOOD)
		{
			m_nStep_WorkSiteChange = 300;
		}
		break;
		
		//==========================================================//
		// Vacuum 사용 모드
		//==========================================================//
	case 200:
		for(i=0; i<MAX_PICKER_; i++)
		{
			m_nPicker[TYPE_FLAG_][i] = CTL_YES;	// [리셋] 플래그 정보
		}
		// [0:좌앞, 1:우앞] 2개의 Vacuum 해제
		OnSet_SolVacuum(IO_OFF, m_nPicker[TYPE_FLAG_]);	// 그립퍼 Vacuum [ON:진공설정, OFF:진공해제]
		m_nStep_WorkSiteChange = 210;
		break;

	case 210:
		nRet = OnGet_SolVacuum(IO_OFF, m_nPicker[TYPE_FLAG_], m_nPicker[TYPE_SEN_]);
		// 어찌되었던 동작이 완료될때까지 대기
		if (nRet == CTL_GOOD || nRet == CTL_ERROR)
		{
			m_lTime_GoesBy[0] = GetCurrentTime();
			m_nStep_WorkSiteChange = 220;
		}
		break;

	case 220:
		// 그립퍼의 자재 존재 상태 반환
		// - m_nPicker : [case 230:] 에서 설정됨
		nRet = Func.OnGet_PickerStatus(0, CTL_NO, m_nPicker);
		if (nRet == CTL_ERROR)
		{
			m_lTime_GoesBy[1] = GetCurrentTime();
			m_lTime_GoesBy[2] = m_lTime_GoesBy[1] - m_lTime_GoesBy[0];
			if (m_lTime_GoesBy[2] < 0)
			{
				m_lTime_GoesBy[0] = GetCurrentTime();
				break;
			}
			
			if (m_lTime_GoesBy[2] > 10)
			{
				// OnGet_PickerStatus() 함수 안에서 알람 코드 설정됨
				alarm.mn_count_mode	= 0;
				alarm.mn_type_mode	= eWARNING;
				st_work.nEqpStatus	= dWARNING;
			}
			break;
		}
		m_nStep_WorkSiteChange = 300;
		break;
		
	case 300:
		nRet = CTL_Lib.OnSingleMove(m_nMotZ, st_motor[m_nMotZ].d_pos[Z_RBT_SAFETY_], (int)st_handler.md_run_speed);
		if (nRet == CTLBD_RET_GOOD)
		{
			// Z축이 다 내려간 후 X축 이동을 위해 대기
			if (stSync.nReq_Lifter2XYZRbt_Work == SYNC_REQ_RESET_)
			{
				m_nStep_WorkSiteChange = 500;
			}
			else
			{
				m_nStep_WorkSiteChange = 400;
			}
		}
		else if (nRet == CTLBD_RET_ERROR || nRet == CTLBD_RET_RETRY)
		{
			// 071005 0 0 "BARCODE_ROBOT_Z_RBT_SAFETY_MOVE_ERR"
			alarm.mstr_code		= "071005";
			alarm.mn_count_mode	= 0;
			alarm.mn_type_mode	= eWARNING;
			st_work.nEqpStatus	= dWARNING;
		}
		break;

	case 400:
		// Z축이 다 내려간 후 X축 이동을 위해 대기
		if (stSync.nReq_Lifter2XYZRbt_Work == SYNC_REQ_RESET_)
		{
			m_nStep_WorkSiteChange = 500;
		}
		break;

	case 500:
		nRet = CTL_Lib.OnSingleMove(m_nMotY, st_motor[m_nMotY].d_pos[Y_RBT_ACC_NG_BUFFER_], (int)st_handler.md_run_speed);
		if (nRet == CTLBD_RET_GOOD)
		{
			m_nStep_WorkSiteChange = 1000;
		}
		else if (nRetData[1] == CTLBD_RET_ERROR || nRetData[1] == CTLBD_RET_RETRY)
		{
			// 051008 0 00 "BARCODE_ROBOT_Y_RBT_ACC_NG_BUFFER_MOVE_ERR."
			alarm.mstr_code		= "051008";
			alarm.mn_count_mode	= 0;
			alarm.mn_type_mode	= eWARNING;
			st_work.nEqpStatus	= dWARNING;
		}
		break;

	case 1000:
		m_nStep_WorkSiteChange = 0;
		nFuncRet = CTL_GOOD;
		break;
	}

	return nFuncRet;
}

// yangkyu [2015.03.05]
//////////////////////////////////////////////////////////////////////////
// Buffer Conv에 자재를 놓는 함수
//////////////////////////////////////////////////////////////////////////
int CSeq_XYZRobot::OnProc_AccyPlace()
{
	int nFuncRet = CTL_PROCEED;
	
	int nRet = VAR_INIT_;
	int nRetData[4] = {0,};
	int i = 0;
	int iCheckCount = 0;

	switch(m_nStep_AccyPlace)
	{
	case 0:
		// BCR 상태가 All Good 이면 Buffer Conv 공급 Step 이동
		if(st_map.nBCR_State[0] == BCR_READ_GOOD_ && st_map.nBCR_State[1] == BCR_READ_GOOD_ && st_map.nBCR_State[2] == BCR_READ_GOOD_ && st_map.nBCR_State[3] == BCR_READ_GOOD_)
		{
			// yangkyu [2015.03.05]
			stSync.nReq_XYZRbt2BufferAlaignConv_Work = SYNC_REQ_BUFFER_LOADING_READY_;
			m_nStep_AccyPlace = 500;
		}
		// 4개의 Accy 중 한개라도 Bad 일경우 에는 Bad Step 수행
		else if(st_map.nBCR_State[0] == BCR_READ_BAD_ || st_map.nBCR_State[1] == BCR_READ_BAD_ || st_map.nBCR_State[2] == BCR_READ_BAD_ || st_map.nBCR_State[3] == BCR_READ_BAD_)
		{
			m_nStep_AccyPlace = 100;
		}
		break;

	case 100:
		nRet = OnProc_BCRStateBad();
		
		if (nRet == CTL_GOOD)
		{
			m_nStep_AccyPlace = 1000;
		}
		break;

	// 모든 자제가 GOOD 일때에는 Buffer Conv에 자재를 가져다 놓음
	case 500:
		// 규이리 수정 [2015.03.25]
		// [1:4개씩, 0:2개씩]
		if (st_basic.nMode_PlaceType == 0)
		{
			nRet = OnProc_BufferPlace();	// [Main<-Accy] 공급용 레일에 Rear 2개 악세사리 내려 놓은 후 Front 2개 악세사리를 내려놓기
		}
		else
		{
			nRet = OnProc_4BufferPlace();	// [Main<-Accy] 공급용 레일에 4개 악세사리 한꺼번에 내려놓기
		}
		
		if (nRet == CTL_GOOD)
		{
			stSync.nReq_XYZRbt2BufferAlaignConv_Work = SYNC_REQ_WORK_COMPLETE_;
			m_nStep_AccyPlace = 1000;
		}
		break;

	case 1000:
		nFuncRet = CTL_GOOD;
		m_nStep_AccyPlace = 0;
		break;
	}

	return nFuncRet;
}

//==================================================================//
// 그립퍼 Vacuum [ON:진공설정, OFF:진공해제]
// - int nzMode :
// : [0] 그립퍼 정보를 보고 Vacuum 동작 여부 결정
// : [그외] 그립퍼 정보에 상관없이 모든 피커의 Vacuum 동작
//==================================================================//
void CSeq_XYZRobot::OnSet_SolVacuum(int nzOnOff, int nzPickerInfo[MAX_PICKER_], int nzMode) 
{
	int i=0;
	int iMaster=0, iSlave=0;
	// [0:좌앞, 1:우앞, 2:좌뒤, 3:우뒤]
	for(i=0; i<MAX_PICKER_; i++)
	{
		iMaster	= i / 2;	// 몫을 계산
		iSlave	= i % 2;	// 나머지 계산

		if (nzMode == 0)
		{
			// 플래그가 설정되지 않은 글비퍼는 Vacuum Off 시키면 안됨
			// - 악세사리 집고 있을 경우 Vacuum 동작 플래그가 설정되지 않았을 것이기 때문임
			if (nzPickerInfo[i] == CTL_YES)
			{
				if (st_basic.n_mode_device != WITHOUT_DVC_)
				{
					g_ioMgr.set_out_bit(stIO.o_Vac_GripRbt_VacOnOff[iMaster][iSlave], nzOnOff);
				}
			}
		}
		else
		{
			if (st_basic.n_mode_device != WITHOUT_DVC_)
			{
				g_ioMgr.set_out_bit(stIO.o_Vac_GripRbt_VacOnOff[iMaster][iSlave], nzOnOff);
		
			}
		}
	}
	m_bflag_Vac = false;
	m_lWait_Vac[0] = GetCurrentTime();
}

int CSeq_XYZRobot::OnGet_SolVacuum(int nzOnOff, int nzPickerInfo[MAX_PICKER_], int nzVacStatus[MAX_PICKER_], int nzMode) 
{
	int nFuncRet = CTL_PROCEED;

	int i, iSensor[MAX_PICKER_];
	int iMaster=0, iSlave=0;
	// [0:좌앞, 1:우앞, 2:좌뒤, 3:우뒤]
	for(i=0; i<MAX_PICKER_; i++)
	{
		iMaster	= i / 2;	// 몫을 계산
		iSlave	= i % 2;	// 나머지 계산

		iSensor[i] = g_ioMgr.get_in_bit(stIO.i_Chk_GripRbt_VacOn[iMaster][iSlave]);
		// 해당 위치의 Vacuum 검사는 무시해야 할 경우
		// - Vacuum 상태를 설정하고자 하는 상태로 강제로 셋팅
		if (nzPickerInfo[i] == CTL_NO)
		{
			iSensor[i] = nzOnOff;
		}
	}

	if (nzMode == 0)
	{
		if (st_basic.n_mode_device == WITHOUT_DVC_)
		{
			// [WithOut] 모드에서는 Vacuum 상태를 설정하고자 하는 상태로 강제로 할당함
			for(i=0; i<MAX_PICKER_; i++)
			{
				iSensor[i] = nzOnOff;
			}
		}
	}
	// 현재의 Vacuum 상태 반환
	// - [WithOut] 모드 또는 해당 포트 사용 여부에 따라 강제 변경될 수 있음
	for(i=0; i<MAX_PICKER_; i++)
	{
		nzVacStatus[i] = iSensor[i];
	}

	if (iSensor[0] == nzOnOff && iSensor[1] == nzOnOff && iSensor[2] == nzOnOff && iSensor[3] == nzOnOff &&
		m_bflag_Vac == false)
	{
		m_lWait_Vac[0] = GetCurrentTime();
		m_bflag_Vac = true;
	}
	else if (iSensor[0] == nzOnOff && iSensor[1] == nzOnOff && iSensor[2] == nzOnOff && iSensor[3] == nzOnOff &&
		m_bflag_Vac == true)
	{
		m_lWait_Vac[1] = GetCurrentTime();
		m_lWait_Vac[2] = m_lWait_Vac[1] - m_lWait_Vac[0];
		if (m_lWait_Vac[2] < 0)
		{
			m_lWait_Vac[0] = GetCurrentTime();
			return nFuncRet;
		}

		if (nzOnOff == IO_ON)
		{
			if (m_lWait_Vac[2] >= st_time.nWait_On[CYL_ACCY_BOX_VAC_GRIPPER])
			{
				nFuncRet = CTL_GOOD;
			}
		}
		else
		{
			if (m_lWait_Vac[2] >= st_time.nWait_Off[CYL_ACCY_BOX_VAC_GRIPPER])
			{
				nFuncRet = CTL_GOOD;
			}
		}
	}
	else
	{
		m_lWait_Vac[1] = GetCurrentTime();
		m_lWait_Vac[2] = m_lWait_Vac[1] - m_lWait_Vac[0];
		if (m_lWait_Vac[2] < 0)
		{
			m_lWait_Vac[0] = GetCurrentTime();
			return nFuncRet;
		}

		if (m_lWait_Vac[2] >= st_time.nWait_Limit[CYL_ACCY_BOX_VAC_GRIPPER])
		{
			if (iSensor[0] != nzOnOff)
			{
				if (nzOnOff == IO_OFF)
				{
					// 115010 0 00 "PS1000_ROBOT_GRIP_1_VAC_OFF_ERR."
					alarm.mstr_code		= "115010";
				}
				else
				{
					// 115000 0 00 "PS1000_ROBOT_GRIP_1_VAC_ON_ERR."
					alarm.mstr_code		= "115000";
				}
			}
			else if (iSensor[1] != nzOnOff)
			{
				if (nzOnOff == IO_OFF)
				{
					// 115011 0 00 "PS1001_ROBOT_GRIP_2_VAC_OFF_ERR."
					alarm.mstr_code		= "115011";
				}
				else
				{
					// 115001 0 00 "PS1001_ROBOT_GRIP_2_VAC_ON_ERR."
					alarm.mstr_code		= "115001";
				}
			}
			else if (iSensor[2] != nzOnOff)
			{
				if (nzOnOff == IO_OFF)
				{
					// 115012 0 00 "PS1002_ROBOT_GRIP_3_VAC_OFF_ERR."
					alarm.mstr_code		= "115012";
				}
				else
				{
					// 115002 0 00 "PS1002_ROBOT_GRIP_3_VAC_ON_ERR."
					alarm.mstr_code		= "115002";
				}
			}
			else if (iSensor[3] != nzOnOff)
			{
				if (nzOnOff == IO_OFF)
				{
					// 115013 0 00 "PS1003_ROBOT_GRIP_4_VAC_OFF_ERR."
					alarm.mstr_code		= "115013";
				}
				else
				{
					// 115003 0 00 "PS1003_ROBOT_GRIP_4_VAC_ON_ERR."
					alarm.mstr_code		= "115003";
				}
			}
			nFuncRet = CTL_ERROR;
		}
	}
	return nFuncRet;
}

// yangkyu [2015.03.17]
//////////////////////////////////////////////////////////////////////////
// NG Accy를 버린 후 NG Buffer를 놓는 작업
//////////////////////////////////////////////////////////////////////////
int CSeq_XYZRobot::OnProc_NGBufferPlace()
{
	int nFuncRet = CTL_PROCEED;
	
	int nRet = VAR_INIT_;
	int nRetData[4] = {0,};
	int i = 0;
	int iCheckCount = 0;

	switch(m_nStep_NGBufferPlace)
	{
	case 0:
		// yangkyu [2015.02.22]
		// 번호는 메인 설비 정면 기준으로 0(앞쪽 좌), 1(앞쪽 우), 2(뒤쪽 좌), 3(뒤쪽 우)
		// NG Buffer 자재 확인
		nRetData[0] = OnCheck_NGBufferFrontAccy(IO_ON, CHK_EXIST_, SIDE_LEFT_);
		nRetData[1] = OnCheck_NGBufferFrontAccy(IO_ON, CHK_EXIST_, SIDE_RIGHT_);
		nRetData[2] = OnCheck_NGBufferRearAccy(IO_ON, CHK_EXIST_, SIDE_LEFT_);
		nRetData[3] = OnCheck_NGBufferRearAccy(IO_ON, CHK_EXIST_, SIDE_RIGHT_);
		
		if (st_basic.n_mode_device == WITHOUT_DVC_)
		{
			for (i = 0; i < 4; i++)
			{
				nRetData[i] = st_map.nNGBuffer[i];
			}
		}
		
		for (i = 0; i < 4; i++)
		{
			if (st_map.nNGBuffer[i] != nRetData[i])
			{
				iCheckCount++;
			}
		}
		
		if (iCheckCount > 0)
		{
			// 151000 0 00 "PS1204_PS1205_PS1206_PS1207_NG_BUFFER_DATA_MISS_MATH."
			alarm.mstr_code		= "151000";
			alarm.mn_count_mode	= 0;
			alarm.mn_type_mode	= eWARNING;
			st_work.nEqpStatus	= dWARNING;
			break;
		}

		// yangkyu [2015.03.24]
		//if (st_map.nNGBuffer[0] == ACCY_NO_ &&  st_map.nNGBuffer[0] == ACCY_NO_ && st_map.nNGBuffer[0] == ACCY_NO_ && st_map.nNGBuffer[0] == ACCY_NO_)
		if (st_map.nNGBuffer[0] == ACCY_NO_ &&  st_map.nNGBuffer[1] == ACCY_NO_ && st_map.nNGBuffer[2] == ACCY_NO_ && st_map.nNGBuffer[3] == ACCY_NO_)
		{
			//m_nStep_NGBufferPlace = 200;
			// kilee [2015.03.23]
			m_nStep_NGBufferPlace = 100;
			break;
		}

		// Gripper i번의 상태와 NG Buffer i의 상태를 비교하여 중복되는 영역은 배출
		for (i = 0; i < MAX_PICKER_; i++)
		{
			// yangkyu [2015.03.24]
			// 바코드 상태가 Bad일 경우에는 확인 필요 없음
			if( st_map.nNGBuffer[i] == ACCY_YES_ && st_map.nBCR_State[i] == BCR_READ_GOOD_)
			{
				// BCR 정보 화면 표시를 위해 추가함
				st_map.nBCR_State[i] = BCR_READ_BAD_;
			}
		}

		// 중복 되는 Accy를 버리기 위해 Bad 처리 하엿으므로 바코드 표시를 다시 함.
		if (st_handler.cwnd_main != NULL)
		{
			st_handler.cwnd_main->PostMessage(WM_UPDATE_MAIN, READ_BCR_DATA);
		}

		m_nStep_NGBufferPlace = 100;
		break;

	case 100:
		// Gripper가 잡고 있는 Accy 배출 (SIDE_FRONT_ : 1, 2번 Gripper, SIDE_REAR_ : 3, 4번 Gripper)
		nRet = OnProc_AccyOut(st_map.nBCR_State, SIDE_FRONT_);
		
		if (nRet == CTL_GOOD)
		{
			m_nStep_NGBufferPlace = 110;
		}
		break;

	case 110:
		// Gripper가 잡고 있는 Accy 배출 (SIDE_FRONT_ : 1, 2번 Gripper, SIDE_REAR_ : 3, 4번 Gripper)
		nRet = OnProc_AccyOut(st_map.nBCR_State, SIDE_REAR_);
		
		if (nRet == CTL_GOOD)
		{
			m_nStep_NGBufferPlace = 200;
		}
		break;

	case 200:
		// 모든 Accy 바코드 상태가 Bad 일경우 다 버린 후 이기 떄문에 완료 Step 진행
		if (st_map.nBCR_State[0] == BCR_READ_BAD_ && st_map.nBCR_State[1] == BCR_READ_BAD_ &&
			st_map.nBCR_State[2] == BCR_READ_BAD_ && st_map.nBCR_State[3] == BCR_READ_BAD_)
		{
			// kilee [2015.03.23]
			m_nStep_NGBufferPlace = 0;
			nFuncRet = CTL_GOOD;
		}
		// NG Buffer에 보급을 할 수 있기 떄문에 보급 Step 진행
		else
		{
			m_nStep_NGBufferPlace = 300;
		}
		break;

	case 300:
		nRet = CTL_Lib.OnSingleMove(m_nMotY, st_motor[m_nMotY].d_pos[Y_RBT_ACC_NG_BUFFER_], (int)st_handler.md_run_speed);
		if (nRet == CTLBD_RET_GOOD)
		{
			m_nStep_NGBufferPlace = 310;
		}
		else if (nRet == CTLBD_RET_ERROR || nRet == CTLBD_RET_RETRY)
		{
			// 051008 0 00 "BARCODE_ROBOT_Y_RBT_ACC_NG_BUFFER_MOVE_ERR."
			alarm.mstr_code		= "051008";
			alarm.mn_count_mode	= 0;
			alarm.mn_type_mode	= eWARNING;
			st_work.nEqpStatus	= dWARNING;
		}
		break;

	case 310:
		// 초기에는 그립퍼+Vacuum 모드도 가능하다고 했는데 실재로는 불가능함
		// - 그립퍼면 그립퍼만 사용, Vacuum이면 Vacuum만 사용해야 함
		if (st_basic.nMode_GripUsing == GRIP_USING)
		{
			m_nStep_NGBufferPlace = 400;	// Grip 사용 모드
		}
		else if (st_basic.nMode_VacUsing == VAC_USING)
		{
			// 이전 동작에서 이미 (Vacuum Off) 진행했을 것이므로 다시 진행하지 않도록 함
			// - 해도 무방하지만 대기 시간만큼의 시간이 더 소요됨
			m_nStep_NGBufferPlace = 500;	// Vacuum 사용 모드
			m_lTime_GoesBy[0] = GetCurrentTime();
		}
		break;

		//==========================================================//
		// Grip 사용 모드
		//==========================================================//
	case 400:
		nRet = CTL_Lib.OnSingleMove(m_nMotZ, st_motor[m_nMotZ].d_pos[Z_RBT_ACC_NG_BUFFER_PLACE_], (int)st_handler.md_run_speed);
		if (nRet == CTLBD_RET_GOOD)
		{
			m_nStep_NGBufferPlace = 8510;	// Grip 사용 모드
		}
		else if (nRet == CTLBD_RET_ERROR || nRet == CTLBD_RET_RETRY)
		{
			// 071001 0 00 "BARCODE_ROBOT_Z_RBT_ACC_NG_BUFFER_PLACE_MOVE_ERR."
			alarm.mstr_code		= "071001";
			alarm.mn_count_mode	= 0;
			alarm.mn_type_mode	= eWARNING;
			st_work.nEqpStatus	= dWARNING;
		}
		break;
		
	case 410:
		// [0] or [1] or [2] or [3] Grip Off
		nRet = OnProc_Grip(15, IO_OFF);
		
		if (nRet == CTLBD_RET_GOOD)
		{
			m_nStep_NGBufferPlace = 420;
		}
		break;

	case 420:
		nRet = CTL_Lib.OnSingleMove(m_nMotZ, st_motor[m_nMotZ].d_pos[Z_RBT_SAFETY_], (int)st_handler.md_run_speed);
		if (nRet == CTLBD_RET_GOOD)
		{
			m_nStep_NGBufferPlace = 1000;
		}
		else if (nRet == CTLBD_RET_ERROR || nRet == CTLBD_RET_RETRY)
		{
			// 071005 0 07 "BARCODE_ROBOT_Z_RBT_SAFETY_MOVE_ERR."
			alarm.mstr_code		= "071005";
			alarm.mn_count_mode	= 0;
			alarm.mn_type_mode	= eWARNING;
			st_work.nEqpStatus	= dWARNING;
		}
		break;
		//==========================================================//

		//==========================================================//
		// Vacuum 사용 모드
		//==========================================================//
	case 500:
		// 그립퍼의 자재 상태 반환
		// - m_nPicker : [case 300:]에서 설정됨
		nRet = Func.OnGet_PickerStatus(0, CTL_YES, m_nPicker);
		if (nRet == CTL_ERROR)
		{
			m_lTime_GoesBy[1] = GetCurrentTime();
			m_lTime_GoesBy[2] = m_lTime_GoesBy[1] - m_lTime_GoesBy[0];
			if (m_lTime_GoesBy[2] < 0)
			{
				m_lTime_GoesBy[0] = GetCurrentTime();
				break;
			}
			
			if (m_lTime_GoesBy[2] < 10)
			{
				break;
			}
		}

		// OnGet_PickerStatus() 함수에서는 [CTL_GOOD/CTL_ERROR] 반환되었을 것임
		if (nRet == CTL_GOOD)
		{
			m_nStep_NGBufferPlace = 510;
		}
		else
		{
			// OnGet_PickerStatus() 함수 안에서 알람 코드 설정됨
			alarm.mn_count_mode	= 0;
			alarm.mn_type_mode	= eWARNING;
			st_work.nEqpStatus	= dWARNING;
		}
		break;

	case 510:
		nRet = CTL_Lib.OnSingleMove(m_nMotZ, st_motor[m_nMotZ].d_pos[Z_RBT_ACC_NG_BUFFER_PLACE_], (int)st_handler.md_run_speed);
		if (nRet == CTLBD_RET_GOOD)
		{
			m_nStep_NGBufferPlace = 520;
		}
		else if (nRet == CTLBD_RET_ERROR || nRet == CTLBD_RET_RETRY)
		{
			// 071001 0 00 "BARCODE_ROBOT_Z_RBT_ACC_NG_BUFFER_PLACE_MOVE_ERR."
			alarm.mstr_code		= "071001";
			alarm.mn_count_mode	= 0;
			alarm.mn_type_mode	= eWARNING;
			st_work.nEqpStatus	= dWARNING;
		}
		break;

	case 520:
		// 전체 피커 갯수 가운데
		for(i=0; i<MAX_PICKER_; i++)
		{
			m_nPicker[TYPE_FLAG_][i] = CTL_YES;	// [리셋] 플래그 정보
		}
		m_nStep_NGBufferPlace = 530;
		break;

	case 530:
		// - m_nPicker[FLAG_INFO] : [case 520:]에서 설정됨
		OnSet_SolVacuum(IO_OFF, m_nPicker[TYPE_FLAG_]);	// 그립퍼 Vacuum [ON:진공설정, OFF:진공해제]
		m_nStep_NGBufferPlace = 540;
		break;

	case 540:
		nRet = OnGet_SolVacuum(IO_OFF, m_nPicker[TYPE_FLAG_], m_nPicker[TYPE_SEN_]);
		// 어찌되었던 동작이 완료될때까지 대기
		// - 피커를 들고 알람을 출력시키기 위함
		if (nRet == CTL_GOOD || nRet == CTL_ERROR)
		{
			m_nStep_NGBufferPlace = 550;
		}
		break;

	case 550:
		nRet = CTL_Lib.OnSingleMove(m_nMotZ, st_motor[m_nMotZ].d_pos[Z_RBT_SAFETY_], (int)st_handler.md_run_speed);
		if (nRet == CTLBD_RET_GOOD)
		{
			m_lTime_GoesBy[0] = GetCurrentTime();
			m_nStep_NGBufferPlace = 570;
		}
		else if (nRet == CTLBD_RET_ERROR || nRet == CTLBD_RET_RETRY)
		{
			// 071005 0 07 "BARCODE_ROBOT_Z_RBT_SAFETY_MOVE_ERR."
			alarm.mstr_code		= "071005";
			alarm.mn_count_mode	= 0;
			alarm.mn_type_mode	= eWARNING;
			st_work.nEqpStatus	= dWARNING;
		}
		break;

	case 570:
		// 그립퍼의 자재 상태 반환
		// - m_nPicker : [case 300:]에서 설정됨
		nRet = Func.OnGet_PickerStatus(0, CTL_NO, m_nPicker);
		if (nRet == CTL_ERROR)
		{
			m_lTime_GoesBy[1] = GetCurrentTime();
			m_lTime_GoesBy[2] = m_lTime_GoesBy[1] - m_lTime_GoesBy[0];
			if (m_lTime_GoesBy[2] < 0)
			{
				m_lTime_GoesBy[0] = GetCurrentTime();
				break;
			}
			
			if (m_lTime_GoesBy[2] < 10)
			{
				break;
			}
		}
		// [자재 정상] : 곧바로 밑에 부분 실행
		// [자재 에러] : 일정 시간 대기 후에 밑에 부분 실행
		
		// 전체 그립퍼 갯수 가운데
		for(i=0; i<MAX_PICKER_; i++)
		{
			// 악세사리 놓는 동작을 진행한 그리퍼에 한해서 악세사리가 Vacuum 센서에 감지가 안된 경우
			if (m_nPicker[TYPE_FLAG_][i] == CTL_YES && m_nPicker[TYPE_SEN_][i] == CTL_NO)
			{
				// 그립퍼의 구조체 정보 갱신 [자재 지었음]
				st_map.nXYZRbtPickerInfo[i]	= CTL_NO;
				m_nPicker[TYPE_FLAG_][i]	= CTL_NO;
			}
		}
		
		// OnGet_PickerStatus() 함수에서는 [CTL_GOOD/CTL_ERROR] 반환되었을 것임
		if (nRet == CTL_GOOD)
		{
			m_nStep_NGBufferPlace = 1000;
		}
		else
		{
			// OnGet_PickerStatus() 함수 안에서 알람 코드 설정됨
			alarm.mn_count_mode	= 0;
			alarm.mn_type_mode	= eWARNING;
			st_work.nEqpStatus	= dWARNING;
		}
		break;
		//==========================================================//

	case 1000:
		for (i = 0; i <4; i++)
		{
			if (st_map.nBCR_State[i] == BCR_READ_GOOD_)
			{
				st_map.nNGBuffer[i] = st_map.nBCR_State[i];
				st_work.sNGBufferBCR_Data[i] = st_work.sRbtBCR_Data[i];
				st_work.sRbtBCR_Data[i] = "";
			}
		}
		
		if (st_handler.cwnd_main != NULL)
		{
			// NG Buffer 자재 상태 표시 요청
			st_handler.cwnd_main->PostMessage(WM_UPDATE_MAIN, PLACE_NG_BUFFER_);
		}
		m_nStep_NGBufferPlace = 0;
		nFuncRet = CTL_GOOD;
		break;
	}

	return nFuncRet;
}

// yangkyu [2015.03.17]
//////////////////////////////////////////////////////////////////////////
// NG Accy를 버린 후 NG Buffer를 놓는 작업
//////////////////////////////////////////////////////////////////////////
int CSeq_XYZRobot::OnProc_NGBufferPick(int nzSite)
{
	int nFuncRet = CTL_PROCEED;
	
	int nRet = VAR_INIT_;
	int nRetData[4] = {0,};
	int i = 0;
	int iCheckCount = 0;
	
	switch(m_nStep_NGBufferPick)
	{
	case 0:
		nRet = CTL_Lib.OnSingleMove(m_nMotZ, st_motor[m_nMotZ].d_pos[Z_RBT_SAFETY_], (int)st_handler.md_run_speed);
		if (nRet == CTLBD_RET_GOOD)
		{
			m_nStep_NGBufferPick = 10;
		}
		else if (nRet == CTLBD_RET_ERROR || nRet == CTLBD_RET_RETRY)
		{
			// 071005 0 0 "BARCODE_ROBOT_Z_RBT_SAFETY_MOVE_ERR"
			alarm.mstr_code		= "071005";
			alarm.mn_count_mode	= 0;
			alarm.mn_type_mode	= eWARNING;
			st_work.nEqpStatus	= dWARNING;
		}
		break;

	case 10:
		if (nzSite == SIDE_BOTH_)	// NG Buffer SIDE_BOTH_
		{
			m_dTargetPos = st_motor[m_nMotY].d_pos[Y_RBT_ACC_NG_BUFFER_];
		}
		else if (nzSite == SIDE_FRONT_) // NG Buffer SIDE_FRONT
		{
			m_dTargetPos = st_motor[m_nMotY].d_pos[Y_RBT_ACC_NG_BUFFER_] + st_accy.d_Y_Gripper_Size;
		}
		else if (nzSite == SIDE_REAR_)	// NG Buffer SIDE_REAR
		{
			m_dTargetPos = st_motor[m_nMotY].d_pos[Y_RBT_ACC_NG_BUFFER_] - st_accy.d_Y_Gripper_Size;
		}

		// nzSite값에 따라 NG Buffer 이동
		nRet = CTL_Lib.OnSingleMove(m_nMotY, m_dTargetPos, (int)st_handler.md_run_speed);
		if (nRet == CTLBD_RET_GOOD)
		{
			m_nStep_NGBufferPick = 100;
			m_nGirpSum = 0;
		}
		else if (nRet == CTLBD_RET_ERROR || nRet == CTLBD_RET_RETRY)
		{
			// 051008 0 00 "BARCODE_ROBOT_Y_RBT_ACC_NG_BUFFER_MOVE_ERR."
			alarm.mstr_code		= "051008";
			alarm.mn_count_mode	= 0;
			alarm.mn_type_mode	= eWARNING;
			st_work.nEqpStatus	= dWARNING;
		}
		break;

	case 100:

		nRetData[0] = OnCheck_NGBufferFrontAccy(IO_ON,	CHK_NOT_EXIST_,	SIDE_LEFT_);
		nRetData[1] = OnCheck_NGBufferFrontAccy(IO_ON,	CHK_NOT_EXIST_,	SIDE_RIGHT_);
		nRetData[2] = OnCheck_NGBufferRearAccy(IO_ON,	CHK_NOT_EXIST_,	SIDE_LEFT_);
		nRetData[3] = OnCheck_NGBufferRearAccy(IO_ON,	CHK_NOT_EXIST_, SIDE_RIGHT_);

		if (st_basic.n_mode_device == WITHOUT_DVC_)
		{
			nRetData[0] = st_map.nNGBuffer[0];
			nRetData[1] = st_map.nNGBuffer[1];
			nRetData[2] = st_map.nNGBuffer[2];
			nRetData[3] = st_map.nNGBuffer[3];
			
		}

		// kilee [2015.03.17]
		for(i=0; i<MAX_PICKER_; i++)
		{
			m_nSensor[i] = nRetData[i];
		}
		
		if (nzSite == SIDE_BOTH_)	// NG Buffer SIDE_BOTH_
		{
			if(st_map.nBCR_State[0] == BCR_READ_BAD_ && nRetData[0] == IO_ON)
			{
				m_nGirpSum += 1;
			}
			if(st_map.nBCR_State[1] == BCR_READ_BAD_ && nRetData[1] == IO_ON)
			{
				m_nGirpSum += 2;
			}
			if(st_map.nBCR_State[2] == BCR_READ_BAD_ && nRetData[2] == IO_ON)
			{
				m_nGirpSum += 4;
			}
			if(st_map.nBCR_State[3] == BCR_READ_BAD_ && nRetData[3] == IO_ON)
			{
				m_nGirpSum += 8;
			}
		}
		else if (nzSite == SIDE_FRONT_) // NG Buffer SIDE_FRONT
		{
			// Gripper 3이 BCR_READ_BAD_ 일경우 NG Buffer 1에서 보급 하기위해 GripSum 값 증가
			if(st_map.nBCR_State[2] == BCR_READ_BAD_ && nRetData[0] == IO_ON)
			{
				m_nGirpSum += 4;
			}
			// Gripper 4가 BCR_READ_BAD_ 일경우 NG Buffer 2에서 보급 하기위해 GripSum 값 증가
			if(st_map.nBCR_State[3] == BCR_READ_BAD_ && nRetData[1] == IO_ON)
			{
				m_nGirpSum += 8;
			}
		}
		else if (nzSite == SIDE_REAR_)	// NG Buffer SIDE_REAR
		{
			// Gripper 1이 BCR_READ_BAD_ 일경우 NG Buffer 3에서 보급 하기위해 GripSum 값 증가
			if(st_map.nBCR_State[0] == BCR_READ_BAD_ && nRetData[2] == IO_ON)
			{
				m_nGirpSum += 1;
			}
			// Gripper 2가 BCR_READ_BAD_ 일경우 NG Buffer 4에서 보급 하기위해 GripSum 값 증가
			if(st_map.nBCR_State[1] == BCR_READ_BAD_ && nRetData[3] == IO_ON)
			{
				m_nGirpSum += 2;
			}
		}
		m_nStep_NGBufferPick = 110;
		break;

	case 110:
		// 초기에는 그립퍼+Vacuum 모드도 가능하다고 했는데 실재로는 불가능함
		// - 그립퍼면 그립퍼만 사용, Vacuum이면 Vacuum만 사용해야 함
		if (st_basic.nMode_GripUsing == GRIP_USING)
		{
			m_nStep_NGBufferPick = 200;	// Grip 사용 모드
		}
		else if (st_basic.nMode_VacUsing == VAC_USING)
		{
			// 이전 동작에서 이미 (Vacuum Off) 진행했을 것이므로 다시 진행하지 않도록 함
			// - 해도 무방하지만 대기 시간만큼의 시간이 더 소요됨
			m_nStep_NGBufferPick = 300;	// Vacuum 사용 모드
		}
		break;

		//==========================================================//
		// Grip 사용 모드
		//==========================================================//
	case 200:
		// [0] or [1] or [2] or [3] Grip Off
		nRet = OnProc_Grip(15, IO_OFF);
		
		if (nRet == CTLBD_RET_GOOD)
		{
			m_nStep_NGBufferPick= 205;
		}
		break;

	case 205:
		nRet = CTL_Lib.OnSingleMove(m_nMotZ, st_motor[m_nMotZ].d_pos[Z_RBT_ACC_NG_BUFFER_PICK_], (int)st_handler.md_run_speed);
		if (nRet == CTLBD_RET_GOOD)
		{
			m_nStep_NGBufferPick= 210;
		}
		else if (nRet == CTLBD_RET_ERROR || nRet == CTLBD_RET_RETRY)
		{
			// 071002 0 00 "BARCODE_ROBOT_Z_RBT_ACC_NG_BUFFER_PICK_MOVE_ERR."
			alarm.mstr_code		= "071002";
			alarm.mn_count_mode	= 0;
			alarm.mn_type_mode	= eWARNING;
			st_work.nEqpStatus	= dWARNING;
		}
		break;

	case 210:
		// [0] or [1] or [2] or [3] Grip On
		nRet = OnProc_Grip(m_nGirpSum, IO_ON);
		
		if (nRet == CTLBD_RET_GOOD)
		{
			m_nStep_NGBufferPick= 220;
		}
		break;

	case 220:
		nRet = CTL_Lib.OnSingleMove(m_nMotZ, st_motor[m_nMotZ].d_pos[Z_RBT_SAFETY_], (int)st_handler.md_run_speed);
		if (nRet == CTLBD_RET_GOOD)
		{
			m_nStep_NGBufferPick= 230;
		}
		else if (nRet == CTLBD_RET_ERROR || nRet == CTLBD_RET_RETRY)
		{
			// 071005 0 0 "BARCODE_ROBOT_Z_RBT_SAFETY_MOVE_ERR"
			alarm.mstr_code		= "071005";
			alarm.mn_count_mode	= 0;
			alarm.mn_type_mode	= eWARNING;
			st_work.nEqpStatus	= dWARNING;
		}
		break;

	case 230:
		// yangkyu [2015.02.22]
		// 번호는 메인 설비 정면 기준으로 0(앞쪽 좌), 1(앞쪽 우), 2(뒤쪽 좌), 3(뒤쪽 우)
		// NG Buffer 자재 확인
		nRetData[0] = OnCheck_NGBufferFrontAccy(IO_ON, CHK_EXIST_, SIDE_LEFT_);
		nRetData[1] = OnCheck_NGBufferFrontAccy(IO_ON, CHK_EXIST_, SIDE_RIGHT_);
		nRetData[2] = OnCheck_NGBufferRearAccy(IO_ON, CHK_EXIST_, SIDE_LEFT_);
		nRetData[3] = OnCheck_NGBufferRearAccy(IO_ON, CHK_EXIST_, SIDE_RIGHT_);
		
		for (i = 0; i < 4; i++)
		{
			if(st_map.nXYZRbtPickerInfo[i] == IO_ON)
			{
				if (nRetData[i] != IO_OFF)
				{
					iCheckCount++;
				}
			}
		}
		
		if (iCheckCount > 0)
		{
			// 143000 0 00 "PS1204_PS1205_PS1206_PS1207_NG_BUFFER_ACCY_EXSIT_CHK_ERR."
			alarm.mstr_code		= "143000";
			alarm.mn_count_mode	= 0;
			alarm.mn_type_mode	= eWARNING;
			st_work.nEqpStatus	= dWARNING;
			m_nStep_NGBufferPick= 240;
		}
		else
		{
			OnBCRStateChange(nzSite);
			m_nStep_NGBufferPick= 1000;
		}
		break;

		// 알람 발생시
	case 240:
		nRet = CTL_Lib.OnSingleMove(m_nMotZ, st_motor[m_nMotZ].d_pos[Z_RBT_ACC_NG_BUFFER_PLACE_], (int)st_handler.md_run_speed);
		if (nRet == CTLBD_RET_GOOD)
		{
			m_nStep_NGBufferPick= 250;	// Grip 사용 모드
		}
		else if (nRet == CTLBD_RET_ERROR || nRet == CTLBD_RET_RETRY)
		{
			// 071002 0 00 "BARCODE_ROBOT_Z_RBT_ACC_NG_BUFFER_PICK_MOVE_ERR."
			alarm.mstr_code		= "071002";
			alarm.mn_count_mode	= 0;
			alarm.mn_type_mode	= eWARNING;
			st_work.nEqpStatus	= dWARNING;
		}
		break;

	case 250:
		// [0],[1],[2],[3] Grip Off
		nRet = OnProc_Grip(15, IO_OFF);
		
		if (nRet == CTLBD_RET_GOOD)
		{
			m_nStep_NGBufferPick= 290;
		}
		break;

	case 290:
		nRet = CTL_Lib.OnSingleMove(m_nMotZ, st_motor[m_nMotZ].d_pos[Z_RBT_SAFETY_], (int)st_handler.md_run_speed);
		if (nRet == CTLBD_RET_GOOD)
		{
			m_nGirpSum = 0;
			m_nStep_NGBufferPick= 100;
		}
		else if (nRet == CTLBD_RET_ERROR || nRet == CTLBD_RET_RETRY)
		{
			// 071005 0 0 "BARCODE_ROBOT_Z_RBT_SAFETY_MOVE_ERR"
			alarm.mstr_code		= "071005";
			alarm.mn_count_mode	= 0;
			alarm.mn_type_mode	= eWARNING;
			st_work.nEqpStatus	= dWARNING;
		}
		break;
		//==========================================================//

		//==========================================================//
		// Vacuum 사용 모드
		//==========================================================//
	case 300:
		// 번호는 메인 설비 정면 기준으로 0(앞쪽 좌), 1(앞쪽 우), 2(뒤쪽 좌), 3(뒤쪽 우)
		// NG Buffer 자재 확인	
		nRetData[0] = OnCheck_NGBufferFrontAccy(IO_ON, CHK_EXIST_, SIDE_LEFT_);
		nRetData[1] = OnCheck_NGBufferFrontAccy(IO_ON, CHK_EXIST_, SIDE_RIGHT_);
		nRetData[2] = OnCheck_NGBufferRearAccy(IO_ON, CHK_EXIST_, SIDE_LEFT_);
		nRetData[3] = OnCheck_NGBufferRearAccy(IO_ON, CHK_EXIST_, SIDE_RIGHT_);
		
		if (st_basic.n_mode_device == WITHOUT_DVC_)
		{
			nRetData[0] = st_map.nNGBuffer[0];
			nRetData[1] = st_map.nNGBuffer[1];
			nRetData[2] = st_map.nNGBuffer[2];
			nRetData[3] = st_map.nNGBuffer[3];
			
		}

		m_nRepickCount = 0;  // [리셋] 자재 집기 시도 횟수

		for(i=0; i<MAX_PICKER_; i++)
		{
			m_nPicker[TYPE_FLAG_][i] = CTL_NO;	// [리셋] 플래그 정보
		}

		if (nzSite == SIDE_BOTH_)	// NG Buffer SIDE_BOTH_
		{
			for(i=0; i<MAX_PICKER_; i++)
			{	
				// NG Buffer에서 보급 할 부분에 대해서만 Vaccum 동작
				if(st_map.nBCR_State[i] == BCR_READ_BAD_ && nRetData[i] == IO_ON)
				{
					m_nPicker[TYPE_FLAG_][i] = CTL_YES;	// 동작할 Vacuum으로 설정
				}
			}
		}
		else if (nzSite == SIDE_FRONT_) // NG Buffer SIDE_FRONT
		{
			for(i = 2; i < MAX_PICKER_; i++)
			{
				// Gripper 3, 4의 바코드 정보가  BCR_READ_BAD_ 일경우 NG Buffer 1, 2에서 보급 하기위해 동작할 Vacuum으로 설정
				if(st_map.nBCR_State[i] == BCR_READ_BAD_ && nRetData[i - 2] == IO_ON)
				{
					m_nPicker[TYPE_FLAG_][i] = CTL_YES;	// 동작할 Vacuum으로 설정
				}
			}
		}
		else if (nzSite == SIDE_REAR_)	// NG Buffer SIDE_REAR
		{
			for(i = 0; i < 2; i++)
			{
				// Gripper 1, 2의 바코드 정보가  BCR_READ_BAD_ 일경우 NG Buffer 3, 4에서 보급 하기위해 동작할 Vacuum으로 설정
				if(st_map.nBCR_State[i] == BCR_READ_BAD_ && nRetData[i + 2] == IO_ON)
				{
					m_nPicker[TYPE_FLAG_][i] = CTL_YES;	// 동작할 Vacuum으로 설정
				}
			}
		}

		m_nStep_NGBufferPick= 310;
		break;

	case 310:
		// Z축 모터를 NG 버퍼에서 악세사리 집기 위한 위치로 이동
		nRet = COMI.Start_SingleMove(m_nMotZ, st_motor[m_nMotZ].d_pos[Z_RBT_ACC_NG_BUFFER_PICK_], (int)st_handler.md_run_speed);
		if (nRet == CTLBD_RET_GOOD)
		{
			// 동작 상 무리가 없어 보이고 동작 시간 줄이기 위해 이곳에서 동작시킴
			// - m_nPicker[FLAG_INFO] : [case 300:]에서 설정됨
			OnSet_SolVacuum(IO_ON, m_nPicker[TYPE_FLAG_]);	// 그립퍼 Vacuum [ON:진공설정, OFF:진공해제]
			m_nStep_NGBufferPick= 320;
		}
		else if (nRet == CTLBD_RET_ERROR || nRet == CTLBD_RET_SAFETY)
		{
			// 071002 0 00 "BARCODE_ROBOT_Z_RBT_ACC_NG_BUFFER_PICK_MOVE_ERR."
			alarm.mstr_code		= "071002";
			alarm.mn_count_mode	= 0;
			alarm.mn_type_mode	= eWARNING;
			st_work.nEqpStatus	= dWARNING;
		}
		break;

	case 320:
		nRet = COMI.Check_SingleMove(m_nMotZ, st_motor[m_nMotZ].d_pos[Z_RBT_ACC_NG_BUFFER_PICK_]);
		if (nRet == CTLBD_RET_GOOD)
		{
			m_nStep_NGBufferPick= 330;
		}
		else if (nRet == CTLBD_RET_ERROR || nRet == CTLBD_RET_SAFETY)
		{
			m_nStep_NGBufferPick= 310;
			
			// 071002 0 00 "BARCODE_ROBOT_Z_RBT_ACC_NG_BUFFER_PICK_MOVE_ERR."
			alarm.mstr_code		= "071002";
			alarm.mn_count_mode	= 0;
			alarm.mn_type_mode	= eWARNING;
			st_work.nEqpStatus	= dWARNING;
		}
		else if (nRet == CTLBD_RET_RETRY)
		{
			m_nStep_NGBufferPick= 310;
		}
		break;

	case 330:
		nRet = OnGet_SolVacuum(IO_ON, m_nPicker[TYPE_FLAG_], m_nPicker[TYPE_SEN_]);
		// 어찌되었던 동작이 완료될때까지 대기
		// - 피커를 들고 알람을 출력시키기 위함
		if (nRet == CTL_GOOD || nRet == CTL_ERROR)
		{
			m_nStep_NGBufferPick= 340;
		}
		break;

	case 340:
		nRet = CTL_Lib.OnSingleMove(m_nMotZ, st_motor[m_nMotZ].d_pos[Z_RBT_SAFETY_], (int)st_handler.md_run_speed);
		if (nRet == CTLBD_RET_GOOD)
		{
			m_lTime_GoesBy[0] = GetCurrentTime();
			m_nStep_NGBufferPick= 350;
		}
		else if (nRet == CTLBD_RET_ERROR || nRet == CTLBD_RET_RETRY)
		{
			// 071005 0 07 "BARCODE_ROBOT_Z_RBT_SAFETY_MOVE_ERR."
			alarm.mstr_code		= "071005";
			alarm.mn_count_mode	= 0;
			alarm.mn_type_mode	= eWARNING;
			st_work.nEqpStatus	= dWARNING;
		}
		break;

	case 350:
		// 그립퍼의 자재 상태 반환
		// - m_nPicker : [case 300:]에서 설정됨
		nRet = Func.OnGet_PickerStatus(0, CTL_YES, m_nPicker);
		if (nRet == CTL_ERROR)
		{
			m_lTime_GoesBy[1] = GetCurrentTime();
			m_lTime_GoesBy[2] = m_lTime_GoesBy[1] - m_lTime_GoesBy[0];
			if (m_lTime_GoesBy[2] < 0)
			{
				m_lTime_GoesBy[0] = GetCurrentTime();
				break;
			}
			
			if (m_lTime_GoesBy[2] < 10)
			{
				break;
			}
		}
		// [자재 정상] : 곧바로 밑에 부분 실행
		// [자재 에러] : 일정 시간 대기 후에 밑에 부분 실행
		
		// 전체 그립퍼 갯수 가운데
		for(i=0; i<MAX_PICKER_; i++)
		{
			// 악세사리 집기 동작 진행한 그리퍼에 한해서 악세사리가 Vacuum 센서에 감지된 경우
			if (m_nPicker[TYPE_FLAG_][i] == CTL_YES && m_nPicker[TYPE_SEN_][i] == CTL_YES)
			{
				// 그립퍼의 구조체 정보 갱신 [자재 지었음]
				st_map.nXYZRbtPickerInfo[i]	= CTL_YES;
				m_nPicker[TYPE_FLAG_][i]	= CTL_NO;
				// 바코드 구조체 정보 갱싱 [Good 자재]
				st_map.nBCR_State[i]		= BCR_READ_GOOD_;
				if (nzSite == SIDE_BOTH_)	// NG Buffer SIDE_BOTH_
				{
					st_map.nNGBuffer[i] = CTL_NO;
					st_work.sRbtBCR_Data[i] = st_work.sNGBufferBCR_Data[i];
					st_work.sNGBufferBCR_Data[i] = "";
				}
				else if (nzSite == SIDE_FRONT_) // NG Buffer SIDE_FRONT
				{
					st_map.nNGBuffer[i-2] = CTL_NO;
					st_work.sRbtBCR_Data[i] = st_work.sNGBufferBCR_Data[i-2];
					st_work.sNGBufferBCR_Data[i-2] = "";
				}
				else if (nzSite == SIDE_REAR_)	// NG Buffer SIDE_REAR
				{
					st_map.nNGBuffer[i+2] = CTL_NO;
					st_work.sRbtBCR_Data[i] = st_work.sNGBufferBCR_Data[i+2];
					st_work.sNGBufferBCR_Data[i+2] = "";
				}
			}
		}
		
		// OnGet_PickerStatus() 함수에서는 [CTL_GOOD/CTL_ERROR] 반환되었을 것임
		if (nRet == CTL_GOOD)
		{
			m_nStep_NGBufferPick= 1000;
		}
		else
		{
			m_nRepickCount++;	// 재시도 횟수 증가
			if (m_nRepickCount > 2)
			{
				m_nRepickCount = 2;
			}
			m_nStep_NGBufferPick= 310;	// 악세사리 집기 동작 재시도
			
			if (m_nRepickCount >= 2)
			{
				m_nRepickCount = 0;	// [리셋] 자재 집기 시도 횟수
				
				// OnGet_PickerStatus() 함수 안에서 알람 코드 설정됨
				alarm.mn_count_mode	= 0;
				alarm.mn_type_mode	= eWARNING;
				st_work.nEqpStatus	= dWARNING;
			}
		}
		break;
		//==========================================================//

	case 1000:
		m_nStep_NGBufferPick = 0;
		nFuncRet = CTL_GOOD;
		break;
	}
	return nFuncRet;
}

//==================================================================//
// [Main<-Accy] 공급용 레일에 4개 악세사리 한꺼번에 내려놓기
// 규이리 추가 [2015.03.25]
//==================================================================//
int CSeq_XYZRobot::OnProc_4BufferPlace() 
{
	Func.OnTrace_ThreadStep(22, m_nStep_BufferConvPlace);	// 쓰레드 스텝 정보 TRACE
	int nFuncRet = CTL_PROCEED;	// 함수 리턴 플래그

	int nRet = VAR_INIT_;
	int nRetData[4] = {0,};
	int i=0, iExist;
	int iCheckCount = 0;	// 내려놓은 악세사리 갯수

	switch(m_nStep_BufferConvPlace)
	{
	case 0:
		nRet = CTL_Lib.OnSingleMove(m_nMotZ, st_motor[m_nMotZ].d_pos[Z_RBT_SAFETY_], (int)st_handler.md_run_speed);
		if (nRet == CTLBD_RET_GOOD)
		{
			if (st_basic.nMode_GripUsing == GRIP_USING)
			{
				m_nStep_BufferConvPlace = 100;
			}
			else if (st_basic.nMode_VacUsing == VAC_USING)
			{
				m_nStep_BufferConvPlace = 10;
			}
		}
		else if (nRet == CTLBD_RET_ERROR || nRet == CTLBD_RET_RETRY)
		{
			// 071005 0 0 "BARCODE_ROBOT_Z_RBT_SAFETY_MOVE_ERR"
			alarm.mstr_code		= "071005";
			alarm.mn_count_mode	= 0;
			alarm.mn_type_mode	= eWARNING;
			st_work.nEqpStatus	= dWARNING;
		}
		break;

		//==========================================================//
		// Vacuum 사용 모드
		//==========================================================//
	case 10:
		for(i=0; i<MAX_PICKER_; i++)
		{
			m_nPicker[TYPE_FLAG_][i] = st_map.nXYZRbtPickerInfo[i];
		}
		m_lTime_GoesBy[0] = GetCurrentTime();
		m_nStep_BufferConvPlace = 20;
		break;

	case 20:
		// 피커의 자재 존재 상태 반환
		nRet = Func.OnGet_PickerStatus(0, CTL_YES, m_nPicker);
		if (nRet == CTL_ERROR)
		{
			m_lTime_GoesBy[1] = GetCurrentTime();
			m_lTime_GoesBy[2] = m_lTime_GoesBy[1] - m_lTime_GoesBy[0];
			if (m_lTime_GoesBy[2] < 0)
			{
				m_lTime_GoesBy[0] = GetCurrentTime();
				break;
			}
			
			if (m_lTime_GoesBy[2] < 10)
			{
				break;
			}
		}
		
		// OnGet_PickerStatus() 함수에서는 [CTL_GOOD/CTL_ERROR] 반환되었을 것임
		if (nRet == CTL_GOOD)
		{
			m_nStep_BufferConvPlace = 50;
		}
		else
		{
			// OnGet_PickerStatus() 함수 안에서 알람 코드 설정됨
			alarm.mn_count_mode	= 0;
			alarm.mn_type_mode	= eWARNING;
			st_work.nEqpStatus	= dWARNING;
		}
		break;

	case 50:
		// 전체 피커 갯수 가운데
		for(i=0; i<MAX_PICKER_; i++)
		{
			m_nPicker[TYPE_FLAG_][i] = CTL_NO;
			
			// 자재 존재 여부를 검사 [구조체 플래그 정보]
			// - 악세사리 내려놓는 동작을 진행할 피커를 설정
			iExist = st_map.nXYZRbtPickerInfo[i];
			if (iExist == CTL_YES)
			{
				m_nPicker[TYPE_FLAG_][i] = CTL_YES;	// 동작할 피커로 설정
			}
		}
		m_nStep_BufferConvPlace = 100;
		break;
		//==========================================================//

	case 100:
		// 이동할 모터 위치 설정
		m_dTargetPos = st_motor[m_nMotY].d_pos[Y_RBT_ACC_CONV_R_BUFF_];
		
		nRet = CTL_Lib.OnSingleMove(m_nMotY, m_dTargetPos, (int)st_handler.md_run_speed);
		if (nRet == CTLBD_RET_GOOD)
		{
			if (st_basic.nMode_GripUsing == GRIP_USING)
			{
				// [Conv->Xyz] 악세사리 공급 요청 기다림
				if (stSync.nResp_BufferAlaignConv2XYZRbt_Work == SYNC_RESP_LOADING_)
				{
					m_nStep_BufferConvPlace = 200;
				}
				else
				{
					m_nStep_BufferConvPlace = 150;
				}
			}
			else if (st_basic.nMode_VacUsing == VAC_USING)
			{
				m_lTime_GoesBy[0] = GetCurrentTime();
				m_nStep_BufferConvPlace = 110;	// Vacuum 사용 모드
			}
		}
		else if (nRet == CTLBD_RET_ERROR || nRet == CTLBD_RET_RETRY)
		{
			// 051011 0 0 "BARCODE_ROBOT_X_RBT_ACC_BUFFER_CONV_MOVE_ERR"
			alarm.mstr_code		= "051011";
			alarm.mn_count_mode	= 0;
			alarm.mn_type_mode	= eWARNING;
			st_work.nEqpStatus	= dWARNING;
		}
		break;

		//==========================================================//
		// Vacuum 사용 모드
		//==========================================================//
	case 110:
		// 피커의 자재 존재 상태 반환
		nRet = Func.OnGet_PickerStatus(0, CTL_YES, m_nPicker);
		if (nRet == CTL_ERROR)
		{
			m_lTime_GoesBy[1] = GetCurrentTime();
			m_lTime_GoesBy[2] = m_lTime_GoesBy[1] - m_lTime_GoesBy[0];
			if (m_lTime_GoesBy[2] < 0)
			{
				m_lTime_GoesBy[0] = GetCurrentTime();
				break;
			}
			
			if (m_lTime_GoesBy[2] < 10)
			{
				break;
			}
		}
		
		// OnGet_PickerStatus() 함수에서는 [CTL_GOOD/CTL_ERROR] 반환되었을 것임
		if (nRet == CTL_GOOD)
		{
			// [Conv->Xyz] 악세사리 공급 요청 기다림
			if (stSync.nResp_BufferAlaignConv2XYZRbt_Work == SYNC_RESP_LOADING_)
			{
				m_nStep_BufferConvPlace = 200;
			}
			else
			{
				m_nStep_BufferConvPlace = 150;
			}
		}
		else
		{
			// OnGet_PickerStatus() 함수 안에서 알람 코드 설정됨
			alarm.mn_count_mode	= 0;
			alarm.mn_type_mode	= eWARNING;
			st_work.nEqpStatus	= dWARNING;
		}
		break;
		//==========================================================//

	case 150:
		// [Conv->Xyz] 악세사리 공급 요청 기다림
		if (stSync.nResp_BufferAlaignConv2XYZRbt_Work == SYNC_RESP_LOADING_)
		{
			m_nStep_BufferConvPlace = 200;
		}
		else
		{
			m_nStep_BufferConvPlace = 160;

		}
		break;

	case 160:
		// Conv에 악세사리 내려놓는 시간을 줄이기 위하여 특정 위치까지 강제로 내림
		//m_dTargetPos = st_motor[m_nMotZ].d_pos[Z_RBT_ACC_BUFFER_CONV_PLACE_] -40;
		// kilee [2015.03.29]
		m_dTargetPos = st_motor[m_nMotZ].d_pos[Z_RBT_ACC_BUFFER_CONV_PLACE_] -15;

		nRet = CTL_Lib.OnSingleMove(m_nMotZ, m_dTargetPos, (int)st_handler.md_run_speed);
		if (nRet == CTLBD_RET_GOOD)
		{
			m_nStep_BufferConvPlace = 170;
		}
		else if (nRet == CTLBD_RET_ERROR || nRet == CTLBD_RET_RETRY)
		{
			// 071005 0 0 "BARCODE_ROBOT_Z_RBT_SAFETY_MOVE_ERR"
			alarm.mstr_code		= "071005";
			alarm.mn_count_mode	= 0;
			alarm.mn_type_mode	= eWARNING;
			st_work.nEqpStatus	= dWARNING;
		}
		break;

	case 170:
		// [Conv->Xyz] 악세사리 공급 요청 기다림
		if (stSync.nResp_BufferAlaignConv2XYZRbt_Work == SYNC_RESP_LOADING_)
		{
			m_nStep_BufferConvPlace = 200;
		}
		break;

	case 200:
		// 악세사리 내려놓는 위치로 Z축 모터 이동
		nRet = CTL_Lib.OnSingleMove(m_nMotZ, st_motor[m_nMotZ].d_pos[Z_RBT_ACC_BUFFER_CONV_PLACE_]  -15, (int)st_handler.md_run_speed);
		if (nRet == CTLBD_RET_GOOD)
		{
			if (st_basic.nMode_GripUsing == GRIP_USING)
			{
				m_nStep_BufferConvPlace = 300;	// Grip 사용 모드
			}
			else if (st_basic.nMode_VacUsing == VAC_USING)
			{
				m_nStep_BufferConvPlace = 400;	// Vacuum 사용 모드
			}
		}
		else if (nRet == CTLBD_RET_ERROR || nRet == CTLBD_RET_RETRY)
		{
			// 071004 0 0 "BARCODE_ROBOT_Z_RBT_ACC_BUFFER_CONV_MOVE_ERR"
			alarm.mstr_code		= "071004";
			alarm.mn_count_mode	= 0;
			alarm.mn_type_mode	= eWARNING;
			st_work.nEqpStatus	= dWARNING;
		}
		break;

		// 그립퍼 사용 시 처리 스텝
	case 300:
		// [0],[1],[2],[3] Grip Off
		nRet = OnProc_Grip(15, IO_OFF);
		if (nRet == CTLBD_RET_GOOD)
		{
			for(i=0; i<MAX_PICKER_; i++)
			{
				if (st_basic.n_mode_device == WITHOUT_DVC_)
				{
					stWithoutData.nBufferConv[i] = st_map.nBCR_State[i];
				}
				
				st_map.nBufferCovAccyExist[i] = st_map.nBCR_State[i];
				if (st_map.nBCR_State[i] == BCR_READ_GOOD_)
				{
					st_work.sBufferConvBCR_Data[i] = st_work.sRbtBCR_Data[i];
					st_work.sRbtBCR_Data[i] = "";
				}
			}

			if (st_handler.cwnd_main != NULL)
			{
				st_handler.cwnd_main->PostMessage(WM_UPDATE_MAIN, PLACE_BUFFER_CONV_);	// 화면 표시 요청
			}
			m_nStep_BufferConvPlace = 500;
		}
		break;

		//==========================================================//
		// Vacuum 사용 모드
		//==========================================================//
	case 400:
		// 전체 피커 갯수 가운데
		for(i=0; i<MAX_PICKER_; i++)
		{
			m_nPicker[TYPE_FLAG_][i] = CTL_NO;

			// 자재 존재 여부를 검사 [구조체 플래그 정보]
			// - 악세사리 내려놓는 동작을 진행할 피커를 설정
			iExist = st_map.nBCR_State[i];
			if (iExist == BCR_READ_GOOD_)
			{
				m_nPicker[TYPE_FLAG_][i] = CTL_YES;	// 동작할 피커로 설정
			}
		}
		m_nStep_BufferConvPlace = 430;
		break;

	case 430:
		OnSet_SolVacuum(IO_OFF, m_nPicker[TYPE_FLAG_]);	// 그립퍼 Vacuum [ON:진공설정, OFF:진공해제]
		m_nStep_BufferConvPlace = 450;
		break;

	case 450:
		nRet = OnGet_SolVacuum(IO_OFF, m_nPicker[TYPE_FLAG_], m_nPicker[TYPE_SEN_]);
		// 어찌되었던 동작이 완료될때까지 대기
		// - 피커를 들고 알람을 출력시키기 위함
		if (nRet == CTL_GOOD || nRet == CTL_ERROR)
		{
			m_nStep_BufferConvPlace = 500;
		}
		break;
		//==========================================================//

	case 500:
		// 규이리 수정 [2015.03.25]
		// 동작 속도를 높이기 위해 수정함
		if (st_basic.nMode_GripUsing == GRIP_USING)
		{
			m_nStep_BufferConvPlace = 1000;	// Grip 사용 모드
		}
		else if (st_basic.nMode_VacUsing == VAC_USING)
		{
			m_lTime_GoesBy[0] = GetCurrentTime();
			m_nStep_BufferConvPlace = 520;	// Vacuum 사용 모드
		}
		break;

		//==========================================================//
		// Vacuum 사용 모드
		//==========================================================//
	case 520:
		// 그립퍼의 악세사리 존재 여부 확인
		// - 악세사리를 Conv에 내려놓았으므로 감지되면 안됨
		// - m_nPicker : [case 400:]에서 설정됨
		nRet = Func.OnGet_PickerStatus(0, CTL_NO, m_nPicker);
		if (nRet == CTL_ERROR)
		{
			m_lTime_GoesBy[1] = GetCurrentTime();
			m_lTime_GoesBy[2] = m_lTime_GoesBy[1] - m_lTime_GoesBy[0];
			if (m_lTime_GoesBy[2] < 0)
			{
				m_lTime_GoesBy[0] = GetCurrentTime();
				break;
			}
			
			if (m_lTime_GoesBy[2] > 10)
			{
				// OnGet_PickerStatus() 함수 안에서 알람 코드 설정됨
				alarm.mn_count_mode	= 0;
				alarm.mn_type_mode	= eWARNING;
				st_work.nEqpStatus	= dWARNING;
			}
			break;
		}

		// 전체 피커 갯수 가운데
		for(i=0; i<MAX_PICKER_; i++)
		{
			// 악세사리 내려놓기 동작을 한 피커에 한해서 실재로 자재를 내려놓은 경우 (센서에 미감지)
			if (m_nPicker[TYPE_FLAG_][i] == CTL_YES && m_nPicker[TYPE_SEN_][i] == CTL_NO)
			{
				// 그립퍼의 구조체 정보 갱신 [자재 지었음]
				st_map.nXYZRbtPickerInfo[i]	= CTL_NO;

				// 위 스텝에서 다시 초기화 시킨 후 재설정하기 때문에 필요는 없지만..
				m_nPicker[TYPE_FLAG_][i]	= CTL_NO;
			}

			if (st_basic.n_mode_device == WITHOUT_DVC_)
			{
				stWithoutData.nBufferConv[i] = st_map.nBCR_State[i];
			}
			
			st_map.nBufferCovAccyExist[i] = st_map.nBCR_State[i];
			if (st_map.nBCR_State[i] == BCR_READ_GOOD_)
			{
				st_work.sBufferConvBCR_Data[i] = st_work.sRbtBCR_Data[i];
				st_work.sRbtBCR_Data[i] = "";
			}
		}

		if (st_handler.cwnd_main != NULL)
		{
			st_handler.cwnd_main->PostMessage(WM_UPDATE_MAIN, PLACE_BUFFER_CONV_);	// 화면 표시 요청
		}
		m_nStep_BufferConvPlace = 1000;
		break;
		//==========================================================//

	case 1000:
		// 규이리 수정 [2015.03.25]
		m_nStep_BufferConvPlace = 0;
		nFuncRet = CTL_GOOD;
		break;
	}
	return nFuncRet;
}
